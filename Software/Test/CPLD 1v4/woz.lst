                      (          woz.asm):00001                 INCLUDE "hd6309_hardware.inc"
                      (hd6309_hardware.i):00001         ;
                      (hd6309_hardware.i):00002         ; 512B from $E000-$E1FF is reserved for I/O devices:
                      (hd6309_hardware.i):00003         ; Z8536 CIO at $E000, Z85C30 SCC at $E010
                      (hd6309_hardware.i):00004         
     E000             (hd6309_hardware.i):00005         IOPAGE   EQU      $E000                             ; Base address of I/O page
     E000             (hd6309_hardware.i):00006         ZCIO     EQU      IOPAGE+$00                        ; CIO base address
     E000             (hd6309_hardware.i):00007         CIOC     EQU      ZCIO                              ; CIO port C access
     E001             (hd6309_hardware.i):00008         CIOB     EQU      ZCIO+1                            ; CIO port B access
     E002             (hd6309_hardware.i):00009         CIOA     EQU      ZCIO+2                            ; CIO port A access
     E003             (hd6309_hardware.i):00010         CIOCTL   EQU      ZCIO+3                            ; CIO control register
                      (hd6309_hardware.i):00011         
     E010             (hd6309_hardware.i):00012         ZSCC     EQU      IOPAGE+$10                        ; SCC base address
     E010             (hd6309_hardware.i):00013         ZSCCBC   EQU      ZSCC                              ;   SCC channel B command reg
     E011             (hd6309_hardware.i):00014         ZSCCBD   EQU      ZSCC+1                            ;   SCC channel B data reg
     E012             (hd6309_hardware.i):00015         ZSCCAC   EQU      ZSCC+2                            ;   SCC channel A command reg
     E013             (hd6309_hardware.i):00016         ZSCCAD   EQU      ZSCC+3                            ;   SCC channel A data reg
     0001             (hd6309_hardware.i):00017         ZSCC.RXBF EQU     $01                               ; BIT MASK FOR RX BUFFER FULL
     0004             (hd6309_hardware.i):00018         ZSCC.TXBE EQU     $04                               ; BIT MASK FOR TX BUFFER EMPTY
                      (hd6309_hardware.i):00019         
                      (hd6309_hardware.i):00020         ; I2CPORT at $E020
                      (hd6309_hardware.i):00021         ;
                      (hd6309_hardware.i):00022         ;       7     6    5    4     3     2    1    0
                      (hd6309_hardware.i):00023         ;        [DSCL][DSDA][---][---][MSCL][MSDA][---][---]
                      (hd6309_hardware.i):00024         ;      rw    rw    r    r    r     r     r    r
                      (hd6309_hardware.i):00025         ;      1     1     0    0    x     x     0    0
                      (hd6309_hardware.i):00026         ;
                      (hd6309_hardware.i):00027         ; DSCL == drive SCL 1 --> float SCL ; 0 --> drive SCL low
                      (hd6309_hardware.i):00028         ; DSDA == drive SDA 1 --> float SDA ; 0 --> drive SDA low
                      (hd6309_hardware.i):00029         ; MSCK == monitor SCL --> state of SCL
                      (hd6309_hardware.i):00030         ; MSDA == monitor SDA --> state of SDA
                      (hd6309_hardware.i):00031         
     E020             (hd6309_hardware.i):00032         I2CPORT  EQU      IOPAGE+$20                        ;soft I2C port
     0080             (hd6309_hardware.i):00033         I2C.DSCL EQU      $80
     0040             (hd6309_hardware.i):00034         I2C.DSDA EQU      $40
     0008             (hd6309_hardware.i):00035         I2C.MSCL EQU      $08
     0004             (hd6309_hardware.i):00036         I2C.MSDA EQU      $04
                      (hd6309_hardware.i):00037         
                      (hd6309_hardware.i):00038         ; SDCARD port at $E030
                      (hd6309_hardware.i):00039         ;    8 bits of data to transfer via SPI
                      (hd6309_hardware.i):00040         
     E030             (hd6309_hardware.i):00041         SDPORT   EQU      IOPAGE+$30                        ; SDPORT register address
                      (hd6309_hardware.i):00042         
                      (hd6309_hardware.i):00043         ; SYSTEM CONFIG port at $E040
                      (hd6309_hardware.i):00044         ;       7    6    5    4    3     2     1      0
                      (hd6309_hardware.i):00045         ;        [---][---][---][CONF][RA14][ROMH][ROML][ROMWS]
                      (hd6309_hardware.i):00046         ;      r    r    r    r     rw    rw    rw    rw
                      (hd6309_hardware.i):00047         ;      0    0    0    x     1     1     1     1
                      (hd6309_hardware.i):00048         ;
                      (hd6309_hardware.i):00049         ;  CONF == status of CONFIG jumper
                      (hd6309_hardware.i):00050         ;  RA14 == control ROM pin 27 (default to CONFIG jumper at reset)
                      (hd6309_hardware.i):00051         ;  ROMH == 1 --> bank ROM over $E200-$FFFF during reads (writes always go to RAM)
                      (hd6309_hardware.i):00052         ;  ROML == 1 --> bank ROM over $C000-$DFFF during reads (writes always go to RAM)
                      (hd6309_hardware.i):00053         ;  ROMWS == 1 --> insert wait state for ROM access; 0 --> no wait states for ROM
                      (hd6309_hardware.i):00054         
     E040             (hd6309_hardware.i):00055         SYSCFG   EQU      IOPAGE+$40                        ; SYSCFG register address
     0001             (hd6309_hardware.i):00056         SYS.ROMWS EQU     $01
     0002             (hd6309_hardware.i):00057         SYS.ROMSEL EQU    $02
     0004             (hd6309_hardware.i):00058         SYS.ROMSEH EQU    $04
     0008             (hd6309_hardware.i):00059         SYS.RA14 EQU      $08
                      (hd6309_hardware.i):00060         
                      (hd6309_hardware.i):00061         ; INPUT-OUTPUT port at $E050
                      (hd6309_hardware.i):00062         ;       7     6      5      4    3  2    1     0
                      (hd6309_hardware.i):00063         ;    [SDSW][SDBSY][SDCLK][SDCS][PB][0][LED2][LED1]
                      (hd6309_hardware.i):00064         ;       I     I      O      O    x       O     O
                      (hd6309_hardware.i):00065         ;  all bits readable, output bits readback
                      (hd6309_hardware.i):00066         ;
                      (hd6309_hardware.i):00067         ;  SDSW == 1 when SD card is inserted
                      (hd6309_hardware.i):00068         ;  SDBSY == 1 while SPI transaction is taking place
                      (hd6309_hardware.i):00069         ;  SDCLK = 1 --> slow SPI clock; 0 --> fast SPI clock
                      (hd6309_hardware.i):00070         ;  SDCS = 1 --> CS signal to SDcard negated; 0 --> asserted
                      (hd6309_hardware.i):00071         ;  PB == 1 when pushbutton is pressed
                      (hd6309_hardware.i):00072         ;  LEDn = 1 --> illuminate corresponding LED
                      (hd6309_hardware.i):00073         
     E050             (hd6309_hardware.i):00074         IOPORT   EQU      IOPAGE+$50                        ; INOUT register address
     0001             (hd6309_hardware.i):00075         IO.LED1  EQU      $01
     0002             (hd6309_hardware.i):00076         IO.LED2  EQU      $02
     0008             (hd6309_hardware.i):00077         IO.PB    EQU      $08
     0010             (hd6309_hardware.i):00078         IO.SDCS  EQU      $10
     0020             (hd6309_hardware.i):00079         IO.SDCLK EQU      $20
     0040             (hd6309_hardware.i):00080         IO.SDBSY EQU      $40
     0080             (hd6309_hardware.i):00081         IO.SDSW  EQU      $80
                      (hd6309_hardware.i):00082         
     E060             (hd6309_hardware.i):00083         CPLDVER  EQU      IOPAGE+$60                        ; CPLD VERSION register address
                      (hd6309_hardware.i):00084         
                      (hd6309_hardware.i):00085         ;; IOPORT LED and PB interface primitives
0000                  (hd6309_hardware.i):00086         OnLED1   MACRO
                      (hd6309_hardware.i):00087                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
                      (hd6309_hardware.i):00088                  ENDM
                      (hd6309_hardware.i):00089         
0000                  (hd6309_hardware.i):00090         OffLED1  MACRO
                      (hd6309_hardware.i):00091                  AIM      #~IO.LED1,IOPORT                  ; turn off LED1
                      (hd6309_hardware.i):00092                  ENDM
                      (hd6309_hardware.i):00093         
0000                  (hd6309_hardware.i):00094         ToggleLED1 MACRO
                      (hd6309_hardware.i):00095                  EIM      #IO.LED1,IOPORT                   ; toggle LED1
                      (hd6309_hardware.i):00096                  ENDM
                      (hd6309_hardware.i):00097         
0000                  (hd6309_hardware.i):00098         OnLED2   MACRO
                      (hd6309_hardware.i):00099                  OIM      #IO.LED2,IOPORT                   ; turn on LED2
                      (hd6309_hardware.i):00100                  ENDM
                      (hd6309_hardware.i):00101         
0000                  (hd6309_hardware.i):00102         OffLED2  MACRO
                      (hd6309_hardware.i):00103                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
                      (hd6309_hardware.i):00104                  ENDM
                      (hd6309_hardware.i):00105         
0000                  (hd6309_hardware.i):00106         ToggleLED2 MACRO
                      (hd6309_hardware.i):00107                  EIM      #IO.LED2,IOPORT                   ; toggle LED2
                      (hd6309_hardware.i):00108                  ENDM
                      (hd6309_hardware.i):00109                  
0000                  (hd6309_hardware.i):00110         OnLEDS   MACRO
                      (hd6309_hardware.i):00111                  OIM      #(IO.LED1+IO.LED2),IOPORT        ; turn on LED1 + LED2
                      (hd6309_hardware.i):00112                  ENDM
                      (hd6309_hardware.i):00113         
0000                  (hd6309_hardware.i):00114         OffLEDS  MACRO
                      (hd6309_hardware.i):00115                  AIM      #~(IO.LED1+IO.LED2),IOPORT       ; turn off LED1 + LED2
                      (hd6309_hardware.i):00116                  ENDM
                      (hd6309_hardware.i):00117         
0000                  (hd6309_hardware.i):00118         StatusPB MACRO
                      (hd6309_hardware.i):00119                  TIM      #IO.PB,IOPORT                     ; check the pushbutton
                      (hd6309_hardware.i):00120                  ENDM
                      (hd6309_hardware.i):00121         
                      (hd6309_hardware.i):00122         ;; I2C interface primitives
0000                  (hd6309_hardware.i):00123         I2C_StatSDA MACRO
                      (hd6309_hardware.i):00124                  TIM      #I2C.MSDA,I2CPORT                 ;(Z = 1 if SDA is low)
                      (hd6309_hardware.i):00125                  ENDM
                      (hd6309_hardware.i):00126         
0000                  (hd6309_hardware.i):00127         I2C_SinkSDA MACRO
                      (hd6309_hardware.i):00128                  AIM      #~I2C.DSDA,I2CPORT                ;Drive SDA line low
                      (hd6309_hardware.i):00129                  ENDM
                      (hd6309_hardware.i):00130         
0000                  (hd6309_hardware.i):00131         I2C_ReleaseSDA MACRO
                      (hd6309_hardware.i):00132                  OIM      #I2C.DSDA,I2CPORT                 ;Release SDA line
                      (hd6309_hardware.i):00133                  ENDM
                      (hd6309_hardware.i):00134         
0000                  (hd6309_hardware.i):00135         I2C_StatSCL MACRO
                      (hd6309_hardware.i):00136                  TIM      #I2C.MSCL,I2CPORT                 ;(Z = 1 if SCL is low)
                      (hd6309_hardware.i):00137                  ENDM
                      (hd6309_hardware.i):00138         
0000                  (hd6309_hardware.i):00139         I2C_SinkSCL MACRO
                      (hd6309_hardware.i):00140                  AIM      #~I2C.DSCL,I2CPORT                ;Drive SCL line low
                      (hd6309_hardware.i):00141                  ENDM
                      (hd6309_hardware.i):00142         
0000                  (hd6309_hardware.i):00143         I2C_ReleaseSCL MACRO
                      (hd6309_hardware.i):00144                  OIM      #I2C.DSCL,I2CPORT                 ;Release SCL line
                      (hd6309_hardware.i):00145                  ENDM
                      (hd6309_hardware.i):00146         
0000                  (hd6309_hardware.i):00147         I2C_ReleaseBoth MACRO
                      (hd6309_hardware.i):00148                  OIM      #(I2C.DSCL+I2C.DSDA),I2CPORT      ;Release both SDA and SCL lines
                      (hd6309_hardware.i):00149                  ENDM
                      (hd6309_hardware.i):00150                  
0000                  (hd6309_hardware.i):00151         I2C_BitDelay MACRO
                      (hd6309_hardware.i):00152                  NOP
                      (hd6309_hardware.i):00153                  ENDM         
                      (hd6309_hardware.i):00154         
0000                  (hd6309_hardware.i):00155         I2C_StretchSCL MACRO
0000                  (hd6309_hardware.i):00156         I?SSH    NOP
                      (hd6309_hardware.i):00157                  I2C_ReleaseSCL                             ; try to release SCL
                      (hd6309_hardware.i):00158                  NOP
                      (hd6309_hardware.i):00159                  I2C_StatSCL                                ; check is SCL is really high yet
                      (hd6309_hardware.i):00160                  BEQ      I?SSH                             ; if SCL is still low -> try again
                      (hd6309_hardware.i):00161                  ENDM
                      (hd6309_hardware.i):00162         
                      (hd6309_hardware.i):00163         ;; SPI interface primitives
0000                  (hd6309_hardware.i):00164         SPI_FastMode MACRO
                      (hd6309_hardware.i):00165                  AIM      #~IO.SDCLK,IOPORT                 ; set SPI to fast mode
                      (hd6309_hardware.i):00166                  ENDM
                      (hd6309_hardware.i):00167         
0000                  (hd6309_hardware.i):00168         SPI_SlowMode MACRO
                      (hd6309_hardware.i):00169                  OIM      #IO.SDCLK,IOPORT                  ; set SPI to slow mode
                      (hd6309_hardware.i):00170                  ENDM
                      (hd6309_hardware.i):00171         
0000                  (hd6309_hardware.i):00172         SPI_Status MACRO
                      (hd6309_hardware.i):00173                  TIM      #IO.SDBSY,IOPORT                  ; check the SPI busy bit (Z=0 means busy)
                      (hd6309_hardware.i):00174                  ENDM
                      (hd6309_hardware.i):00175         
                      (hd6309_hardware.i):00176         ;; SD card interface primitives
0000                  (hd6309_hardware.i):00177         SD_AssertCS MACRO
                      (hd6309_hardware.i):00178                  AIM      #~IO.SDCS,IOPORT                  ; assert SD card select
                      (hd6309_hardware.i):00179                  ENDM
                      (hd6309_hardware.i):00180         
0000                  (hd6309_hardware.i):00181         SD_NegateCS MACRO
                      (hd6309_hardware.i):00182                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
                      (hd6309_hardware.i):00183                  ENDM
                      (hd6309_hardware.i):00184         
0000                  (hd6309_hardware.i):00185         SD_CardPresent MACRO
                      (hd6309_hardware.i):00186                  TIM      #IO.SDSW,IOPORT                   ; examine SD card switch
                      (hd6309_hardware.i):00187                  ENDM
                      (          woz.asm):00002         
                      (          woz.asm):00003          ;  Condition Code Register bits
     0001             (          woz.asm):00004         CC_C    EQU     $01
     0002             (          woz.asm):00005         CC_V    EQU     $02
     0004             (          woz.asm):00006         CC_Z    EQU     $04
     0008             (          woz.asm):00007         CC_N    EQU     $08
     0010             (          woz.asm):00008         CC_I    EQU     $10
     0020             (          woz.asm):00009         CC_H    EQU     $20
     0040             (          woz.asm):00010         CC_F    EQU     $40
     0080             (          woz.asm):00011         CC_E    EQU     $80
                      (          woz.asm):00012         
                      (          woz.asm):00013          ;  Other defines
     0001             (          woz.asm):00014         TRUE    EQU     1
     0000             (          woz.asm):00015         FALSE   EQU     0
     000D             (          woz.asm):00016         CR      EQU     $0D
     000A             (          woz.asm):00017         LF      EQU     $0A
     0020             (          woz.asm):00018         SPACE   EQU     ' '
                      (          woz.asm):00019         
                      (          woz.asm):00020          ;  ROM Monitor 1v4 jump points
     E203             (          woz.asm):00021         GOWOZ   EQU     $E203
     E206             (          woz.asm):00022         GONOICE EQU     $E206
     E209             (          woz.asm):00023         GOBASIC EQU     $E209
                      (          woz.asm):00024         
                      (          woz.asm):00025          ;======================================================================
                      (          woz.asm):00026          ;         RAM STORAGE for WOZMON (RAM Based)
                      (          woz.asm):00027          ;======================================================================
                      (          woz.asm):00028                 ORG     $0F80
                      (          woz.asm):00029          ;
                      (          woz.asm):00030          ;  Initial user stack
     0F80             (          woz.asm):00031         INITSTACK EQU   *               ; user stack starts below monitor stack
     0F80             (          woz.asm):00032         WOZ_RAM EQU     *               ; storage for WOZMON input buffer, vars (on $80 bounardy)
                      (          woz.asm):00033         
                      (          woz.asm):00034                 ORG     $1000
                      (          woz.asm):00035          ;;======================================================================
                      (          woz.asm):00036          ;; WOZMON RESIDENT MONITOR
                      (          woz.asm):00037          ;;======================================================================
                      (          woz.asm):00038          ; This is adapted from Jeff Tranter's work, and is a port of WOZMON to
                      (          woz.asm):00039          ; my HD6309 SBC. Jeff's work can be found here:
                      (          woz.asm):00040          ; https://github.com/jefftranter/6809/blob/master/sbc/wozmon/wozmon.asm
                      (          woz.asm):00041          ;
                      (          woz.asm):00042          ; This code uses SCC UART functions that are already present elsewhere
                      (          woz.asm):00043          ; in this ROM. I've tweaked it a bit in terms of cleanup and taking
                      (          woz.asm):00044          ; advantage of 6809/6309 architecture. I've added an "X" command to
                      (          woz.asm):00045          ; invoke an S-Record/Intel Hex loader (inspired by Dave Dunfield's
                      (          woz.asm):00046          ; 6809 monitor), an "N" command to invoke the ROM resident
                      (          woz.asm):00047          ; NoICE debugger, and an "M" command to invoke MSBASIC (resident in the
                      (          woz.asm):00048          ; alternate ROM bank). Finally, I added a crude 'flow control' to the
                      (          woz.asm):00049          ; NXTPRNT function, to allow pausing (^S), exit to newline (^C), and
                      (          woz.asm):00050          ; line-by-line (SPACE) during the dump. As such, the code is now much
                      (          woz.asm):00051          ; larger than the 256 bytes that Woz's original 6502 occupied!
                      (          woz.asm):00052          ;
                      (          woz.asm):00053          ; It was fun to study this old code, and I added some more comments to
                      (          woz.asm):00054          ; it to help w/ readability. I've migrated the syntax to that of William
                      (          woz.asm):00055          ; Astle's LWTOOLS 6809/6309 toolchain, which can be found here:
                      (          woz.asm):00056          ; http://www.lwtools.ca/
                      (          woz.asm):00057          ;
                      (          woz.asm):00058          ;***********************************************************************
                      (          woz.asm):00059          ;
                      (          woz.asm):00060          ; Following are notes from Jeff Tranter on this:
                      (          woz.asm):00061          ;
                      (          woz.asm):00062          ; This is a port of the 6800 version of Woz Mon to my 6809-based Single
                      (          woz.asm):00063          ; Board Computer. It was converted to 6809 instructions as well as
                      (          woz.asm):00064          ; ported to use the 6850 ACIA for input/output.
                      (          woz.asm):00065          ;
                      (          woz.asm):00066          ; The original 6800 port came from here: https://pastebin.com/TSM2DdRL
                      (          woz.asm):00067          ;
                      (          woz.asm):00068          ; Note: The code internally converts all characters to high ASCII (bit
                      (          woz.asm):00069          ; 7 = 1) because the Apple 1 used this format and the program logic is
                      (          woz.asm):00070          ; dependent on it in several places.
                      (          woz.asm):00071          ;
                      (          woz.asm):00072          ; The code is not quite small enough to fit in 256 bytes as the
                      (          woz.asm):00073          ; original 6502 and 6800 versions did.
                      (          woz.asm):00074          ;
                      (          woz.asm):00075          ;***********************************************************************
                      (          woz.asm):00076          ;
                      (          woz.asm):00077          ; This is a rewrite of the Apple 1 monitor to run on an MC6800
                      (          woz.asm):00078          ; microprocessor, rather than the MCS6502 microprocessor that
                      (          woz.asm):00079          ; was standard.  This source code will assemble with the
                      (          woz.asm):00080          ; AS Macro Assembler; with minor changes it should assemble
                      (          woz.asm):00081          ; with any MC6800 assembler.
                      (          woz.asm):00082         
                      (          woz.asm):00083          ; Copyright 2011 Eric Smith <eric@brouhaha.com>
                      (          woz.asm):00084          ;
                      (          woz.asm):00085          ; This program is free software; you can redistribute and/or modify it
                      (          woz.asm):00086          ; under the terms of the GNU General Public License version 3 as
                      (          woz.asm):00087          ; published by the Free Software Foundation.
                      (          woz.asm):00088          ;
                      (          woz.asm):00089          ; This program is distributed in the hope that it will be useful, but
                      (          woz.asm):00090          ; WITHOUT ANY WARRANTY; without even the implied warranty of
                      (          woz.asm):00091          ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                      (          woz.asm):00092          ; General Public License for more details.
                      (          woz.asm):00093          ;
                      (          woz.asm):00094          ; The text of the license may be found online at:
                      (          woz.asm):00095          ;     http://www.brouhaha.com/~eric/software/GPLv3
                      (          woz.asm):00096          ; or:
                      (          woz.asm):00097          ;     http://www.gnu.org/licenses/gpl-3.0.txt
                      (          woz.asm):00098         
                      (          woz.asm):00099          ; relative addresses of program variables
                      (          woz.asm):00100         
                      (          woz.asm):00101          ; first, determine WOZ_RAM absolute offset
     0F80             (          woz.asm):00102         W_OFFS  EQU     WOZ_RAM % 256
                      (          woz.asm):00103         
                      (          woz.asm):00104          ; next, establish the amount of line input buffer to allocate
     0078             (          woz.asm):00105         W_INLEN EQU     120             ; line input buffer length
                      (          woz.asm):00106         
                      (          woz.asm):00107          ; then, determine xx,U offset for XAM variable, because this gets used w/o DP reg, also
     0078             (          woz.asm):00108         W_XAM   EQU     W_INLEN
                      (          woz.asm):00109         
                      (          woz.asm):00110          ; finally, determine DP offset pointers to temporary variables
     0FF8             (          woz.asm):00111         W_dXAM  EQU     W_OFFS+W_INLEN  ; XAM address (+120/121)
     0FFA             (          woz.asm):00112         W_dST   EQU     W_OFFS+W_INLEN+2 ; STOR address  (+122/+123)   [A3 in new monitor]
     0FFC             (          woz.asm):00113         W_dMODE EQU     W_OFFS+W_INLEN+4 ; 'mode' is XAM, STOR, BLOCK XAM (+124)
     0FFD             (          woz.asm):00114         W_dTEMP EQU     W_OFFS+W_INLEN+5 ; temporary storage (+125)
     002E             (          woz.asm):00115         DOT     EQU     '.'
     00BA             (          woz.asm):00116         HI_COL  EQU     ':'+$80         ; msb set Colon
     00D1             (          woz.asm):00117         HI_Q    EQU     'Q'+$80         ; msb set "Q" - QUIT to ROM monitor command
     00D2             (          woz.asm):00118         HI_R    EQU     'R'+$80         ; msb set "R" - RUN command
     00D8             (          woz.asm):00119         HI_X    EQU     'X'+$80         ; msb set "X" - HEX LOAD command
     00CD             (          woz.asm):00120         HI_M    EQU     'M'+$80         ; msb set "M" - MS BASIC command
     00CE             (          woz.asm):00121         HI_N    EQU     'N'+$80         ; msb set "N" - NOICE command
     0013             (          woz.asm):00122         CTL_S   EQU     'S'-$40         ; control-S
     0008             (          woz.asm):00123         CTL_H   EQU     'H'-$40         ; control-H
     0018             (          woz.asm):00124         CTL_X   EQU     'X'-$40         ; control-X
     007F             (          woz.asm):00125         DEL     EQU     127             ; "Delete"
     001B             (          woz.asm):00126         ESC     EQU     '['-$40         ; ESCape
                      (          woz.asm):00127         
                      (          woz.asm):00128          ;; WOZMON - primary entry point
1000                  (          woz.asm):00129         WOZMON:
1000 10CE0F80         (          woz.asm):00130                 LDS     #INITSTACK      ; grow stack downward from reserved RAM
1004 CE0F80           (          woz.asm):00131                 LDU     #WOZ_RAM        ; point U at beginning of WOZ_RAM block
                      (          woz.asm):00132         
                      (          woz.asm):00133          ;; WOZMON2 - alternate entry point
                      (          woz.asm):00134          ;; inputs:  U = pointer to beginning of 128 bytes of RAM on same page boundary
                      (          woz.asm):00135          ;;          S = stack pointer already established!
1007                  (          woz.asm):00136         WOZMON2:
1007 30C878           (          woz.asm):00137                 LEAX    W_INLEN,U       ; absolute address of FIRST variable in X
100A 1F1B             (          woz.asm):00138                 TFR     X,DP            ; copy the MSB of the address to DP register
100C BD1271           (          woz.asm):00139                 JSR     SCC_InitA       ; init SCC channel A for 115.2kbps
100F 105F             (          woz.asm):00140                 CLRW                    ; reset WORD value
1011 1097F8           (          woz.asm):00141                 STW     <W_dXAM         ; reset XAM address
1014 1097FA           (          woz.asm):00142                 STW     <W_dST          ; reset STORE address
1017 201A             (          woz.asm):00143                 BRA     W_GETLINE       ; enter WOZMON
                      (          woz.asm):00144         
                      (          woz.asm):00145          ; Get a line of input from the keyboard, echoing to display.
                      (          woz.asm):00146          ; Normally enter at ESCAPE or GETLINE. Handle ^H and DEL as
                      (          woz.asm):00147          ; 'backspace' and ^X and ESC as 'cancel'. Otherwise accumulate
                      (          woz.asm):00148          ; characters in the buffer. Exit when a CR is received, and
                      (          woz.asm):00149          ; auto-cancel and resrtart when buffer length exceeds W_INLEN.
                      (          woz.asm):00150          ;
                      (          woz.asm):00151          ; U is pointer to line buffer and work variables
                      (          woz.asm):00152          ; B is the index into the buffer
                      (          woz.asm):00153         
1019                  (          woz.asm):00154         W_NOTCR:
1019 8108             (          woz.asm):00155                 CMPA    #CTL_H          ; CTRL-H? ["backspace"]
101B 2720             (          woz.asm):00156                 BEQ     W_BACKSPC       ;   yes, back up a character
101D 817F             (          woz.asm):00157                 CMPA    #DEL            ; DEL? ["delete"]
101F 271C             (          woz.asm):00158                 BEQ     W_BACKSPC       ;   yes, back up a character
1021 8118             (          woz.asm):00159                 CMPA    #CTL_X          ; CTRL-X? ["cancel"]
1023 2709             (          woz.asm):00160                 BEQ     W_CANCEL        ;   yes, abort line
1025 811B             (          woz.asm):00161                 CMPA    #ESC            ; ESC? ["escape"]
1027 2705             (          woz.asm):00162                 BEQ     W_CANCEL
1029 5C               (          woz.asm):00163                 INCB                    ; leave in buffer and advance text index.
102A C178             (          woz.asm):00164                 CMPB    #W_INLEN        ; are we at end of buffer?
102C 2512             (          woz.asm):00165                 BLO     W_NEXTCHR       ;   no, get another character
102E                  (          woz.asm):00166         W_CANCEL:
102E 865C             (          woz.asm):00167                 LDA     #'\'
1030 BD12D9           (          woz.asm):00168                 JSR     PUTCH           ; output a \
1033                  (          woz.asm):00169         W_GETLINE:
1033 BD12EB           (          woz.asm):00170                 JSR     PUTCR           ; start a new line
1036 8621             (          woz.asm):00171                 LDA     #'!'
1038 BD12D9           (          woz.asm):00172                 JSR     PUTCH           ; output a * prompt
103B C601             (          woz.asm):00173                 LDB     #1              ; Set offset to 1 (decremented next line)
103D                  (          woz.asm):00174         W_BACKSPC:
103D 5A               (          woz.asm):00175                 DECB                    ; Back up text index.
103E 2BF3             (          woz.asm):00176                 BMI     W_GETLINE       ; index<0 (start of line), reinitialize
1040                  (          woz.asm):00177         W_NEXTCHR:
1040 BD12A1           (          woz.asm):00178                 JSR     GETCHT          ; get a character from UART Ch A
1043 A7C5             (          woz.asm):00179                 STA     B,U             ; Add to text buffer.
1045 BD12D9           (          woz.asm):00180                 JSR     PUTCH           ; Display character.
1048 810D             (          woz.asm):00181                 CMPA    #CR             ; CR?
104A 26CD             (          woz.asm):00182                 BNE     W_NOTCR         ;   not a CR, keep getting input chars
                      (          woz.asm):00183                 ; fall into W_PARSE...
                      (          woz.asm):00184         
                      (          woz.asm):00185          ; Process an input line. Examine each character in the buffer. Handle
                      (          woz.asm):00186          ; CR (end of line), and "." (block mode) and ":" (store mode) cases. Character
                      (          woz.asm):00187          ; codes less than "." are treated as delimiters. The "R" character executes the
                      (          woz.asm):00188          ; RUN command, and the "X" character executes the S-Record download function.
                      (          woz.asm):00189          ; The "N" command jumps to NoICE debugger. The "M" command jumps to BASIC
                      (          woz.asm):00190          ; All other characters are assumed to be a hex input 'item' and parsed into
                      (          woz.asm):00191          ; W register.
                      (          woz.asm):00192          ;
                      (          woz.asm):00193          ; U is pointer to line buffer and work variables
                      (          woz.asm):00194          ; W is the WORD parsed from input line
                      (          woz.asm):00195          ; B is the index into the line buffer
                      (          woz.asm):00196          ; A is work register
                      (          woz.asm):00197          ; W_TEMP is used as part of zero-digit-length argument check
                      (          woz.asm):00198         
104C                  (          woz.asm):00199         W_PARSE:
104C 104F             (          woz.asm):00200                 CLRD                    ; clear both A and B (A used to set XAM mode soon)
104E 5A               (          woz.asm):00201                 DECB                    ; (B) text index -1, to become zero at BLSKIP
104F                  (          woz.asm):00202         W_SETMODE:
104F 97FC             (          woz.asm):00203                 STA     <W_dMODE        ; $00=XAM (0), $BA=STORE (-), $2E=BLOK XAM (+)
1051                  (          woz.asm):00204         W_BLSKIP:
1051 5C               (          woz.asm):00205                 INCB                    ; advance text index (B,U allows only 0...127)
1052                  (          woz.asm):00206         W_NEXTITEM:
1052 A6C5             (          woz.asm):00207                 LDA     B,U             ; Get character
1054 810D             (          woz.asm):00208                 CMPA    #CR             ; is it a CR?
1056 27DB             (          woz.asm):00209                 BEQ     W_GETLINE       ;  yes, done this line.
1058 812E             (          woz.asm):00210                 CMPA    #DOT            ; is it a period?
105A 27F3             (          woz.asm):00211                 BEQ     W_SETMODE       ; yes, set BLOCK XAM mode ($2E)
105C 23F3             (          woz.asm):00212                 BLS     W_BLSKIP        ;  less than periods are treated as delimiters
105E 8A80             (          woz.asm):00213                 ORA     #$80            ; convert high-bit set (for MODE stuff)
1060 81BA             (          woz.asm):00214                 CMPA    #HI_COL         ; is it a colon?
1062 27EB             (          woz.asm):00215                 BEQ     W_SETMODE       ;  yes, set STORE mode ($BA)
1064 81CD             (          woz.asm):00216                 CMPA    #HI_M           ; is it an "M"?  ("MS Basic")
1066 1027D19F         (          woz.asm):00217                 LBEQ    GOBASIC         ;   yes, jump to MS BASIC
106A 81CE             (          woz.asm):00218                 CMPA    #HI_N           ; is it an "N"?  ("NoICE")
106C 1027D196         (          woz.asm):00219                 LBEQ    GONOICE         ;   yes, start NoICE debugger
1070 81D1             (          woz.asm):00220                 CMPA    #HI_Q           ; is it a "Q"? ("Quit")
1072 1027D18D         (          woz.asm):00221                 LBEQ    GOWOZ           ;   yes, exit to WOZMON (ROM)
1076 81D2             (          woz.asm):00222                 CMPA    #HI_R           ; is it an "R"?  ("Run")
1078 272C             (          woz.asm):00223                 BEQ     W_RUN           ;   Yes, jump to current XAM index.
107A 81D8             (          woz.asm):00224                 CMPA    #HI_X           ; is it an "X"?  ("Hex")
107C 272B             (          woz.asm):00225                 BEQ     W_XLOAD         ;   yes, try to load hexfile from console
107E                  (          woz.asm):00226         W_NEWHEX:
107E 105F             (          woz.asm):00227                 CLRW                    ; clear W (HI = E, LO = F)
1080 D7FD             (          woz.asm):00228                 STB     <W_dTEMP        ; make a copy of text buffer index
1082                  (          woz.asm):00229         W_NEXTHEX:
1082 A6C5             (          woz.asm):00230                 LDA     B,U             ; Get character for hex test.
1084 8830             (          woz.asm):00231                 EORA    #$30            ; Map digits to $0-9.
1086 8109             (          woz.asm):00232                 CMPA    #$09            ; Digit?
1088 2308             (          woz.asm):00233                 BLS     W_ADDDIG        ; Yes.
108A 8A20             (          woz.asm):00234                 ORA     #$20            ; convert lower to uppercase
108C 8B89             (          woz.asm):00235                 ADDA    #$89            ; Map letter "A"-"F" to $FA-FF.
108E 81F9             (          woz.asm):00236                 CMPA    #$F9            ; Hex letter?
1090 231C             (          woz.asm):00237                 BLS     W_NOTHEX        ; No, character not hex.
1092                  (          woz.asm):00238         W_ADDDIG:
1092 840F             (          woz.asm):00239                 ANDA    #$0F            ; isolate the hex digit value ($0-$F)
1094 1E06             (          woz.asm):00240                 EXG     D,W             ; digit in 4lsb of E, WORD in D, buffer ptr in F
1096 1048             (          woz.asm):00241                 ASLD                    ; shift WORD left 4 bits to make room
1098 1048             (          woz.asm):00242                 ASLD                    ;   for the new hex nybble
109A 1048             (          woz.asm):00243                 ASLD
109C 1048             (          woz.asm):00244                 ASLD
109E 1035E9           (          woz.asm):00245                 ORR     E,B             ; OR the new digit in WORD
10A1 1E06             (          woz.asm):00246                 EXG     D,W             ; WORD back in W, buffer pointer back in B
10A3 5C               (          woz.asm):00247                 INCB                    ; advance text index
10A4 20DC             (          woz.asm):00248                 BRA     W_NEXTHEX       ; Always taken. Check next character for hex.
10A6                  (          woz.asm):00249         W_RUN:
10A6 6ED878           (          woz.asm):00250                 JMP     [W_XAM,U]       ; RUN command, jump to address in XAM index
10A9                  (          woz.asm):00251         W_XLOAD:
10A9 BD1125           (          woz.asm):00252                 JSR     DL_START0       ; yes, try to download from host
10AC 2085             (          woz.asm):00253                 BRA     W_GETLINE       ; get a new input line
                      (          woz.asm):00254         
                      (          woz.asm):00255          ; A non-hex, non-command character has been encountered. We may have a new
                      (          woz.asm):00256          ; hex argument in WORD (if W_TEMP = B, we do NOT) and if so, we need to figure
                      (          woz.asm):00257          ; out what to do with depending on MODE. If we are already in STOR mode, then
                      (          woz.asm):00258          ; we simply store the LSB of the WORD at address in ST, then increment ST.
                      (          woz.asm):00259          ; If we are in XAM mode (which includes the address entered prior to the ':' in
                      (          woz.asm):00260          ; the command line) then WORD argument is copied to XAM and ST addresses, and we
                      (          woz.asm):00261          ; fall into the NXTPRT loop. If we're already in BLOCK XAM mode, then we take the
                      (          woz.asm):00262          ; WORD argument as the end of the block, and fall in the NXTPRT loop.
                      (          woz.asm):00263          ;
                      (          woz.asm):00264          ; U is pointer to line buffer and work variables
                      (          woz.asm):00265          ; X is work pointer
                      (          woz.asm):00266          ; W is the WORD parsed from input line (A2 in new monitor)
                      (          woz.asm):00267          ; B is the index into the line buffer
                      (          woz.asm):00268          ; A is work register
                      (          woz.asm):00269          ; W_TEMP is copy of line buffer index upon entry, but after this is
                      (          woz.asm):00270          ;        complete, it is the flow-control byte for XAM/BLOCK XAM output
                      (          woz.asm):00271         
10AE                  (          woz.asm):00272         W_NOTHEX:
10AE D1FD             (          woz.asm):00273                 CMPB    <W_dTEMP        ; Check if W empty (no hex digits parsed).
10B0 1027FF7A         (          woz.asm):00274                 LBEQ    W_CANCEL        ;  yes, bad input so handle as CANCEL
10B4 0FFD             (          woz.asm):00275                 CLR     <W_dTEMP        ; clear the 'flow control' byte
10B6 0DFC             (          woz.asm):00276                 TST     <W_dMODE        ; Test MODE byte.
10B8 2A09             (          woz.asm):00277                 BPL     W_NOTSTOR       ; B7=1 for STOR, 0 for XAM and BLOCK XAM
                      (          woz.asm):00278                 ; STOR mode
10BA 9EFA             (          woz.asm):00279                 LDX     <W_dST          ; use X to hold 'store index'
10BC 11E780           (          woz.asm):00280                 STF     ,X+             ; store LSB of WORD at 'store index'
10BF 9FFA             (          woz.asm):00281                 STX     <W_dST          ; save the incremented 'store index'
10C1 208F             (          woz.asm):00282                 BRA     W_NEXTITEM      ; Get next command item.
10C3                  (          woz.asm):00283         W_NOTSTOR:
10C3 264D             (          woz.asm):00284                 BNE     W_XAMNEXT       ; mode = $00 for XAM, $56 for BLOCK XAM.
                      (          woz.asm):00285                 ; non BLOCK XAM
10C5 1097FA           (          woz.asm):00286                 STW     <W_dST          ; copy word parsed into 'store index'
10C8 1097F8           (          woz.asm):00287                 STW     <W_dXAM         ; copy word parsed into 'XAM index'
10CB 4F               (          woz.asm):00288                 CLRA                    ; set Z=1 to cause address display to occur
                      (          woz.asm):00289                 ; fall into NXTPRNT loop...
10CC                  (          woz.asm):00290         W_NXTPRNT:
10CC 263B             (          woz.asm):00291                 BNE     W_PRDATA        ; Z=0 means skip displaying address
10CE 96FD             (          woz.asm):00292                 LDA     <W_dTEMP        ; check flow control byte
10D0 270E             (          woz.asm):00293                 BEQ     W?NXT1          ;  if zero, skip waiting for character
10D2 BD12A1           (          woz.asm):00294                 JSR     GETCHT          ; yes, flow control in effect, wait for character
10D5 8118             (          woz.asm):00295                 CMPA    #CTL_X          ; did we get a ^X?
10D7 1027FF58         (          woz.asm):00296                 LBEQ    W_GETLINE       ;  yes, exit and get new input line
10DB 8120             (          woz.asm):00297                 CMPA    #SPACE          ; did we get a SPACE
10DD 2701             (          woz.asm):00298                 BEQ     W?NXT1          ;  yes, set flow control to $20
10DF 4F               (          woz.asm):00299                 CLRA                    ; any other character, clear flow control
10E0 97FD             (          woz.asm):00300         W?NXT1  STA     <W_dTEMP        ; update flow control byte
10E2 BD12B4           (          woz.asm):00301                 JSR     GETCH1          ; attempt to read a character (A=0 if none)
10E5 8120             (          woz.asm):00302                 CMPA    #SPACE          ; is it a SPACE?
10E7 270C             (          woz.asm):00303                 BEQ     W?NXT2          ;   yes, set flow control to $20
10E9 8113             (          woz.asm):00304                 CMPA    #CTL_S          ; is it a ^S?
10EB 2708             (          woz.asm):00305                 BEQ     W?NXT2          ;  yes, set flow control as $13
10ED 8118             (          woz.asm):00306                 CMPA    #CTL_X          ; is it a ^X?
10EF 1027FF40         (          woz.asm):00307                 LBEQ    W_GETLINE       ;  yes, exit and get new input line
10F3 96FD             (          woz.asm):00308                 LDA     <W_dTEMP        ; flow unaffected by other characters
10F5 97FD             (          woz.asm):00309         W?NXT2  STA     <W_dTEMP        ; update flow control byte
10F7 BD12EB           (          woz.asm):00310         W?NXT3  JSR     PUTCR           ; CR for a new line
10FA 96F8             (          woz.asm):00311                 LDA     <W_dXAM         ; 'XAM index' high-order byte.
10FC BD1308           (          woz.asm):00312                 JSR     PUTBYTE
10FF 96F9             (          woz.asm):00313                 LDA     <W_dXAM+1       ; Low-order 'Examine index' byte.
1101 BD1308           (          woz.asm):00314                 JSR     PUTBYTE
1104 863A             (          woz.asm):00315                 LDA     #':'            ; ":".
1106 BD12D9           (          woz.asm):00316                 JSR     PUTCH           ; Output it.
1109                  (          woz.asm):00317         W_PRDATA:
1109 BD12F7           (          woz.asm):00318                 JSR     PUTSPACE        ; output a space
110C A6D878           (          woz.asm):00319                 LDA     [W_XAM,U]       ; Get data byte at 'examine index'.
110F BD1308           (          woz.asm):00320                 JSR     PUTBYTE         ; display it
1112                  (          woz.asm):00321         W_XAMNEXT:
1112 9EF8             (          woz.asm):00322                 LDX     <W_dXAM         ; use X to hold XAM index
1114 103761           (          woz.asm):00323                 CMPR    W,X             ; compare XAM index to parsed address WORD
1117 1027FF37         (          woz.asm):00324                 LBEQ    W_NEXTITEM      ;  same, done examining memory
111B 3001             (          woz.asm):00325                 LEAX    1,X             ; increment XAM index
111D 9FF8             (          woz.asm):00326                 STX     <W_dXAM         ;  and save it
111F 96F9             (          woz.asm):00327                 LDA     <(W_dXAM+1)     ; Check low-order 'examine index' byte
1121 8407             (          woz.asm):00328                 ANDA    #$07            ; set Z when 'examine index' MOD 8 = 0
1123 20A7             (          woz.asm):00329                 BRA     W_NXTPRNT       ; always taken
                      (          woz.asm):00330         
                      (          woz.asm):00331          ;;======================================================================
                      (          woz.asm):00332          ;; S-RECORD AND INTEL HEX CONSOLE DOWNLOAD FUNCTION
                      (          woz.asm):00333          ;;======================================================================
                      (          woz.asm):00334         
                      (          woz.asm):00335          ;;
                      (          woz.asm):00336          ;; DL_START - try to download a HEX file (either S9 or IHEX) from console
                      (          woz.asm):00337          ;; inputs: none
                      (          woz.asm):00338          ;; return: V=0 : successful load (A=0)
                      (          woz.asm):00339          ;;         V=1 : error during load (A=$FF)
                      (          woz.asm):00340          ;;
1125                  (          woz.asm):00341         DL_START0:
1125 BD1226           (          woz.asm):00342                 JSR     PUTMSG
1128 0D0A             (          woz.asm):00343                 FCB     CR,LF
112A 48657820446F776E (          woz.asm):00344                 FCN     "Hex Download"
     6C6F616400
1137 BD12EB           (          woz.asm):00345                 JSR     PUTCR           ; NEW LINE
113A                  (          woz.asm):00346         DL_START:
113A 8D20             (          woz.asm):00347                 BSR     DL_REC          ; DOWNLOAD RECORD (A=00 ready for more)
113C 2606             (          woz.asm):00348                 BNE     D?LO2           ;  if Z=0 then stop reading records
113E BD1219           (          woz.asm):00349                 JSR     PUTCONST        ; OUTPUT ONE DOT PER RECORD
1141 2E               (          woz.asm):00350                 FCC     '.'
1142 20F6             (          woz.asm):00351                 BRA     DL_START        ; CONTINUE
1144 2A0C             (          woz.asm):00352         D?LO2   BPL     D?LO3           ;  if N=0, no error occurred (A=01 means EOF)
1146 BD1226           (          woz.asm):00353                 JSR     PUTMSG          ; error occurred
1149 0D0A             (          woz.asm):00354                 FCB     CR,LF
114B 455252           (          woz.asm):00355                 FCC     "ERR"
114E FF               (          woz.asm):00356                 FCB     $FF
114F 1A02             (          woz.asm):00357                 ORCC    #CC_V           ; set V (error)
1151 39               (          woz.asm):00358                 RTS
1152 BD1226           (          woz.asm):00359         D?LO3   JSR     PUTMSG          ; load successful
1155 0D0A             (          woz.asm):00360                 FCB     CR,LF
1157 4F4B             (          woz.asm):00361                 FCC     "OK"
1159 FF               (          woz.asm):00362                 FCB     $FF
115A 4F               (          woz.asm):00363                 CLRA                    ; clear V (success)
115B 39               (          woz.asm):00364                 RTS
                      (          woz.asm):00365         
                      (          woz.asm):00366          ; Download a record in either MOTOROLA or INTEL hex format
115C BD129C           (          woz.asm):00367         DL_REC  JSR     GETCH           ; Get a character
115F 8103             (          woz.asm):00368                 CMPA    #$03            ; Check for ^C (Break)
1161 274E             (          woz.asm):00369                 BEQ     DL_ERR          ; yes, abort with error
1163 813A             (          woz.asm):00370                 CMPA    #':'            ; Start of INTEL record?
1165 10270071         (          woz.asm):00371                 LBEQ    DL_INT          ; Yes, download INTEL
1169 8153             (          woz.asm):00372                 CMPA    #'S'            ; Start of MOTOROLA record?
116B 26EF             (          woz.asm):00373                 BNE     DL_REC          ; No, keep looking
                      (          woz.asm):00374         
                      (          woz.asm):00375          ; Download a record in MOTOROLA hex format
116D BD129C           (          woz.asm):00376         DL_MOT  JSR     GETCH           ; get record type
1170 8130             (          woz.asm):00377                 CMPA    #'0'            ; S0 header record?
1172 27E8             (          woz.asm):00378                 BEQ     DL_REC          ;    skip it
1174 8135             (          woz.asm):00379                 CMPA    #'5'            ; S5 count record?
1176 27E4             (          woz.asm):00380                 BEQ     DL_REC          ;    skip it
1178 8139             (          woz.asm):00381                 CMPA    #'9'            ; S9 end of file?
117A 2738             (          woz.asm):00382                 BEQ     DL_MOT9         ;    end of file
117C 8131             (          woz.asm):00383                 CMPA    #'1'            ; should be a data record (S1) then!
117E 2631             (          woz.asm):00384                 BNE     DL_ERR          ;  none of these = load error
1180 BD1243           (          woz.asm):00385                 JSR     GETBYTE         ; get length
1183 292C             (          woz.asm):00386                 BVS     DL_ERR          ; report error
1185 1F8E             (          woz.asm):00387                 TFR     A,E             ; start checksum in E
1187 8003             (          woz.asm):00388                 SUBA    #3              ; adjust length (omit address and checksum)
1189 1F8F             (          woz.asm):00389                 TFR     A,F             ; set length in F
                      (          woz.asm):00390                 ; Get address
118B BD1243           (          woz.asm):00391                 JSR     GETBYTE         ; get first byte of address
118E 2921             (          woz.asm):00392                 BVS     DL_ERR          ; report error
1190 1F89             (          woz.asm):00393                 TFR     A,B             ; save for later
1192 10308E           (          woz.asm):00394                 ADDR    A,E             ; include in checksum
1195 BD1243           (          woz.asm):00395                 JSR     GETBYTE         ; get next byte of address
1198 2917             (          woz.asm):00396                 BVS     DL_ERR          ; report error
119A 1E89             (          woz.asm):00397                 EXG     A,B             ; swap address halves (endian stuff)
119C 1F01             (          woz.asm):00398                 TFR     D,X             ; set pointer
119E 10309E           (          woz.asm):00399                 ADDR    B,E             ; include in checksum
                      (          woz.asm):00400                 ; Get data bytes
11A1 8D24             (          woz.asm):00401                 BSR     DL_BYTES
11A3 290C             (          woz.asm):00402                 BVS     DL_ERR
                      (          woz.asm):00403                 ; get checksum byte
11A5 BD1243           (          woz.asm):00404                 JSR     GETBYTE
11A8 2907             (          woz.asm):00405                 BVS     DL_ERR          ; report error
11AA 10308E           (          woz.asm):00406                 ADDR    A,E             ; add to computed checksum
11AD 114C             (          woz.asm):00407                 INCE                    ; test for success
11AF 2714             (          woz.asm):00408                 BEQ     DL_RTS          ; download ok
                      (          woz.asm):00409         
                      (          woz.asm):00410          ; Error occurred on loading
11B1 86FF             (          woz.asm):00411         DL_ERR  LDA     #$FF            ; A=$FF if an error occurred (N is set, Z is clear)
11B3 39               (          woz.asm):00412                 RTS
                      (          woz.asm):00413         
                      (          woz.asm):00414          ; properly handle S9 end record (just eat it)
11B4 BD1243           (          woz.asm):00415         DL_MOT9 JSR     GETBYTE         ; get length byte
11B7 29F8             (          woz.asm):00416                 BVS     DL_ERR          ; report error
11B9 1F8F             (          woz.asm):00417                 TFR     A,F             ; save length
11BB BD1243           (          woz.asm):00418         DL_MOT10 JSR    GETBYTE         ; get next byte (ignore it)
11BE 115A             (          woz.asm):00419                 DECF                    ; reduce length
11C0 26F9             (          woz.asm):00420                 BNE     DL_MOT10        ; get all the bytes
                      (          woz.asm):00421                 ; fall into DLEOF...
                      (          woz.asm):00422         
                      (          woz.asm):00423          ; Record download successful, EOF marker encountered
11C2 8601             (          woz.asm):00424         DL_EOF  LDA     #$01            ; A=$01 if EOF is reached (N and Z both clear)
11C4 39               (          woz.asm):00425                 RTS
                      (          woz.asm):00426         
                      (          woz.asm):00427          ; Record download successful, expecting another record
11C5 4F               (          woz.asm):00428         DL_RTS  CLRA                    ; A=$00 if another record is needed (Z set, N clear)
11C6 39               (          woz.asm):00429                 RTS
                      (          woz.asm):00430         
                      (          woz.asm):00431          ; Download F number of bytes from console, storing in memory at X, and
                      (          woz.asm):00432          ; maintaining running checksum in E. Exit with V=1 on error.
11C7 115D             (          woz.asm):00433         DL_BYTES TSTF                   ; examine # of bytes to get
11C9 270E             (          woz.asm):00434                 BEQ     D?LBX           ;   zero, nothing to do!
11CB BD1243           (          woz.asm):00435                 JSR     GETBYTE         ; get data byte
11CE 2909             (          woz.asm):00436                 BVS     D?LBX           ; exit with V=1 on error
11D0 A780             (          woz.asm):00437                 STA     ,X+             ; Write to memory
11D2 10308E           (          woz.asm):00438                 ADDR    A,E             ; include in checksum
11D5 115A             (          woz.asm):00439                 DECF                    ; reduce length
11D7 26EE             (          woz.asm):00440                 BNE     DL_BYTES        ; Do them all
11D9 39               (          woz.asm):00441         D?LBX   RTS
                      (          woz.asm):00442         
                      (          woz.asm):00443          ; Download record in INTEL format
11DA BD1243           (          woz.asm):00444         DL_INT  JSR     GETBYTE         ; get count
11DD 29D2             (          woz.asm):00445                 BVS     DL_ERR          ; report error
11DF 1F8E             (          woz.asm):00446                 TFR     A,E             ; start checksum in E
11E1 1F8F             (          woz.asm):00447                 TFR     A,F             ; set length in F
                      (          woz.asm):00448                 ; Get address
11E3 BD1243           (          woz.asm):00449                 JSR     GETBYTE         ; get first byte of address
11E6 29C9             (          woz.asm):00450                 BVS     DL_ERR          ; report error
11E8 1F89             (          woz.asm):00451                 TFR     A,B             ; Save for later
11EA 10308E           (          woz.asm):00452                 ADDR    A,E             ; include in checksum
11ED BD1243           (          woz.asm):00453                 JSR     GETBYTE         ; get next byte of address
11F0 29BF             (          woz.asm):00454                 BVS     DL_ERR          ; report error
11F2 1E89             (          woz.asm):00455                 EXG     A,B             ; Swap
11F4 1F01             (          woz.asm):00456                 TFR     D,X             ; Set pointer
11F6 10309E           (          woz.asm):00457                 ADDR    B,E             ; include in checksum
                      (          woz.asm):00458                 ; Get record type
11F9 115C             (          woz.asm):00459                 INCF                    ; temporarily increment length (EOF 0->1)
11FB BD1243           (          woz.asm):00460                 JSR     GETBYTE         ; get type value
11FE 29B1             (          woz.asm):00461                 BVS     DL_ERR          ; report error
1200 8101             (          woz.asm):00462                 CMPA    #1              ; EOF record?
1202 27B7             (          woz.asm):00463                 BEQ     DL_MOT10        ;   yes, eat 1 byte and return with EOF status
1204 10308E           (          woz.asm):00464                 ADDR    A,E             ; include type in checksum
1207 115A             (          woz.asm):00465                 DECF                    ; back to correct length
                      (          woz.asm):00466                 ; Get data bytes
1209 8DBC             (          woz.asm):00467                 BSR     DL_BYTES        ; get F# of data bytes (return with zero length)
120B 29A4             (          woz.asm):00468                 BVS     DL_ERR          ; report error
                      (          woz.asm):00469                 ; Get checksum
120D BD1243           (          woz.asm):00470                 JSR     GETBYTE         ; Read checksum byte
1210 299F             (          woz.asm):00471                 BVS     DL_ERR          ; Report error
1212 10308E           (          woz.asm):00472                 ADDR    A,E             ; add to computed checksum
1215 27AE             (          woz.asm):00473                 BEQ     DL_RTS          ; Report success
1217 2098             (          woz.asm):00474                 BRA     DL_ERR          ; Report failure
                      (          woz.asm):00475         
                      (          woz.asm):00476          ;;
                      (          woz.asm):00477          ;; PUTCONST - ouptut character at PC to UART A.
                      (          woz.asm):00478          ;; inputs:  PC = address of character to output
                      (          woz.asm):00479          ;; return:  all registers preserved
                      (          woz.asm):00480          ;;
1219                  (          woz.asm):00481         PUTCONST
1219 3412             (          woz.asm):00482                 PSHS    A,X             ; preserve A,X
121B AE63             (          woz.asm):00483                 LDX     3,S             ; get old PC
121D A680             (          woz.asm):00484                 LDA     ,X+             ; get character, increment past it (new PC)
121F BD12D9           (          woz.asm):00485                 JSR     PUTCH           ; output character
1222 AF63             (          woz.asm):00486                 STX     3,S             ; store new PC
1224 3592             (          woz.asm):00487                 PULS    A,X,PC
                      (          woz.asm):00488         
                      (          woz.asm):00489          ;;
                      (          woz.asm):00490          ;; PUTMSG - output NULL/FF terminated string at PC to SCC Channel A
                      (          woz.asm):00491          ;; terminate with either 0, or $FF (CRLF before terminates)
                      (          woz.asm):00492          ;; inputs: PC = address of string to output
                      (          woz.asm):00493          ;; return: all registers intact
                      (          woz.asm):00494          ;;
1226                  (          woz.asm):00495         PUTMSG:
1226 3410             (          woz.asm):00496                 PSHS    X               ; save old x
1228 AE62             (          woz.asm):00497                 LDX     2,S             ; get old pc
122A 8D04             (          woz.asm):00498                 BSR     PUTSTR          ; output string
122C AF62             (          woz.asm):00499                 STX     2,S             ; update old pc
122E 3590             (          woz.asm):00500                 PULS    X,PC            ; restore X and return
                      (          woz.asm):00501         
                      (          woz.asm):00502          ;;
                      (          woz.asm):00503          ;; PUTSTR - output NULL/FF terminated string at X to SCC Channel A
                      (          woz.asm):00504          ;; terminate with either 0, or $FF (CRLF before terminates)
                      (          woz.asm):00505          ;; inputs: X = address of string to output
                      (          woz.asm):00506          ;; return: X = terminator byte of string+1
                      (          woz.asm):00507          ;;
1230                  (          woz.asm):00508         PUTSTR:
1230 3402             (          woz.asm):00509                 PSHS    A               ; preserve A
1232 A680             (          woz.asm):00510         P?S1    LDA     ,X+             ; get char from message
1234 270B             (          woz.asm):00511                 BEQ     PSTRX?          ;  0 = end
1236 81FF             (          woz.asm):00512                 CMPA    #$FF            ; FF = newline end?
1238 102700B1         (          woz.asm):00513                 LBEQ    PUTCR1          ;  yes, new line, exit via PUTCR
123C BD12D9           (          woz.asm):00514                 JSR     PUTCH           ; output character to term
123F 20F1             (          woz.asm):00515                 BRA     P?S1            ; keep going
1241 3582             (          woz.asm):00516         PSTRX?  PULS    A,PC            ; restore A and return
                      (          woz.asm):00517         
                      (          woz.asm):00518          ;;
                      (          woz.asm):00519          ;; GETBYTE - acquire an ASCII HEX byte from SCC Channel A and return in A
                      (          woz.asm):00520          ;; inputs: none
                      (          woz.asm):00521          ;; return: V=0 means input was valid, byte value in A
                      (          woz.asm):00522          ;;         V=1 means input was non-ASII HEX, A is destroyed
                      (          woz.asm):00523          ;;
1243                  (          woz.asm):00524         GETBYTE:
1243 8D11             (          woz.asm):00525                 BSR     GETNIB          ; Get FIRST nibble
1245 290E             (          woz.asm):00526                 BVS     GETB1?          ; Invalid, abort (V=1)
1247 48               (          woz.asm):00527                 LSLA                    ; Rotate
1248 48               (          woz.asm):00528                 LSLA                    ; into
1249 48               (          woz.asm):00529                 LSLA                    ; high
124A 48               (          woz.asm):00530                 LSLA                    ; nibble
124B 3402             (          woz.asm):00531                 PSHS    A               ; Save for later
124D 8D07             (          woz.asm):00532                 BSR     GETNIB          ; Get SECOND nibble
124F 2902             (          woz.asm):00533                 BVS     GETB2?          ;  bad, release storage and return with V=1
1251 AAE4             (          woz.asm):00534                 ORA     ,S              ; Include high (and clear V)
1253 3261             (          woz.asm):00535         GETB2?  LEAS    1,S             ; release stack storage (V unaffected)
1255 39               (          woz.asm):00536         GETB1?  RTS
                      (          woz.asm):00537         
                      (          woz.asm):00538          ;;
                      (          woz.asm):00539          ;; GETNIB - acquire an ASCII HEX nibble from SCC Channel A and return in A
                      (          woz.asm):00540          ;; inputs: none
                      (          woz.asm):00541          ;; return: V=0 means input was valid, nibble value in A
                      (          woz.asm):00542          ;;         V=1 means input was non-ASII HEX, A is preserved
                      (          woz.asm):00543          ;;
1256                  (          woz.asm):00544         GETNIB:
1256 BD12A1           (          woz.asm):00545                 JSR     GETCHT          ; get a character
1259 8030             (          woz.asm):00546                 SUBA    #'0'            ; Convert numbers
125B 8109             (          woz.asm):00547                 CMPA    #9              ; Numeric?
125D 230A             (          woz.asm):00548                 BLS     G?N1            ; Yes, OK
125F 8007             (          woz.asm):00549                 SUBA    #7              ; Convert alphas
1261 810A             (          woz.asm):00550                 CMPA    #10             ; Under?
1263 2507             (          woz.asm):00551                 BLO     G?N2            ; Yes, error
1265 810F             (          woz.asm):00552                 CMPA    #15             ; Over?
1267 2203             (          woz.asm):00553                 BHI     G?N2            ; Yes, error
1269 840F             (          woz.asm):00554         G?N1    ANDA    #$0F            ; V=0 indicates good input
126B 39               (          woz.asm):00555                 RTS
126C 8B37             (          woz.asm):00556         G?N2    ADDA    #$37            ; Normalize character
126E 1A02             (          woz.asm):00557                 ORCC    #CC_V           ; V=1 indicates non-hex input
1270 39               (          woz.asm):00558                 RTS
                      (          woz.asm):00559         
                      (          woz.asm):00560          ;;
                      (          woz.asm):00561          ;; SCC_InitA - Initialize SCC channel A to default
                      (          woz.asm):00562          ;; return: all registers preserved
                      (          woz.asm):00563          ;;
1271                  (          woz.asm):00564         SCC_InitA:
1271 3432             (          woz.asm):00565                 PSHS    A,X,Y           ; preserve A,X,Y
1273 108EE012         (          woz.asm):00566                 LDY     #ZSCCAC         ; Y points to channel A command reg
1277 8E128C           (          woz.asm):00567                 LDX     #SCCATBL        ; X points to channel A config table
127A A6A4             (          woz.asm):00568                 LDA     ,Y              ; reset register pointer to WR0/RR0
127C A680             (          woz.asm):00569         IS1?    LDA     ,X+             ; load address from table
127E 81FF             (          woz.asm):00570                 CMPA    #$FF            ; is it $FF? (end of table)
1280 2708             (          woz.asm):00571                 BEQ     IS2?            ;    yes, done with init of channel
1282 A7A4             (          woz.asm):00572                 STA     ,Y              ;    no, write the register pointer to WR0
1284 A680             (          woz.asm):00573                 LDA     ,X+             ; get data byte from table
1286 A7A4             (          woz.asm):00574                 STA     ,Y              ; write data to SCC command register
1288 20F2             (          woz.asm):00575                 BRA     IS1?            ; repeat until EOT reached..
128A 35B2             (          woz.asm):00576         IS2?    PULS    A,X,Y,PC        ; restore registers and return
                      (          woz.asm):00577         
                      (          woz.asm):00578          ; Initialization table for SCC Channel A in ASYNC mode, external 16x clock
                      (          woz.asm):00579          ; ACLK from CPLD is 1.843 MHz. 1.843 / 16 = 115.2kbps (USB VCP interface)
128C                  (          woz.asm):00580         SCCATBL:
128C 0980             (          woz.asm):00581                 FCB     $09,$80         ; Point to WR9; Reset Ch A
128E 0900             (          woz.asm):00582                 FCB     $09,$00         ; Point to WR9; un-reset CH A
1290 0444             (          woz.asm):00583                 FCB     $04,$44         ; Point to WR4; X16 clock,1 Stop,NP
1292 03C1             (          woz.asm):00584                 FCB     $03,$C1         ; Point to WR3; Enable receiver, No Auto Enable (Hardware CTS), Receive 8 bits
1294 05EA             (          woz.asm):00585                 FCB     $05,$EA         ; Point to WR5; Enable, Transmit 8 bits RTS,DTR, Enable
1296 0B05             (          woz.asm):00586                 FCB     $0B,$05         ; Point to WR11; RX clock = TX clock = RTXC pin; TRXC pin = xmit clock
1298 0F00             (          woz.asm):00587                 FCB     $0F,$00         ; Point to WR15; no INT from hardware CTS/RTS
129A FFFF             (          woz.asm):00588                 FCB     $FF,$FF         ; EOT marker
                      (          woz.asm):00589         
                      (          woz.asm):00590          ;;
                      (          woz.asm):00591          ;; GETCH - wait forever for a character from SCC Channel A
                      (          woz.asm):00592          ;; GETCHT - as GETCH, but also toggle LED1 each timeout
                      (          woz.asm):00593          ;; GETCH1 - one attempt to get a character from SCC Channel A
                      (          woz.asm):00594          ;; GETCH2 - attempt for ~500ms to get a character from SCC Channel A
                      (          woz.asm):00595          ;; inputs:  none
                      (          woz.asm):00596          ;; return:  A=character received
                      (          woz.asm):00597          ;;          V=0 if data received
                      (          woz.asm):00598          ;;          V=1 if timeout (0.5 seconds)
                      (          woz.asm):00599          ;;
                      (          woz.asm):00600          ; GETCH entry point - infinite retry duration
129C                  (          woz.asm):00601         GETCH:
129C 8D1E             (          woz.asm):00602                 BSR     GETCH2          ; process as GETCH2
129E 29FC             (          woz.asm):00603                 BVS     GETCH           ;  if no character, keep trying
12A0 39               (          woz.asm):00604                 RTS                     ;  otherwise, return with char in A
                      (          woz.asm):00605                 ; GETCHT entry point - infinite retry duration with LED1 toggle each timeout
12A1                  (          woz.asm):00606         GETCHT:
                      (          woz.asm):00607                 OnLED1                  ; turn on LED1 while attempting input
12A1 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
12A5 8D15             (          woz.asm):00608         G?T     BSR     GETCH2          ; go try to get a character
12A7 2806             (          woz.asm):00609                 BVC     G?X             ;   got one, return
                      (          woz.asm):00610                 ToggleLED1              ; toggle LED1 each timeout
12A9 7501E050         (       ToggleLED1):00001                  EIM      #IO.LED1,IOPORT                   ; toggle LED1
12AD 20F6             (          woz.asm):00611                 BRA     G?T             ; and try again
12AF                  (          woz.asm):00612         G?X     OnLED1                  ; got a character, turn LED1 back on
12AF 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
12B3 39               (          woz.asm):00613                 RTS
                      (          woz.asm):00614                 ; GETCH1 entry point - one attempt
12B4                  (          woz.asm):00615         GETCH1:
12B4 3420             (          woz.asm):00616                 PSHS    Y               ; preserve Y
12B6 108E0002         (          woz.asm):00617                 LDY     #2              ; only check once for a character in channel A
12BA 2006             (          woz.asm):00618                 BRA     GC10?           ; process as GETCH2
                      (          woz.asm):00619                 ; GETCH2 entry point - standard timeout
12BC                  (          woz.asm):00620         GETCH2:
12BC 3420             (          woz.asm):00621                 PSHS    Y               ; preserve Y
12BE 108E0000         (          woz.asm):00622                 LDY     #0              ; clear Y for longest timeout (~450ms)
12C2 1A02             (          woz.asm):00623         GC10?   ORCC    #CC_V           ; set V flag ahead of decrement
12C4 313F             (          woz.asm):00624                 LEAY    -1,Y            ; decrement timeout counter (V unaffected)
12C6 270F             (          woz.asm):00625                 BEQ     GC90?           ;  EXIT IF TIMEOUT (with V=1)
12C8 B6E012           (          woz.asm):00626                 LDA     ZSCCAC          ; reset register pointer to WR0/RR0
12CB B6E012           (          woz.asm):00627                 LDA     ZSCCAC          ; read RR0
12CE 8401             (          woz.asm):00628                 ANDA    #ZSCC.RXBF      ; examine the RX char available bit
12D0 27F0             (          woz.asm):00629                 BEQ     GC10?           ;  LOOP UNTIL CHARACTER AVAILABLE
12D2 B6E013           (          woz.asm):00630                 LDA     ZSCCAD          ; read character
12D5 8A00             (          woz.asm):00631                 ORA     #0              ; clear V flag
12D7 35A0             (          woz.asm):00632         GC90?   PULS    Y,PC            ; restore Y and return
                      (          woz.asm):00633         
                      (          woz.asm):00634          ;;
                      (          woz.asm):00635          ;; PUTCH - output character in A to SCC Channel A
                      (          woz.asm):00636          ;; inputs: character in A
                      (          woz.asm):00637          ;; return: all registers preserved
                      (          woz.asm):00638          ;;
12D9 3402             (          woz.asm):00639         PUTCH:  PSHS    A               ; save character pior to writing
12DB B6E012           (          woz.asm):00640         PC10?   LDA     ZSCCAC          ; reset SCC register pointer to WR0/RR0
12DE B6E012           (          woz.asm):00641                 LDA     ZSCCAC          ; read RR0
12E1 8404             (          woz.asm):00642                 ANDA    #ZSCC.TXBE      ;  examine the TX buffer empty bit
12E3 27F6             (          woz.asm):00643                 BEQ     PC10?           ;  LOOP UNTIL EMPTY
12E5 3502             (          woz.asm):00644                 PULS    A
12E7 B7E013           (          woz.asm):00645                 STA     ZSCCAD          ; write character to SCC A data reg
12EA 39               (          woz.asm):00646                 RTS
                      (          woz.asm):00647         
                      (          woz.asm):00648          ;;
                      (          woz.asm):00649          ;; PUTCR - output CRLF to SCC Channel A
                      (          woz.asm):00650          ;; return: all registers preserved
                      (          woz.asm):00651          ;;
12EB                  (          woz.asm):00652         PUTCR:
12EB 3402             (          woz.asm):00653                 PSHS    A               ; save A value
12ED 860D             (          woz.asm):00654         PUTCR1  LDA     #CR             ; output a carriage return
12EF 8DE8             (          woz.asm):00655                 BSR     PUTCH           ;
12F1 860A             (          woz.asm):00656                 LDA     #LF             ; output a line feed
12F3 8DE4             (          woz.asm):00657                 BSR     PUTCH           ;
12F5 3582             (          woz.asm):00658                 PULS    A,PC            ; restore A and PC and return
                      (          woz.asm):00659         
                      (          woz.asm):00660          ;;
                      (          woz.asm):00661          ;; PUTSPACE - output a SPACE to SCC Channel A
                      (          woz.asm):00662          ;; return: all registers preserved
                      (          woz.asm):00663          ;;
12F7                  (          woz.asm):00664         PUTSPACE:
12F7 3402             (          woz.asm):00665                 PSHS    A
12F9 8620             (          woz.asm):00666                 LDA     #SPACE
12FB 8DDC             (          woz.asm):00667                 BSR     PUTCH
12FD 3582             (          woz.asm):00668                 PULS    A,PC
                      (          woz.asm):00669         
                      (          woz.asm):00670          ;;
                      (          woz.asm):00671          ;; PUTWORD - output ASCII HEX WORD to SCC Channel A
                      (          woz.asm):00672          ;; inputs: D = value to output
                      (          woz.asm):00673          ;; return: all registers preserved
                      (          woz.asm):00674          ;;
12FF                  (          woz.asm):00675         PUTWORD:
12FF 8D07             (          woz.asm):00676                 BSR     PUTBYTE         ; A is MSB, output it first
1301 1E98             (          woz.asm):00677                 EXG     B,A             ; swap bytes
1303 8D03             (          woz.asm):00678                 BSR     PUTBYTE         ; now output LSB
1305 1E98             (          woz.asm):00679                 EXG     B,A             ; restore A and B
1307 39               (          woz.asm):00680                 RTS
                      (          woz.asm):00681         
                      (          woz.asm):00682          ;;
                      (          woz.asm):00683          ;; PUTBYTE - output ASCII HEX BYTE to SCC Channel A
                      (          woz.asm):00684          ;; inputs: A = value to output
                      (          woz.asm):00685          ;; return: all registers preserved
                      (          woz.asm):00686          ;;
1308                  (          woz.asm):00687         PUTBYTE:
1308 3402             (          woz.asm):00688                 PSHS    A               ; Save low nibble
130A 44               (          woz.asm):00689                 LSRA                    ; Rotate
130B 44               (          woz.asm):00690                 LSRA                    ; upper nibble
130C 44               (          woz.asm):00691                 LSRA                    ; into
130D 44               (          woz.asm):00692                 LSRA                    ; lower nibble
130E 8D02             (          woz.asm):00693                 BSR     PUTHEX          ; Output high nibble
1310 3502             (          woz.asm):00694                 PULS    A               ; Restore low nibble
                      (          woz.asm):00695                 ; fall into PUTHEX...
                      (          woz.asm):00696         
                      (          woz.asm):00697          ;;
                      (          woz.asm):00698          ;; PUTHEX - output ASCII HEX NIBBLE to SCC Channel A
                      (          woz.asm):00699          ;; inputs: A = value to output
                      (          woz.asm):00700          ;; return: all registers preserved
                      (          woz.asm):00701          ;;
1312                  (          woz.asm):00702         PUTHEX:
1312 3402             (          woz.asm):00703                 PSHS    A               ; preserve A
1314 840F             (          woz.asm):00704                 ANDA    #$0F            ; Remove upper half
1316 8B30             (          woz.asm):00705                 ADDA    #'0'            ; Convert to printable
1318 8139             (          woz.asm):00706                 CMPA    #'9'            ; In range?
131A 2302             (          woz.asm):00707                 BLS     P?H0            ;   yes, skip alpha adjust
131C 8B07             (          woz.asm):00708                 ADDA    #7              ; Convert to alpha
131E 8DB9             (          woz.asm):00709         P?H0    BSR     PUTCH           ; output via PUTCH
1320 3582             (          woz.asm):00710                 PULS    A,PC            ; restore A and return
                      (          woz.asm):00711         
                      (          woz.asm):00712         
