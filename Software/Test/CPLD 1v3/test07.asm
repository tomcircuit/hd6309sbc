* TEST07.ASM
* S-record load test the HD6309 SBC
* T. LeMense 2/8/2014

* HARDWARE INFORMATION
RAM	EQU	$0800		TEST01 data goes here
ZCIO	EQU	$0200		CIO base address
CIOC	EQU	ZCIO                      CIO port C access
CIOB	EQU	ZCIO+1		CIO port B access
CIOA	EQU	ZCIO+2		CIO port A access
CIOCTL	EQU	ZCIO+3                    CIO control register
ZSCC	EQU	$0210		SCC base address
SCCBC      EQU	ZSCC		SCC channel B command
SCCBD	EQU	ZSCC+1		SCC channel B data
SCCAC	EQU	ZSCC+2      		SCC channel A command
SCCAD	EQU	ZSCC+3		SCC channel A data
INOUTP	EQU	$0250		INOUT register address

* Start of program
	ORG	RAM
	
RESET	LDA	#$00
	STA	store
	LDS	#STACK
	BSR	CIOINIT
	LBSR	CTMINIT
	
ZERO	LDA	INOUTP
	ANDA	#$80
	BMI	ZERO
ONE	INC	store                       ; increment the LED's (count up)
	LDA	store
	STA	INOUTP
	LBSR	CTMREAD
TWO	LDA	INOUTP
	ANDA	#$80
	BPL	TWO
	BRA	ZERO
store	rmb	16	
stack	EQU	*

***************
* CIOINIT
* Initialize CIO
***************
*
* ROUTINE TO INITIALIZE Z8536 AND SET TO A KNOWN STATE WHERE THE PART
* CAN THEN BE PROGRAMMED TO PERFORM THE VARIOUS FUNCTIONS. THE PROGRAMMING OF
* THE Z8536 IS AT TIMES COMPLICATED.  

CIOINIT
* RESET THE CHIP TO A KNOWN STATE AND THEN CLEAR THE RESET

* A READ WILL FORCE THE Z8536 INTO STATE 0 IF IN STATE 1, OTHERWISE IT WILL
* NOT CAUSE ANY CHANGES
	LDA	CIOCTL	

* IF THE Z8536 WAS RESET, WRITING A 0 WILL FORCE IT INTO STATE 0. IF IN
* STATE 0, THIS WILL SET THE POINTER TO REGISTER 0 AND GO TO STATE 1.
	CLRA
	STA	CIOCTL	

* ANOTHER READ OPERATION WILL FORCE THE 8536 INTO STATE 0, FROM WHERE FURTHER
* INSTRUCTIONS CAN BE DONE
	NOP
	NOP
	LDA	CIOCTL	
	
* Set address pointer to Master Interrupt Control Register (ADDR 0)	
	CLRA
	STA	CIOCTL	
	
* Reset the Z8536 by enabling the RESET bit (b0)	
	NOP
	NOP
	LDA	#1
	STA	CIOCTL		

* NEXT, BY WRITING A 0 TO REGISTER 0 DURING RESET, THE RESET WILL BE CLEARED.
* SUCCESSIVE WRITES CAN ONLY BE DONE DURING RESET (DURING NORMAL OPERATION,
* SUCCESSIVE WRITES WILL CHANGE THE ADDRESS POINTER TO THAT OUTPUT VALUE).
	CLRA
	STA	CIOCTL	
	RTS

***************
* CTMINIT
* Initialize CIO Counter-Timer Module 
***************
*
* SET UP PORT B (HIGH NIBBLE) AS A COUNTER. THIS IS COUNTER 1. (PORT B LOW
* NIBBLE IS COUNTER 2 AND PORT C IS COUNTER 3).
CTMINIT
* SET THE ADDRESS POINTER TO THE MASTER CONFIGURATION CONTROL REGISTER
	LDA	#1
	STA	CIOCTL
	
* DISABLE COUNTER 1 PRIOR TO CONFIGURATION	
	LDA	#$14
	STA	CIOCTL
	
* SET THE ADDRESS POINTER TO THE PORT 'B' DATA DIRECTION REGISTER
	LDA	#$2B
	STA	CIOCTL
	
* SET THE FOLLOWING PIN DIRECTIONS
*   COUNTER/TIMER OUTPUT  PORT B BIT 4
*   COUNTER INPUT         PORT B BIT 5
*   TRIGGER INPUT         PORT B BIT 6
*   GATE INPUT            PORT B BIT 7 	
	LDA	#$EE
	STA	CIOCTL
	
* SET THE ADDRESS POINTER TO THE MODE SPECIFICATION REGISTER
	LDA	#$1C
	STA	CIOCTL
	
* SETS THE COUNTER/TIMER FOR THE FOLLOWING:	
*   CONTINUOUS CYCLE ENABLED; EXTERNAL OUTPUT ENABLED; DISABLE EXTERNAL COUNT,
*   TRIGGER, AND GATE; RETRIGGER ENABLED; SQUARE-WAVE OUPUT.
*	LDA	#$C6
	LDA	#$82
	STA	CIOCTL

*   THE COUNTER/TIMERS CAN BE ACCESSED EXTERNALLY - THAT IS, USE AN EXTERNAL
*   COUNTER SOURCE, EXTERNAL TRIGGER AND GATE.  TO ENABLE EXTERNAL ACCESS,
*	LDA	#$FE
*	STA	CIOCTL

* THE FOLLOWING TWO REGISTERS SETS THE TIME CONSTANT.  THIS IS THE FREQUENCY
* OF COUNTING AND THE WIDTH OF THE SQUARE WAVE PULSE.

* SET THE ADDRESS POINTER TO THE COUNTER/TIMER TIME CONSTANT REGISTER MSB
	LDA	#$16
	STA	CIOCTL

* SETS THE TIME CONSTANT MSB TO $1f
	LDA	#$1f
	STA	CIOCTL
	
* SET THE ADDRESS POINTER TO THE COUNTER/TIMER TIME CONSTANT REGISTER LSB
	LDA	#$17
	STA	CIOCTL

* SETS THE TIME CONSTANT LSB TO $ff
	LDA	#$ff
	STA	CIOCTL

* SET THE ADDRESS POINTER TO THE MASTER CONFIGURATION CONTROL REGISTER
	LDA	#1
	STA	CIOCTL
	
* ENABLE COUNTER 1 
	LDA	#$D4
	STA	CIOCTL
	
* SET THE ADDRESS POINTER TO THE COMMAND AND STATUS REGISTER
	LDA	#$0A
	STA	CIOCTL	
	
* TRIGGER THE COUNTER	
	LDA	#$06
	STA	CIOCTL
	RTS	

***************
* CTMREAD
* Read CIO Counter 1 Value 16 times in a row
***************
*
CTMREAD
	LDX	#$10
CTMRD.0	
* OUTPUT A CR+LF PRIOR TO PRINTING TIMER 1 VALUE
	BSR	LFCR

* SET THE ADDRESS POINTER TO THE CURRENT COUNT REGISTER MSB
	LDA	#$10
	STA	CIOCTL
	
* READ THE CONTENTS OF THE CURRENT COUNT REGISTER MSB
	LDA	CIOCTL
	STA	store+1
	
* SET THE ADDRESS POINTER TO THE CURRENT COUNT REGISTER LSB
	LDA	#$11
	STA	CIOCTL
	
* READ THE CONTENTS OF THE CURRENT COUNT REGISTER LSB
	LDA	CIOCTL
	STA	store+2
	
	LDD	store+1
	JSR	wrdout
	LEAX	-1,X
	BNE	CTMRD.0
	RTS	
	
*
* OUTPUT A WORD (IN HEX) FROM REGISTER D
*
WRDOUT	BSR	HEXOUT		Output first byte
	TFR	B,A		Get second byte
*
* OUTPUT A BYTE (IN HEX) FROM REGISTER A
*
HEXOUT	PSHS	A		Save low nibble
	LSRA			Rotate
	LSRA			upper nibble
	LSRA			into
	LSRA			lower nibble
	BSR	HOUT		Output high nibble
	PULS	A		Rertore low nibble
*
* OUTPUT A NIBBLE (IN HEX) FROM REGISTER A
*
HOUT	ANDA	#$0F		Remove upper half
	ADDA	#'0'		Convert to printable
	CMPA	#'9'		In range?
	BLS	HOUT1		Yes, display
	ADDA	#7		Convert to alpha
HOUT1	BRA	WRITE		Output character
*
* WRITE ERROR MESSAGE FOLLOWING TEXT
*
WRMSG	PSHS	X		SAVE X
	LDX	2,S		GET OLD PC
	BSR	WRLIN		OUTPUT LINE
	STX	2,S		UPDATE OLD PC
	PULS	X,PC		RESTORE X, RETURN
*
* DISPLAY MESSAGE(X)
*
WRLIN	LDA	,X+		GET CHAR FROM MESSAGE
	BEQ	WRLND		END, QUIT
	CMPA	#$FF		NEWLINE END, LFCR & EXIT
	BEQ	LFCR		IF SO, NEW LINE, RETURN
	BSR	WRITE		OUTPUT TO TERM
	BRA	WRLIN		KEEP GOING
WRLND	RTS
*
* DISPLAY LINE-FEED, CARRIAGE RETURN ON TERMINAL
*
LFCR	PSHS	A		SAVE
	LDA	#$0A		GET LF
	BSR	WRITE		OUTPUT
	LDA	#$0D		GET CR
LFC1	BSR	WRITE		OUTPUT
	PULS	A,PC		RESTORE AND GO HOME
*	
* READ UART(X)
*
READ	LDA	SCCAC	; reset register pointer to WR0/RR0
	LDA	SCCAC	; read RR0
	ANDA	#%00000001	; examine the RX char available bit
	BEQ	NOCHR
	LDA	SCCAD
	ORCC	#%00000100	SET 'Z'
	RTS
NOCHR	LDA	#$FF		NO CHAR
	RTS
*	
* WRITE UART(X)
*
WRITE	PSHS	A
WR1	LDA	SCCAC	; reset register pointer to WR0/RR0
	LDA	SCCAC	; read RR0
	ANDA	#%00000100	; examine the TX buffer empty bit
	BEQ	WR1	;    if not empty, check again
   	PULS	A
	STA	SCCAD	; put character in data register
	RTS
	
	
	






	
