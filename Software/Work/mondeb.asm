; This is a port of the MONDEB monitor/debugger to the 6809,
; specifically my 6809-based Single Board Computer.
;
; It is a port of the original 6800 version by Don Peters, with some
; additional changes taken from a 6809 version written by Alan R.
; Baldwin.
;
; Jeff Tranter <tranter@pobox.com>

        NAM   MONDEB

;THIS SOURCE CODE WAS SENT TO WALTER BANKS AT
;THE UNIVERSITY OF WATERLOO BY DON PETERS ON PAPER TAPE
;CROSS ASSEMBLY WAS DONE ON THE U OF W HONEYWELL 66/60
;THE BARCODE AND LISTING WERE SET ON A PHOTON PHOTO-
;TYPESETTER DRIVEN BY THE HONEYWELL.
;
;       M O N D E B  - A MONITOR/DEBUGGER FOR THE M6800 MICROPROCESSOR

; AUTHOR: DON PETERS
; DATE: APRIL 1977
; MEMORY REQ'D: 3K BYTES AT HIGH END OF ADDRESS SPACE

; SEE USER MANUAL FOR CAPABILITIES & INSTRUCTIONS ON USE

;      ORG     $400    ;DEBUG ORG AT 1K
       ORG    $F000    ;NORMAL ORIGIN AT 60K


;I/O DEVICE ADDRESSES
ACIA1  EQU    $A001    ;ACIA #1 - MAIN TERMINAL ACIA
ACIA2  EQU    $A001    ;ACIA #2 - AUXILIARY TERMINAL ACIA

;OTHER CONSTANTS
CR     EQU    13       ;CARRIAGE RETURN
LF     EQU    10       ;LINE FEED


START  EQU    *        ;PROGRAM ENTRY POINT
       LDS    #STACK   ;INITIALIZE THE STACK POINTER
       STS    SP       ;SAVE THE POINTER
       JSR    INITAL   ;INITIALIZE VARIABLES


;TYPE OUT MONITOR NAME & VERSION
       JSR    DOCRLF   ;ADVANCE TO A CLEAN LINE
       LDX    #MSGHED  ;GET ADDRESS OF HEADER
       JSR    OUTSTR   ;TYPE IT

;SET UP DESTINATION OF INPUT LINE
;DEFINE BEGINNING OF INPUT BUFFER
       LDX    #TTYBUF-1   ;GET ADDRESS OF TERMINAL INPUT BUFFER
       STX    BUFBEG   ;SAVE IT

;DEFINE END OF INPUT BUFFER - 72 CHAR CAPACITY, INCL CR
       LDX    #TTYEND
       STX    BUFEND

;DELIMITER CLASS DEFINITION - SPACE OR COMMA (CODE 3)
       LDA    #3
       STA    DELIM
       BRA    PROMP1

;PREPARE TO GET A NEW COMMAND
PROMPT JSR    DOCRLF   ;TYPE CR-LF
       INC    BOLFLG   ;SET "BEGINNING OF LINE" FLAG
       LDX    SYNPTR   ;POINT TO CURRENT CHARACTER
       LDA    ,X       ;GET IT
       CMPA   #';'     ;SEMICOLON?
       BEQ    GETCMD   ;CONTINUE SCAN IF IT IS, SKIPPING THE PROMPT

;TYPE PROMPT
PROMP1 LDX    #MSGPRM
       JSR    OUTSTR
       JSR    GETLIN  ;GET LINE OF INPUT

;ABORT LINE ON A CONTROL-C
       CMPB   #3
       BEQ    PROMPT

;SET SYNTAX SCANNING POINTER TO BEGINNING OF BUFFER/LINE
       LDX    BUFBEG
       STX    SYNPTR

;REPROMPT ON AN EMPTY LINE (FIRST CHAR = CR, LF, OR ;)
       LDA    1,X      ;GET FIRST CHAR
       JSR    TSTEOL   ;TEST IT
       BEQ    PROMPT   ;IF IT IS, PROMPT AGAIN

;USE LIST 1 WHEN MATCHING
GETCMD LDA    #1

;NOW GO FOR A MATCH
       JSR    COMAND

;-AND TEST THE RESULT OF THE SCAN
       BEQ    PROMPT   ;REPROMPT IF JUST A CR WAS TYPED
       BGT    JMPCMD   ;GOOD COMMAND IF POSITIVE

;*****
;UNRECOGNIZABLE SYNTAX - POINT TO ERROR
BADSYN LDX    BUFBEG   ;GET START OF LINE
;SPACE OVER TO ERROR IN SYNTAX
BADS1  CPX    LINPTR   ;AT ERROR?
       BEQ    BADS2
       JSR    OUTSP    ;OUTPUT A SPACE
       LEAX   1,X      ;NO, MOVE ON
       BRA    BADS1

;THE "EXTRA" CHAR "1" IS COMPENSATED FOR BY THE PROMPT CHAR ON THE PRECEDING LINE
BADS2  LDA    #'^'     ;AT ERROR - GET AN UP-ARROW
       JSR    OUTCHR   ;PRINT IT
       JSR    DOCRLF
       BRA    PROMP1   ;IGNORE ANY SUCCEEDING PACKED COMMANDS

;*****
;THERE SHOULD BE NO MORE CHARACTERS ON THE INPUT LINE
;                       (EXCEPT DELIMITERS)
NOMORE JSR    SKPDLM
       BCS    PROMPT   ;IF CARRY BIT SET, END OF LINE (NORMAL)
;THERE IS SOMETHING THERE BUT SHOULDN'T BE
       BRA    BADSYN

;*****
;EXECUTE A COMPUTED "GOTO" TO THE PROPER COMMAND
JMPCMD TFR    A,B      ;SAVE COMMAND # IN ACCB
       ASLA            ;MULTIPLY COMMAND BY 2
       PSHS   B        ;ABA
       ADDA  ,S+       ;ACCA NOW HOLDS COMMAND # MULTIPLIED BY 3
;ADD IT TO BASE OF JUMP TABLE
       LDB    #JMPHI   ;GET HI BYTE OF START OF JUMP TABLE IN ACCB
       ADDA   #JMPLO   ;ADD LO BYTE OF START OF JUMP TABLE TO ACCA
       ADCB   #0       ;ADD CARRY IF THERE WAS ONE
;MOVE ACCA & ACCB TO IX (CODE IS WEIRD, BUT BRIEF)
       PSHS   A
       PSHS   B
       TFR    S,X      ;PUT ADDRESS OF "GOTO" INTO X
       LDX    ,X       ;GET THE ADDRESS ITSELF
       PULS   B        ;RESTORE THE STACK
       PULS   A
       JMP    ,X       ;JUMP TO RIGHT COMMAND

JMPTBL EQU    *-3

JMPHI  EQU    JMPTBL/256
JMP256 EQU    JMPHI*256
JMPLO  EQU    JMPTBL-JMP256

       LBRA   REG
       LBRA   GOTO
       LBRA   LSEI
       LBRA   LCLI
       LBRA   COPY
       LBRA   BREAK
       LBRA   IBASE
       LBRA   DBASE
       LBRA   CONTIN
       LBRA   DISPLA
       LBRA   SET
       LBRA   VERIFY
       LBRA   SEARCH
       LBRA   TEST
       LBRA   INT
       LBRA   NMI
       LBRA   LSWI
       LBRA   COMPAR
       LBRA   DUMP
       LBRA   LOAD
       LBRA   DELAY
       LBRA   HELP
       LBRA   LCLF
       LBRA   LSEF
       LBRA   FIRQ
       LBRA   RSRVD
       LBRA   LSWI2
       LBRA   LSWI3

;*****
;REG - DISPLAY REGISTERS
REG    EQU    *
;PRINT STACK STORED SWI DATA
DISREG LDX    SP       ;GET SAVED STACK POINTER

;REGISTER NAME TYPEOUT INITIALIZATION
       CLR    COMNUM   ;START AT BEGINNING OF THE REGISTER NAME LIST

       BSR    OUT2     ;TYPE CONDITION CODES
       BSR    OUT2     ;TYPE ACCA
       BSR    OUT2     ;TYPE ACCB
       BSR    OUT2     ;TYPE DP

       BSR    OUT4     ;TYPE X REG
       BSR    OUT4     ;TYPE Y REG
       BSR    OUT4     ;TYPE U REG
       BSR    OUT4     ;TYPE PROGRAM COUNTER

;TYPE THE STACK POINTER LOCATION
       BSR    OUT2A4   ;TYPE STACK POINTER ID
       LDX    #SP
       JSR    OUT2BY   ;TYPE THE VALUE
       LBRA   NOMORE

;OUTPUT CONTENT OF A 1 BYTE REGISTER
OUT2   BSR    OUT2A4
       JSR    OUT1BY
       LEAX   1,X
       RTS

;OUTPUT CONTENT OF A 2 BYTE REGISTER
OUT4   BSR    OUT2A4
       JSR    OUT2BY
       LEAX   2,X      ;SKIP TO NEXT 2 BYTES IN STACK
       RTS

;MISC SETUP FOR REGISTER DISPLAY
OUT2A4 JSR    OUTSP    ;OUTPUT A SPACE
       INC    COMNUM   ;SKIP TO NEXT REGISTER NAME
       LDA    #5       ;REGISTER NAME IS IN LIST 5
       JSR    TYPCMD   ;TYPE IT
       JSR    OUTEQ    ;TYPE AN "="
       RTS

;ENTER HERE FROM SOFTWARE INTERRUPT
TYPSWI LDX    #MSGSWI
       JSR    OUTSTR
;DECREMENT PC SO IT POINTS TO "SWI" INSTRUCTION
       LDX    SP
       TST    12,X      ;TEST LO BYTE OF PC FOR PENDING BORROW
       BNE    TYPSW1
       DEC    11,X      ;NEED TO BORROW, DEC HI BYTE OF PC
TYPSW1 DEC    12,X      ;DECR LO BYTE OF PC
       BRA    DISREG   ;GO DISPLAY REGISTERS
;*****
;GOTO - GO TO MEMORY ADDRESS
GOTO   JSR    NUMBER   ;GET DESTINATION
       BEQ    GOTO1    ;IF NONE, USE DEFAULT
       LDX    NBRHI
       STX    LASTGO   ;SAVE IT
       JMP    ,X       ;GO TO DESTINATION

GOTO1  LDX    LASTGO   ;GET LAST GOTO ADDRESS
       JMP    ,X       ;GO TO IT

;*****
;SEI - SET INTERRUPT MASK
LSEI   ORCC   #$10     ;SEI
       BRA    COPY3

;*****
;SEF - SET FAST INTERRUPT MASK
LSEF   ORCC   #$40     ;SEF
       BRA    COPY3

;*****
;CLI - CLEAR INTERRUPT MASK
LCLI   ANDCC  #$EF     ;CLI
       BRA    COPY3

;*****
;CLF - CLEAR FAST INTERRUPT MASK
LCLF   ANDCC  #$EF     ;CLF
       BRA    COPY3

;*****
;COPY - COPY FROM ONE LOCATION TO ANOTHER
COPY   JSR    GTRANG   ;GET SOURCE RANGE INTO RANGLO & RANGHI
       BLE    COPY2    ;ERROR IF NO SOURCE
       JSR    NUMBER   ;GET DESTINATION
       BLE    COPY2    ;ERROR IF NO DESTINATION

       LDX    RANGLO   ;GET SOURCE ADDRESS POINTER
COPY1  LDA    ,X       ;GET BYTE FROM SOURCE
       LDX    NBRHI    ;GET DESTINATION ADDRESS POINTER
       STA    ,X       ;SAVE BYTE IN DESTINATION
       LEAX   1,X      ;INC DESTINATION POINTER
       STX    NBRHI    ;SAVE IT
       LDX    RANGLO   ;GET SOURCE ADDRESS POINTER
       CPX    RANGHI   ;COMPARE TO END OF INPUT RANGE
       BEQ    COPY3    ;DONE IF EQUAL
       LEAX   1,X      ;NOT EQUAL, INC SOURCE POINTER
       STX    RANGLO   ;SAVE IT
       LBRA   COPY1    ;LOOP FOR NEXT BYTE

COPY2  LBRA   BADSYN   ;BAD SYNTAX
COPY3  LBRA   NOMORE   ;SHOULD BE NO MORE ON THE INPUT LINE

;*****
;BREAK - SET BREAKPOINT AT SPECIFIED ADDRESS & REMOVE OLD ONE
BREAK  JSR    NUMBER   ;GET BREAKPOINT LOCATION
       BMI    BREAK3   ;IF NOT NUMERIC, LOOK FOR "?"
       BEQ    BREAK2   ;IF NO MODIFIER, REMOVE OLD BREAKPOINT

;*****
;CHECK IF A "SWI" IS STORED AT THE BREAK ADDRESS
       LDX    BRKADR   ;GET CURRENT BREAK ADDRESS
       LDA    ,X       ;AND THE CHAR THERE
       CMPA   #$3F     ;COMPARE TO "SWI"
       BNE    BREAK1   ;EQUAL?
;YES, RESTORE THE OLD INSTRUCTION
       LDA    BRKINS   ;GET IT
       STA    ,X       ;RESTORE IT

;PUT BREAK AT NEWLY SPECIFIED LOCATION
BREAK1 LDX    NBRHI    ;GET NEW BREAKPOINT (BREAK ADDRESS)
       STX    BRKADR   ;SAVE IT
       LDA    ,X       ;GET INSTRUCTION STORED THERE
       STA    BRKINS   ;SAVE IT
       LDA    #$3F     ;GET CODE FOR SOFTWARE INTERRUPT
       STA    ,X       ;PUT IT AT BREAKPOINT
       BRA    BREAK5   ;ALL DONE

;REMOVE BREAKPOINT
BREAK2 LDX    BRKADR   ;GET ADDRESS OF BREAK
       LDA    ,X       ;GET INST. THERE
       CMPA   #$3F     ;SWI?
       BNE    BREAK5   ;IF NOT,, RETURN & PROMPT
       LDA    BRKINS   ;WAS A SWI - GET PREVIOUS INST.
       STA    ,X       ;& RESTORE IT
       BRA    BREAK5

;LOOK FOR A QUESTION MARK IN LIST 4
BREAK3 LDA    #4
       JSR    COMAND   ;SCAN FOR IT
       BLE    BREAK6   ;BAD SYNTAX IF NOT "?"
       LDX    BRKADR   ;IT IS, GET BREAK ADDRESS
       LDA    ,X       ;GET INSTRUCTION THERE
       CMPA   #$3F     ;IS IT A "SWI"?
       BEQ    BREAK4   ;IF YES, SAY SO
;NO BREAKPOINT SET
       LDX    #MSGNBR  ;GET THAT MESSAGE
       JSR    OUTSTR   ;SAY IT
       BRA    BREAK5
;BREAKPOINT SET
BREAK4 LDX    #MSGBAT  ;GET THAT MESSAGE
       JSR    OUTSTR   ;SAY IT
       LDX    #BRKADR  ;GET BREAK ADDRESS
       JSR    OUT2BY   ;TYPE IT

BREAK5 LBRA   NOMORE
BREAK6 LBRA   BADSYN

;*****
;IBASE - SET INPUT BASE
;LOOK FOR HEX, DEC, OR OCT IN LIST #3
IBASE  LDA    #3
       JSR    COMAND
       BMI    IBASE2   ;UNRECOGNIZABLE BASE, TRY "?"
       BGT    IBASE1
       LDA    #1       ;NO BASE GIVEN - DEFAULT TO HEX
IBASE1 STA    IBCODE   ;SAVE BASE CODE
       BRA    BREAK5

;LOOK FOR "?" IN LIST #4
IBASE2 LDA    IBCODE   ;GET IB CODE IN CASE ITS NEEDED
       PSHS   A        ;SAVE IT ON STACK TEMPORARILY
       BRA    DBASE4

;*****
;DBASE - SET DISPLAY BASE
;LOOK FOR HEX,DEC,OCT OR BIN IN LIST #3
DBASE  LDA    #3
       JSR    COMAND
       BMI    DBASE3   ;UNRECOGNIZABLE BASE, TRY "?"
       BGT    DBASE1
       LDA    #1       ;NO BASE GIVEN - DEFAULT TO HEX
DBASE1 STA    DBCODE

;COMPUTE THE NUMERIC DISPLAY BASE (FOR THE "DISPLAY" COMMAND)
       LDX    #DBTBL-1 ;POINT TO HEAD OF DISPLAY BASE TABLE
DBASE2 LEAX   1,X      ;INC TABLE POINTER
       DECA            ;DECR DISPLAY BASE CODE
       BNE    DBASE2   ;LOOP IF NOT EQUAL
       LDA    ,X       ;EQUAL - GET NUMERIC BASE FROM TABLE
       STA    DBNBR    ;SAVE IT
       BRA    BREAK5   ;DONE

;DISPLAY BASE TABLE
DBTBL  FCB    16
       FCB    10
       FCB    8
       FCB    2

;LOOK FOR "?" IN LIST #4
DBASE3 LDA    DBCODE   ;GET DB CODE IN CASE ITS NEEDED
       PSHS   A        ;SAVE IT ON STACK TEMPORARILY
DBASE4 LDA    #4
       JSR    COMAND
       PULS   B        ;RETRIEVE INPUT BASE/DISPLAY BASE CODE
       BLE    BREAK6   ;ERROR IF THE "SOMETHING" WAS NOT AN "?"
;SET UP FOR TYPEOUT OF BASE CODE
       LDA    #3       ;ITS IN LIST
       STB    COMNUM   ;STORE BASE CODE
       JSR    TYPCMD   ;TYPE OUT BASE
       BRA    BREAK5
;*****
;CONTINUE - CONTINUE FROM A "SWI"
;RETURN TO LOCATION WHERE SWI WAS
CONTIN LDS    SP       ;IN CASE SP WAS MODIFIED VIA SET COMMAND
       RTI

;*****
;DISPLAY - DISPLAY MEMORY DATA
DISPLA JSR    GTRANG   ;GET MEMORY DISPLAY RANGE
       BLE    DISPL9   ;ADDRESS IS REQUIRED

;INITIALIZE ADDRESS POINTER TO START OF MEMORY
       LDX    RANGLO
       STX    MEMADR

;SEARCH LIST 6 FOR DISPLAY MODIFIERS "DATA" OR "USED"
       LDA    #6
       JSR    COMAND
       BMI    DISPL9   ;ANY OTHER MODIFIER IS ILLEGAL
;ADJ DISPLAY MODIFIER CODE SO THAT: -1=ADDR & DATA, 0=DATA, I=USED
       DECA
       STA    COMNUM   ;SAVE FOR LATER TESTS
;INIT "DATA VALUES PER LINE" COUNTER
       CLRB
       INCB
DISPL1 LDX    #MEMADR
       TST    COMNUM   ;WHICH DISPLAY OPTION?
       BMI    DISPL6   ;IF "ADDRESS & DATA", GO THERE

;OUTPUT DATA WITH ADDRESS ONLY AT LINE BEGINNING
       DECB            ;COUNT DATA VALUES PER LINE
       BNE    DISPL2   ;IF COUNT NOT UP, SKIP ADDRESS OUTPUT

       JSR    DOCRLF   ;GET TO LINE BEGINNING
       JSR    OUT2BY   ;OUTPUT ADDRESS
       JSR    OUTSP    ;AND A SPACE
       LDB    DBNBR    ;RESET LINE COUNTER

DISPL2 LDX    MEMADR   ;POINT TO DATA AT THAT ADDRESS
       TST    COMNUM   ;WANT "DATA" OPTION?
       BGT    DISPL3   ;IF NOT, GO TO "USES" CODE

;"DATA" OPTION
       JSR    OUTSP    ;OUTPUT PRECEDING SPACE
       BRA    DISPL7
;"USED" OPTION
DISPL3 LDA    ,X       ;GET THE DATA
       TSTA            ;EXAMINE IT FOR ZERO
       BNE    DISPL4
       LDA    #'.'     ;ITS ZERO, GET A "."
       BRA    DISPL5
DISPL4 LDA    #'+'     ;ITS NON-ZERO. GET A "+"
DISPL5 JSR    OUTCHR   ;OUTPUT THE "." OR "+"
       BRA    DISPL8

DISPL6 JSR    OUTSP    ;OUTPUT A PRECEEDING SPACE
       JSR    OUT2BY   ;TYPE ADDRESS
       JSR    OUTEQ    ;TYPE "="
       LDX    ,X       ;GET CONTENT
DISPL7 JSR    OUT1BY   ;TYPE IT

DISPL8 CPX    RANGHI   ;ARE WE DONE?
       BEQ    DISP10   ;IF YES, BACK TO PROMPT
       LEAX   1,X      ;NO, INC MEMORY ADDRESS
       STX    MEMADR   ;SAVE IT
       BRA    DISPL1

DISPL9 LBRA   BADSYN
DISP10 LBRA   NOMORE

;*****
;SET - SET MEMORY LOCATIONS
SET    JSR    GTRANG   ;GET MEMORY LOCATION/RANGE
       BMI    SET5     ;IF NOT AN ADDRESS, LOOK FOR A REGISTER NAME
       BEQ    DISPL9   ;AN ADDRESS MODIFIER IS REQUIRED

;RANGE OF ADDRESSES SPECIFIED?
       LDX    RANGLO
       CPX    RANGHI
       BEQ    SET2     ;IF SINGLE ADDRESS, SET UP ADDRESSES INDIVIDUALLY
;SET A RANGE OF ADDRESSES TO A SINGLE VALUE
       JSR    NUMBER   ;GET THAT VALUE
       BLE    DISPL9   ;ITS REQUIRED
       LDA    NBRLO    ;PUT IT IN ACCA
SET1   STA    ,X       ;STORE IT IN DESTINATION
       CPX    RANGHI   ;END OF RANGE HIT?
       BEQ    DISP10   ;IF YES,ALL DONE
       LEAX   1,X      ;NO, ON TO NEXT ADDRESS IN RANGE
       BRA    SET1     ;LOOP TO SET IT
;SET ADDRESSES UP INDIVIDUALLY
SET2   STX    MEMADR   ;SAVE MEMORY LOC
SET3   JSR    NUMBER   ;GET DATA TO PUT THERE
       BEQ    SET4     ;END OF LINE?
       BLT    DISPL9   ;ABORT IF BAD SYNTAX
       LDA    NBRLO    ;LOAD DATA BYTE
       LDX    MEMADR   ;LOAD ADDRESS
       STA    ,X       ;STORE DATA

;INCREMENT ADDRESS IN CASE USER WANTS TO INDIVIDUALLY SET SEVERAL
;SUCCESSIVE LOCATIONS
       LEAX   1,X
       BRA    SET2

;END OF LINE - WAS IT TERMINATED WITH A LINE FEED?
SET4   LDX    SYNPTR   ;POINT TO END OF LINE
       LDA    ,X       ;GET CHAR THERE
       CMPA   #LF      ;LINE FEED?
       LBNE   SET12    ;IF NOT, BACK TO PROMPT
       LDX    #MEMADR  ;YES, GET NEXT ADDRESS TO BE SET
       JSR    OUT2BY   ;TYPE IT
       JSR    OUTSP    ;AND A SPACE
       JSR    GETLIN   ;GET A NEW LINE
       LDX    BUFBEG   ;GET BUFFER BEGINNING
       STX    SYNPTR   ;EQUATE IT TO SYNTAX SCAN POINTER
       BRA    SET3     ;GO PICK UP DATA


;LOOK FOR (REGISTER NAME, REGISTER VALUE) PAIRS
SET5   LDA    #5
       JSR    COMAND   ;PICK UP A REGISTER NAME
       BMI    SET11    ;ERROR IF UNRECOGNIZABLE
       BEQ    SET12    ;DONE IF END OF LINE
       PSHS   A        ;SAVE REGISTER NAME(NUMBER)
       JSR    NUMBER   ;GET NEW REGISTER VALUE
       PULS   A        ;RESTORE REGISTER NAME(NUMBER)
       BLE    SET11    ;GOT GOOD REGISTER VALUE?
       LDX    SP       ;YES, POINT TO TOP OF STACK
       LDB    NBRLO    ;GET REGISTER VALUE

;CONDITION CODES
       CMPA   #1
       BNE    SET6
       STB     ,X
       BRA    SET5
;ACCA
SET6   CMPA   #2
       BNE    SET7
       STB    1,X
       BRA    SET5

;ACCB
SET7   CMPA   #3
       BNE    SET7A
       STB    2,X
       BRA    SET5

;DP
SET7A  CMPA   #4
       BNE    SET8
       STB    3,X
       BRA    SET5

;X
SET8   CMPA   #5
       BNE    SET8A
       LDA    NBRHI
       STD    4,X
       BRA    SET5

;Y
SET8A  CMPA   #6
       BNE    SET8B
       LDA    NBRHI
       STD    6,X
       BRA    SET5

;U
SET8B  CMPA   #7
       BNE    SET9
       LDA    NBRHI
       STD    8,X
       BRA    SET5

;PC
SET9   CMPA   #8
       BNE    SET10
       LDA    NBRHI
       STD    10,X     ;UPDATE HI BYTE
       BRA    SET5

;S
SET10  CMPA   #9
       BNE    SET11
       STD    SP
       BRA    SET5

SET11  LBRA   BADSYN
SET12  LBRA   NOMORE
;*****
;VERIFY - CHECKSUM VERIFY A BLOCK OF MEMORY
VERIFY JSR    GTRANG   ;GET A NUMBER RANGE
       BEQ    VERIF1   ;NO MODIFIER MEANS CHECK WHAT WE HAVE
       BMI    SET11    ;ANYTHING ELSE IS ILLEGAL
;GOOD RANGE GIVEN, TRANSFER IT TO CHECKSUM ADDRESSES
       LDX    RANGLO
       STX    VERFRM
       LDX    RANGHI
       STX    VERTO

       BSR    CKSUM    ;COMPUTE CHECKSUM
       STA    CHKSUM   ;SAVE IT
       LDX    #CHKSUM  ;TYPE THE CHECKSUM
       JSR    OUT1BY
       BRA    SET12

;NO MODIFIER GIVEN - JUST VERIFY CHECKSUM
VERIF1 BSR    CKSUM    ;COMPUTE CHECKSUM
       CMPA   CHKSUM   ;SAME AS STORED CHECKSUM?
       BNE    VERIF2

;THEY VERIFY - SAY SO
       LDX    #MSGVER
       JSR    OUTSTR
       BRA    SET12

;THEY DON'T - SAY SO
VERIF2 LDX    #MSGNVE
       JSR    OUTSTR
       BRA    SET12

;COMPUTE THE CHECKSUM FROM ADDRESSES VERFRM TO VERTO
;RETURN THE CHECKSUM IN ACCA
CKSUM  CLRA            ;INIT CHECKSUM TO ZERO
       LDX    VERFRM   ;GET FIRST ADDRESS
       LEAX   -1,X     ;INIT TO ONE LESS
CKSUM1 LEAX   1,X      ;START OF CHECKSUM LOOP
       ADDA   ,X       ;UPDATE CHECKSUM IN ACCA WITH BYTE POINTED TO
       CPX    VERTO    ;HIT END OF RANGE?
       BNE    CKSUM1   ;IF NOT, LOOP BACK
       COMA            ;COMPLEMENT THE SUM
       RTS             ;RETURN WITH IT
;*****
;SEARCH - SEARCH MEMORY FOR A BYTE STRING

;GLOBAL VARIABLES USED
;LINPTR - INPUT LINE CHARACTER POINTER
;LISPTR - COMMAND LIST CHARACTER POINTER
;RANGLO - "SEARCH FROM" ADDRESS
;RANGHI - "SEARCH TO" ADDRESS

;LOCAL VARIABLES USE
;MEMADR - STARTING MEMORY ADDRESS WHERE A MATCH OCCURRED
;BYTPTR - ADDRESS POINTER USED TO FILL BYTSTR AND SUBSTR BUFFERS
;NBYTES - NUMBER OF BYTES IN BYTE STRING
;NBRMAT - NUMBER OF CHARS THAT MATCH SO FAR IN THE MATCHING PROCESS
;BYTSTR - STARTING ADDRESS OF 6 CHARACTER BYTE STRING BUFFER

;THE SEARCH STRING OCCUPIES TEMP4, TEMP5, & TEMP6 (6 BYTES MAX)

;GET SEARCH RANGE BEGINNING (RANGLO) & END (RANGHI)
SEARCH JSR    GTRANG
       LBLE   SEARC9   ;ABORT IF NO PAIR

;INITIALIZED BYTE STRING POINTER
       LDX    #BYTSTR  ;GET START OF BYTE STRING TO SEARCH FOR
       STX    BYTPTR   ;SET POINTER TO IT

       CLR    NBYTES   ;ZERO # OF BYES IN BYTE STRING

;GET BYTE STRING
SEARC1 JSR    NUMBER   ;GET A BYTE
       BEQ    SEARC2   ;BEGIN SEARCH IF EOL
       BLT    SEARC9

;GOOD BYTE, ADD IT TO STRING
       INC    NBYTES   ;COUNT THIS BYTE
;DON'T ACCEPT OVER 6 BYTES
       LDA    NBYTES
       CMPA   #6
       BGT    SEARC9

       LDA    NBRLO    ;GET (LOW ORDER) BYTE
       LDX    BYTPTR   ;GET BYTE POINTER
       STA    ,X       ;SAVE BYTE
       LEAX   1,X      ;MOVE BYTE POINTER TO NEXT LOCATION IN STRING
       STX    BYTPTR   ;SAVE IT
       BRA    SEARC1

;BEGIN SEARCH FOR BYTE STRING
;IS # OF BYTES TO LOOK FOR >0
SEARC2 TST    NBYTES
       BEQ    SEARC9   ;IF NOT, BAD SYNTAX

;MAKE USE OF INPUT LINE CHARACTER FETCH & COMMAND LIST CHAR FETCH ROUTINES

;INITIALIZE MEMORY POINTER TO START OF SEARCH RANGE
       LDX    RANGLO
       LEAX   -1,X
       STX    LINPTR

;INITIALIZE BYTE POINTER TO START OF BYTE STRING
SEARC3 LDX    #BYTSTR-1
       STX    LISPTR

       CLR    NBRMAT   ;SET "NUMBER OF BYTES THAT MATCHED" TO ZERO
;GET BYTE FROM BYTE STRING & RETURN IT IN ACCA
       JSR    GETLST
;GET BYTE FROM MEMORY RANGE & RETURN IT IN ACCB
SEARC4 JSR    GETCHR

       PSHS   B        ;CBA
       CMPA   ,S+      ;COMPARE MEMORY & BYTE STRING CHARACTERS
       BEQ    SEARC5   ;IF NO MATCH, TEST FOR RANGE END
       CPX    RANGHI   ;HAVE WE REACHED THE RANGE SEARCH UPPER LIMIT?
       BEQ    SEAR10   ;YES, GO PROMPT FOR NEXT COMMAND
       BRA    SEARC4

;MATCH ACHIEVED - SAVE ADDRESS OF MATCH
SEARC5 STX    MEMADR
SEARC6 INC    NBRMAT   ;BUMP NUMBER MATCHED
       LDA    NBRMAT
       CMPA   NBYTES   ;HAVE ALL CHARACTERS MATCHED?
       BEQ    SEARC8   ;IF SO, MATCH ACHIEVED
;HAVEN'T MATCHED ALL YET, GO GET NEXT PAIR EVEN IF PAST "SEARCH TO" ADDRESS
       JSR    GETLST
       JSR    GETCHR
       PSHS   B        ;CBA
       CMPA   ,S+
       BEQ    SEARC6
;MISMATCH ON SOME BYTE PAST THE FIRST ONE
;RESET THE MEMORY POINTER TO GET NEXT UNTESTED MEMORY LOCATION
SEARC7 LDX    MEMADR
;THIS TEST HANDLES SPECIAL CASE OF A MATCH ON RANGE END
       CPX    RANGHI
       BEQ    SEAR10
       STX    LINPTR
;GO RESET THE BYTE STRING POINTER
       BRA    SEARC3

;MATCH ON BYTE STRING ACHIEVED, TYPE OUT MEMORY ADDRESS
SEARC8 LDX    #MEMADR
       JSR    OUT2BY
       JSR    OUTSP    ;AND A SPACE
;ASSUME A MISMATCH (I.E., RESET MEMORY & BYTE STRING POINTERS & CONTINUE
       BRA    SEARC7

SEARC9 LBRA   BADSYN
SEAR10 LBRA   NOMORE

;*****
;TEST - TEST RAM FOR BAD BYTES
;GET AN ADDRESS RANGE
TEST   JSR    GTRANG
       BLE    SEARC9   ;ABORT IF NO PAIR
;RANGLO HOLS STARTING ADDRESS OF RANGE
;RANGHI HOLDS ENDING ADDRESS OF RANGE
       LDX    RANGLO
       STX    MEMADR
;GET BYTE STORED AT TEST LOCATION & SAVE IT
TEST1  LDA    ,X
       PSHS   A

       CLR    ,X       ;ZERO THE LOCATION
       TST    ,X       ;TEST IT
       BEQ    TEST2    ;OK IF = ZERO

;CAN'T CLEAR LOCATION
       LDX    #MSGCCL
       BRA    TEST4

TEST2  DEC    ,X       ;SET LOCATION TO FF
       LDA    #$FF
       CMPA   ,X       ;DID IT GET SET TO FF?
       BEQ    TEST3

;CAN'T SET LOCATION TO ONE'S
       LDX    #MSGCSO
       BRA    TEST4

TEST3  LDX    MEMADR   ;GET LOCATION BEING TESTED
       PULS   A
       STA    ,X       ;RESTORE PREVIOUS CONTENT

;HIT END OF TEST RANGE?
       CPX    RANGHI
       BEQ    SEAR10   ;YES, ALL DONE

;NO, MOVE TO TEST NEXT LOCATION
       LEAX   1,X
       STX    MEMADR
       BRA    TEST1

;*LOCATION IS BAD
TEST4  STX    TEMP3    ;SAVE ERROR MESSAGE TEMPORARILY

       LDX    #MEMADR
       JSR    OUT2BY   ;TYPE OUT BAD ADDRESS.
       JSR    OUTEQ    ;AN EQUAL SIGN

       LDX    MEMADR
       JSR    OUT1BY   ;ITS CONTENT.
       JSR    OUTSP    ;A SPACE.
       LDX    TEMP3
       JSR    OUTSTR   ;AND THE TYPE OF ERROR

       JSR    DOCRLF   ;SEND CR-LF
       BRA    TEST3
;*****
;INT - SET UP INTERRUPT POINTER
INT    JSR    NUMINX   ;GET POINTER IN IX
       STX    INTVEC   ;SAVE IT
       BRA    COMPA1

;*****
;NMI - SET UP NON-MASKABLE INTERRUPT POINTER
NMI    JSR    NUMINX   ;GET POINTER IN IX
       STX    NMIVEC   ;SAVE IT
       BRA    COMPA1

;*****
;SWI - SET UP SWI POINTER
LSWI   JSR    NUMINX   ;GET POINTER TO IX
       STX    SWIVEC   ;SAVE IT
       BRA    COMPA1

;*****
;SWI2 - SET UP SWI2 POINTER
LSWI2  JSR    NUMINX   ;GET POINTER TO IX
       STX    SWI2VC   ;SAVE IT
       BRA    COMPA1

;*****
;SWI3 - SET UP SW3 POINTER
LSWI3  JSR    NUMINX   ;GET POINTER TO IX
       STX    SWI3VC   ;SAVE IT
       BRA    COMPA1

;*****
;FIRQ - SET UP FAST INTERRUPT POINTER
FIRQ   JSR    NUMINX   ;GET POINTER IN IX
       STX    FIRQVC   ;SAVE IT
       BRA    COMPA1

;*****
;RSRVD - SET UP RESERVED INTERRUPT POINTER
RSRVD  JSR    NUMINX   ;GET POINTER IN IX
       STX    RSRVDVC  ;SAVE IT
       BRA    COMPA1

;*****
;COMPARE - OUTPUT SUM & DIFFERENCE OF TWO INPUT NUMBERS
COMPAR JSR    NUMINX   ;GET FIRST NUMBER
       STX    RANGLO   ;PUT IT IN RANGLO

       JSR    NUMINX   ;GET SECOND NUMBER
       STX    NBRHI    ;SAVE IT IN NBRHI

;COMPUTE AND OUTPUT THE SUM
       JSR    SUMNUM   ;COMPUTE SUM
       LDX    #MSGSIS  ;GETS ITS TITLE
       BSR    OUTSD    ;OUTPUT TITLE & SUM

       JSR    DIFNUM   ;COMPUTE DIFFERENCE
       LDX    #MSGDIS  ;GET ITS TITLE
       BSR    OUTSD    ;OUTPUT TITLE & DIFFERENCE

COMPA1 LBRA   NOMORE

;COMPUTE AND OUTPUT THE RESULT
OUTSD  JSR    OUTSTR   ;OUTPUT IT
       LDX    #RANGHI  ;GET RESULT
       JSR    OUT2BY   ;DISPLAY RESULT
       RTS
;*****
;DUMP - DUMP A PORTION OF MEMORY, IN MIKBUG FORMAT, TO A SPECIFIED ACIA ADDRESS

;GET ADDRESS RANGE: START IN RANGLO (2 BYTES), END IN RANGHI (2 BYTES)
;IF NO ADDRESS RANGE IS GIVEN, USE WHATEVER IS IN RANGLO & RANGHI
DUMP   JSR    GTRANG

       CLR    TEMP5    ;INITIALIZE TO DUMP TO TERMINAL

;LOOK FOR A "TO" MODIFIER
DUMP1  LDA    #2
       JSR    COMAND
       BEQ    DUMP4
DUMP2  LBLE   DUMP10   ;ERROR IF BAD SYNTAX
       CMPA   #1       ;TO?
       BEQ    DUMP3
       BRA    DUMP1    ;GO LOOK FOR ANOTHER MODIFIER

DUMP3  JSR    NUMINX   ;GET "TO" ADDRESS
       STX    OUTADR   ;SAVE IT
       INC    TEMP5    ;REMEMBER THIS
       BRA    DUMP1    ;GO LOOK FOR ANOTHER MODIFIER

DUMP4  TST    TEMP5
       BEQ    DUMP5
       INC    OUTFLG   ;SET FLAG FOR PROPER OUTPUT DEVICE
DUMP5  BSR    NULLS    ;SEND SOME NULLS

;MIKBUG MODE
;OUTPUT AN "S0" TYPE RECORD
       LDX    #MSGS0
       JSR    OUTSTR

;COMPUTER # OF BYTES TO OUTPUT (RANGE END - RANGE START + 1)
;SUBTRACT LO BYTES
DUMP6  LDA    RANGHI+1
       SUBA   RANGLO+1
;SUBTRACT HI BYTES
       LDB    RANGHI
       SBCB   RANGLO
;NON-ZERO HI BYTE IMPLIES LOTS TO OUTPUT
       BNE    DUMP7
;HI BYTE DIFF IS ZERO
       CMPA   #16      ;LO BYTE OF DIFF 0 TO 15
       BCS    DUMP8    ;IF YES, TO DUMP8
DUMP7  LDA    #15      ;NO, LO BYTE IS 16-255; SET BYTES TO 15
;TO GET FRAME COUNT, ADD 1 (DIFF OF 0 IMPLIES 1 OUTPUT) + # OF DATA BYTES,
; + 2 ADDR BYTES + 1 CHECKSUM BYTE
DUMP8  ADDA   #4
       STA    TEMP3    ;TEMP3 IS THE FRAME COUNT
       SUBA   #3
       STA    TEMP4    ;TEMP4 IS THE RECORD BYTE COUNT
;OUTPUT A MIKBUG "S1" HEADER DATA RECORD
       LDX    #MSGS1
       JSR    OUTSTR
       CLRB            ;ZERO CHECKSUM
;PUNCH FRAME COUNT
       LDX    #TEMP3
       BSR    OUTP2

;PUNCH ADDRESS
       LDX    #RANGLO
       BSR    OUTP2
       BSR    OUTP2

;OUTPUT DATA
       LDX    RANGLO
DUMP9  BSR    OUTP2    ;OUTPUT DATA BYTE
       DEC    TEMP4    ;DEC BYTE COUNT
       BNE    DUMP9

;COMPLEMENT AND PUNCH THE CHECKSUM
       STX    RANGLO   ;SAVE MEMORY POINTER
       COMB            ;COMPLEMENT CHECKSUM
       PSHS   B        ;PUT IT ON STACK
       TFR    S,X      ;LET IX POINT TO IT
       BSR    OUTP2    ;OUTPUT CHECKSUM
       PULS   B        ;PULL IT OFF STACK
       LDX    RANGLO   ;RESTORE MEMORY POINTER
       LEAX   -1,X
       CPX    RANGHI   ;HIT END OF RANGE?
       BNE    DUMP6

;YES, OUTPUT AN "S9" RECORD
       LDX    #MSGS9
       JSR    OUTSTR
       BSR    NULLS    ;GENERATE BLANK TAPE
       CLR    OUTFLG   ;SET TO TERMINAL OUTPUT
       LBRA   NOMORE   ;ALL DONE
DUMP10 LBRA   BADSYN   ;BAD SYNTAX

;SEND A STRING OF NULLS
NULLS  RTS

;OUTPUT A BYTE POINTED TO BY IX AS 2 HEX CHARACTERS
OUTP2  ADDB   ,X       ;UPDATE CHECKSUM
       JSR    OUT1BY
       LEAX   1,X
       RTS
;*****
;LOAD - LOAD A MIKBUG TAPE
;LOOK FOR A "FROM" MODIFIER
LOAD   LDA    #7       ;IN LIST 7
       JSR    COMAND
       BMI    DUMP10   ;ERROR, UNRECOGNIZABLE MODIFIER
       BEQ    LOAD1

       JSR    NUMINX   ;GET "FROM" ADDRESS
       STX    INPADR   ;SAVE IT
       INC    INPFLG   ;SET FLAG FOR NON-TERMINAL ACIA

;KEEP READING CHARACTERS UNTIL AN "S" IS READ
LOAD1  JSR    INPCHR   ;GET A CHAR
       CMPA   #'S'     ;IS IT AN S?
       BNE    LOAD1

;GOT AN "S", EXAMINE NEXT CHARACTER
       JSR   INPCHR
       CMPA   #'9'     ;DONE IF ITS A "9"
       BEQ    LOAD5

       CMPA   #'1'     ;IS IT A "1"?
       BNE    LOAD1    ;IF NOT, LOOK FOR NEXT "S"
;VALID S1 RECORD
       CLR    CKSM     ;CLEAR CHECKSUM
;READ RECORD BYTE COUNT
       JSR    RDBYTE
       SUBA   #2
       STA    BYTECT   ;SAVE COUNT MINUS 2 ADDRESS BYTES

       BSR    BLDADR   ;BUILD ADDRESS

LOAD2  BSR    RDBYTE   ;READ A DATA BYTE INTO ACCA
       DEC    BYTECT   ;COUNT IT
       BEQ    LOAD3    ;IF DONE WITH RECORD, CHECK CHECKSUM
       STA    ,X       ;NOT DONE, STORE BYTE IN MEMORY
       LEAX   1,X      ;ON TO NEXT MEMORY ADDRESS
       BRA    LOAD2

;RECORD READ IN COMPLETE
LOAD3  INC    CKSM     ;TEST CHECKSUM BY ADDING 1
       BEQ    LOAD1    ;IF OK, RESULT SHOULD BE ZERO

;RECORD CHECKSUM ERROR
       LDX    #MSGNVE  ;SAY SO
       JSR    OUTSTR
       LDX    #TEMP1   ;GET RECORD ADDRESS OF IT
       JSR    OUT2BY   ;TYPE IT TOO
LOAD4  CLR    INPFLG   ;RESET FLAG TO NORMAL TERMINAL INPUT
       LBRA   NOMORE

LOAD5  JSR    INPCHR   ;GET A CHAR
       CMPA   #CR      ;IS IT CR?
       BEQ    LOAD4    ;IF YES, THEN DONE
       CMPA   #LF      ;IS IT LF?
       BEQ    LOAD4    ;IF YES, THEN DONE
       BRA    LOAD5    ;OTHERWISE KEEP READING REST OF S9 RECORD

;BUILD ADDRESS
BLDADR BSR    RDBYTE
       STA    TEMP1
       BSR    RDBYTE
       STA    TEMP1+1
       LDX    TEMP1
       RTS
RDBYTE BSR    INHEX    ;GET LEFT HEX DIGIT
;MOVE TO HI 4 BITS
       ASLA
       ASLA
       ASLA
       ASLA
       TFR    A,B      ;SAVE IT IN ACCA
       BSR    INHEX    ;GET RIGHT HEX DIGIT
       PSHS   B
       ADDA   ,S+      ;COMBINE THEM IN ACCA
;UPDATE THE CHECKSUM
       TFR    A,B
       ADDB   CKSM
       STB    CKSM
       RTS

;INPUT A HEX CHAR & CONVERT TO INTERNAL FORM
INHEX  JSR    INPCHR   ;INPUT A CHAR
       SUBA   #$30
       BMI    INHEX2   ;NOT HEX IF BELOW ASCII "1"
       CMPA   #$09
       BLE    INHEX1   ;OK IF ASCII "9" OR LESS
       CMPA   #$11     ;BELOW ASCII "A"?
       BMI    INHEX2   ;ERROR IF IT IS
       CMPA   #$16     ;OVER ASCII "F"?
       BGT    INHEX2   ;ERROR IF IT IS
       SUBA   #7       ;CONVERT ASCII A-F TO HEX A-F
INHEX1 RTS
;ERROR - CHAR NOT HEX, SAY SO
INHEX2 LDX    #MSGCNH
       JSR    OUTSTR
       RTS

;*****
;DELAY - DELAY SPECIFIED # OF MILLISECONDS
DELAY  JSR    NUMINX   ;GET DELAY TIME
       BSR    TIMDEL
       LBRA   NOMORE

;**
;TIME DELAY SUBROUTINE
;IX IS INPUT AS THE # OF MILLISECONDS TO DELAY
;ACCA IS ALTERED
;ACCB IS PRESERVED
;ADJ TIMCON SO (6*TIMCON*CYCLE TIME=1 MS)
TIMDEL LDA    TIMCON
;ENTER A 6 CYCLE LOOP
TIMDE1 DECA
       BNE    TIMDE1
       LEAX   -1,X     ;DECREMENT MILLISECOND COUNTER
       BNE    TIMDEL
       RTS

;HELP COMMAND
HELP   JSR    DOCRLF   ;NEXT LINE
       LDX    #COMLST  ;COMMAND LIST

HEL1   LDB    #4       ;COMMANDS PER LINE
       STB    TEMP1

HEL2   LDB    #12      ;POSITIONS PER COMMAND
                       ;MUST BE LARGER THAN LONGEST COMMAND
HEL3   LDA    ,X+      ;GET CHARACTER
       CMPA   #CR      ;<CR> IS END OF COMMAND
       BEQ    HEL4
       JSR    OUTCHR   ;PRINT COMMAND CHARACTER
       DECB
       BNE    HEL3

HEL4   LDA    ,X       ;GET CHARACTER
       CMPA   #LF      ;<LF> IS END OF LIST
       BEQ    HEL6     ;FINISHED
       DEC    TEMP1    ;PER LINE DONE ?
       BNE    HEL5     ;NO - SKIP

       JSR    DOCRLF   ;NEXT LINE
       BRA    HEL1

HEL5   LDA    #' '     ;SPACE
       JSR    OUTCHR
       DECB
       BNE    HEL5
       BRA    HEL2

HEL6   JSR    DOCRLF   ;NEXT LINE
       LBRA   NOMORE

;====================================================

;  C O M M A N D     L I S T     S C A N N I N G    R O U T I N E

;THIS ROUTINE SEEKS A MATCH OF THE CHARACTERS POINTED AT
;BY THE INPUT LINE SCANNING POINTER TO ONE OF THE COMMANDS
;IN A LIST SPECIFIED BY ACCA.
;
; AS FOLLOWS:
;
;      ACCA=-1: THE MATCH WAS UNSUCCESSFUL.  THE SYNTAX
;               POINTER (SYNPTR) WAS NOT UPDATED (ADVANCED).
;
;      ACCA= 0: THE MATCH WAS UNSUCCESSFUL SINCE THERE WERE
;               NO MORE CHARACTERS, I.E., THE END OF THE
;               LINE WAS REACHED.
;
;      ACCA=+N: SUCCESSFUL MATCH.  THE SYNTAX POINTER WAS UPDATED
;               TO THE FIRST CHARACTER FOLLOWING THE COMMAND
;               DELIMITER.  ACCA HOLDS THE NUMBER OF THE
;               COMMAND MATCHED.
;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
;SYNPTR - GOOD SYNTAX INPUT CHAR LINE POINTER
;LINPTR - INPUT LINE CHARACTER POINTER
;DELIM - CLASS OF PERMISSIBLE COMMAND DELIMITERS

;TEMPORARY 2 BYTE INTERNAL VARIABLES
;LISPTR - COMMAND LIST CHARACTER POINTER

;TEMPORARY 1 BYTE INTERNAL VARIABLES
;NUMMAT - NUMBER OF CHARACTERS THAT SUCCESSFULLY MATCH
;LISNUM - # OF LIST WITHIN WHICH A MATCH WILL BE SOUGHT
;COMNUM - COMMAND NUMBER MATCHED

;CONSTANTS USED
;CR - CARRIAGE RETURN
;LF - LINE FEED

;ACCB & IX ARE NOT PRESERVED.

COMAND STA    LISNUM   ;SAVE LIST # TO MATCH WITHIN
;TEST IF WE ARE AT THE END OF THE LINE
       JSR    SKPDLM
       BCC    INILST
       CLRA
       RTS

;INITIALIZE THE COMMAND LIST POINTER TO ONE LESS THAN
;                       THE BEGINNING OF THE COMMAND LISTS
INILST LDX    COMADR   ;ENTRY POINT

;MOVE TO THE BEGINNING OF THE DESIRED COMMAND LIST
       LDA    LISNUM   ;SEARCH FOR "STRING" # LISNUM
       LDB    #LF      ;USE LF AS A "STRING" TERMINATOR
       BSR    FNDSTR
       STX    LISPTR

;THE LIST POINTER, LISPTR, NOW POINTS TO ONE LESS THAN THE FIRST CHARACTER
;OF THE FIRST COMMAND IN THE DESIRED LIST.
       CLR    COMNUM

;RESET INPUT LINE POINTER TO: 1) BEGINNING OF LINE, OR TO
;  2) POINT WHERE LAST SUCCESSFUL SCAN TERMINATED
CMD3   INC    COMNUM
       LDX    SYNPTR
       STX    LINPTR
       CLR    NUMMAT   ;CLEAR NUMBER OF CHARACTERS MATCHED

CMD4   JSR    GETCHR   ;GET INPUT LINE CHAR IN ACCB
       JSR    TSTDLM   ;TEST FOR A DELIMITER
       BNE    MATCH    ;SUCCESS (FOUND DELIMITER) IF NOT = ZERO
       JSR    GETLST   ;GET COMMAND LIST CHAR IN ACCA
       CMPA   #LF      ;HAS END OF COMMAND LIST BEEN REACHED?
       BEQ    NMATCH   ;IF SO, POTENTIAL MATCH FAILURE
       CMPA   #CR      ;HAS END OF COMMAND BEEN REACHED?
       BEQ    NMATCH   ;IF SO, POTENTIAL MATCH FAILURE

       PSHS   B        ;CBA
       CMPA   ,S+      ;COMPARE THE TWO CHARACTERS
       BNE    NEXCOM   ;MATCH NOT POSSIBLE ON THIS COMMAND

;THEY MATCH, COMPARE THE SUCCEEDING CHARACTERS
       INC    NUMMAT   ;INC NUMBER OF CHARACTERS MATCHED
       BRA    CMD4

;***
;SUCCESSFUL MATCH - RETURN COMMAND NUMBER MATCHED IN ACCA
MATCH  LDA    COMNUM
       LDX    LINPTR
       STX    SYNPTR   ;UPDATE GOOD SYNTAX POINTER
       RTS

;***
;NO MATCH
;DID AT LEAST ONE MATCH?
NMATCH TST    NUMMAT
       BEQ    NEXCOM   ;TO NEXT COMMAND IF NONE MATCHED

;AT LEAST ONE MATCHED - TEST FOR DELIMITER (NON-MATCHING CHAR)
       JSR    TSTDLM
       BNE    MATCH    ;IF A DELIMITER, MATCH HAS BEEN ACHIEVED
       LDA    ,X       ;RETRIEVE LAST CHARACTER
;
;ILLEGAL DELIMITER

;MOVE TO NEXT COMMAND WITHIN LIST
NEXCOM CMPA   #LF      ;END OF THIS LIST?
       BEQ    MFAIL    ;IF SO, NOTHING ON LIST MATCHED
       CMPA   #CR      ;IS IT A CR?
       BEQ    CMD3     ;YES, NEXT COMMAND
       JSR    GETLST   ;GET NEXT COMMAND LIST CHARACTER
       BRA    NEXCOM   ;NO, GET TO END OF COMMAND

;***
;MATCH FAILURE - NO MATCH POSSIBLE WITHIN THIS LIST
MFAIL  CLRA            ;MATCH FAILURE
       DECA            ;NO MATCH POSSIBLE WITHIN THIS LIST
       RTS

;======================================================
;THIS ROUTINE TYPES OUT COMMAND NUMBER "COMNUM"
;THE LIST IS SPECIFIED IN ACCA
;ACCB & IX ARE PRESERVED
TYPCMD STX    XTEMP
       PSHS   B
       LDX    #COMLST-1 ;MOVE TO HEAD OF COMMAND LISTS
       LDB    #LF      ;AND LIST TERMINATOR
       BSR    FNDSTR   ;GO TO HEAD OF DESIRED LIST
       LDA    COMNUM   ;GET COMMAND NUMBER
       LDB    #CR      ;GET COMMAND TERMINATOR
       BSR    FNDSTR   ;GO TO HEAD OF DESIRED COMMAND

TYPCM1 LEAX   1,X      ;MOVE TO NEXT CHARACTER
       LDA    ,X       ;GET A COMMAND CHARACTER
       CMPA   #CR      ;IS IT A COMMAND TERMINATOR?
       BEQ    TYPCM2   ;IF SO, RETURN
       JSR    OUTCHR   ;NO, TYPE IT
       BRA    TYPCM1

TYPCM2 LDX    XTEMP
       PULS   B
       RTS

;======================================================
;MOVE TO BEGINNING OF DESIRED STRING NUMBER (IN ACCA)
;EACH STRING IS TERMINATED BY AN END OF STRING CHARACTER (IN ACCB)
;THE INDEX REGISTER IS ASSUMED INITIALIZED POINTING TO
;ONE LESS THAT THE FIRST CHARACTER OF THE FIRST STRING
;ACCA, ACCB & IX ARE NOT PRESERVED
;LOCAL VARIABLES
;STRNUM - STRING # TO FIND
;EOSCHR - "END OF STRING" CHARACTER

FNDSTR STA    STRNUM   ;SAVE STRING NUMBER
       STB    EOSCHR   ;SAVE TERMINATOR
       CLRB
FNDST1 INCB            ;STRING 1 IS THE FIRST STRING
       CMPB   STRNUM   ;IS THIS THE RIGHT STRING?
       BEQ    FNDST3   ;IF SO, DONE

;NO, SWALLOW UP CHARACTERS UNTIL AND END OF STRING CHAR IS HIT
FNDST2 LEAX   1,X      ;BUMP POINTER TO NEXT ONE
       LDA    ,X       ;GET CHAR POINTED AT
       CMPA   EOSCHR   ;END OF STRING HIT?
       BEQ    FNDST1   ;IF IT IS, BUMP THE STRING COUNTER
       BRA    FNDST2   ;NO, MOVE ON TO NEXT CHAR
FNDST3 RTS             ;IX SET PROPERLY, RETURN

;======================================================
;SKIP LEADING DELIMITERS
;THIS ROUTINE SHOULD BE CALLED PRIOR TO SCANNING FOR ANY INFORMATION
;ON THE INPUT LINE
;THE CURRENT CHARACTER IS IGNORED IF THE SCANNING POINTER IS AT THE
;BEGINNING OF A LINE.  IF NOT, THE SCANNING POINTER SKIPS OVER SPACES
;AND COMMAS UNTIL AN END OF LINE OR NON-DELIMITER IS FOUND.
;THE CARRY BIT IS SET IF AN END OF LINE IS ENCOUNTERED.

;ACCA, ACCB & IX ARE NOT PRESERVED

SKPDLM ANDCC  #$FE     ;CLC
       TST    BOLFLG   ;AT BEGINNING OF LINE?
       BGT    SKPDL2

;LOOK AT CURRENT INPUT CHARACTER
SKPDL1 LDX    SYNPTR   ;GET POINTER TO IT
       LDA    ,X       ;GET CHAR
       BSR    TSTEOL   ;TEST FOR END OF LINE
       BNE    SKPDL2
       ORCC   #$01     ;SEC YES, END HIT, SET CARRY
       RTS
;"PEEK" AT NEXT CHAR IN LINE
SKPDL2 LDB    1,X     ;GET IT
       BSR    TSTDLM  ;SEE IF ITS A DELIMITER
       BNE    SKPDL3
       RTS            ;ITS NOT, RETURN

;NEXT CHAR IS A DELIMITER
SKPDL3 JSR    GETCHR   ;MOVE TO NEXT CHAR IN INPUT LINE
       STX    SYNPTR   ;UPDATE SYNTAX POINTER
       BRA    SKPDL1   ;GO TEST FOR END OF LINE

;======================================================
;TEST FOR END-OF-LINE CHARACTER
;Z BIT OF CC REG SET IF CHAR IN ACCA IS A TERMINATOR
;ACCA, ACCB, & IX ARE PRESERVED
TSTEOL CMPA   #CR      ;CARRIAGE RETURN?
       BEQ    TSTEO1
       CMPA   #LF      ;LINE FEED? (CONTINUED LINES)
       BEQ     TSTEO1
       CMPA    #';'    ;FOR SEVERAL COMMANDS ON ONE LINE
TSTEO1 RTS

;======================================================
;CHECK THE CHARACTER IN ACCB
;AGAINST THE DELIMITER(S) SPECIFIED BY VARIABLE DELIM
;ACCB & IX ARE PRESERVED
;ACCA IS SET TO 0 IF ACCB IS NOT A DELIMITER, TO 1 IF IT IS
;  IF DELIM=1, SPACE IS DELIMITER
;  IF DELIM-2, COMMA IS DELIMITER
;  IF DELIM=3, SPACE OR COMMAND IS DELIMITER
;  IF DELIM=4, ANY NON-ALPHANUMERIC IS A DELIMITER
;TEST FOR END-OF-LINE (LOGICAL OR PHYSICAL)
TSTDLM PSHS   B
       TFR    B,A
       BSR    TSTEOL
       PULS   B
       BEQ    DLMYES

       LDA    DELIM
       CMPA   #1
       BNE    ISDLM2
       CMPB   #32      ;WANT A SPACE - IS IT?
       BNE    DLMNO
       BRA    DLMYES

ISDLM2 CMPA   #2
       BNE    ISDLM3
TSTCMA CMPB   #','     ;WANT A COMMA - IS IT?
       BNE    DLMNO
       BRA    DLMYES
ISDLM3 CMPA   #3
       BNE    ISDLM4
       CMPB   #32      ;WANT EITHER, IS IT A SPACE?
       BEQ    DLMYES
       BRA    TSTCMA   ;OR A COMMA?

ISDLM4 CMPA   #4
       BNE    ERROR    ;ERROR IF DELIM NOT 1-4
;TEST IF CHAR IS 0 TO 9 INCLUSIVE
       CMPB   #'0'
       BLT    DLMYES
       CMPB   #'9'
       BLE    DLMNO

;TEST IF CHAR IS A TO 9 INCLUSIVE
       CMPB   #'A'
       BLT    DLMYES
       CMPB   #'Z'
       BLE    DLMNO
;OVER Z - ITS A DELIMITER

;CHAR IN ACCB IS A DELIMITER
DLMYES LDA    #1
       RTS

;CHAR IN ACCB IS NOT A DELIMITER
DLMNO  CLRA
       RTS

;ERROR IN SPECIFYING DELIMITER CLASS
ERROR  SWI             ;HAVE MONITOR TYPE OUT PERTINENT STATISTICS

;=====================================================
;ADD THE 2 BYE NUMBER STORED IN (RANGLO,RANGLO+1) TO THE NUMBER
;STORED IN (NBRHI,NBRLO) AND PUT THE RESULT IN (RANGHI,RANGHI+1)
;ACCB & IX ARE PRESERVED
;ACCA IS ALTERED

;ADD LO ORDER BYTES
SUMNUM LDA    RANGLO+1
       ADDA   NBRLO
       STA    RANGHI+1

;ADD HI ORDER BYTES
       LDA    RANGLO
       ADCA   NBRHI
       STA    RANGHI
       RTS

;========================================================
;SUBTRACT THE TWO BYTE NUMBER STORED IN (NBRHI,NBRLO) FROM THE
;TWO BYTE NUMBER STORED IN (RANGLO,RANGLO+1) AND PUT THE
;RESULT IN (RANGHI,RANGHI+1)
;ACCB & IX ARE PRESERVED
;ACCA IS ALTERED

;SUBTRACT LO ORDER BYTES
DIFNUM LDA    RANGLO+1
       SUBA   NBRLO
       STA    RANGHI+1

;SUBTRACT HI ORDER BYES
       LDA    RANGLO
       SBCA   NBRHI
       STA    RANGHI
       RTS

;======================================================
;THIS ROUTINE SCANS THE INPUT LINE FOR A PAIR OF NUMBERS
;REPRESENTING AN ADDRESS RANGE.  A COLON SEPARATING THE
;PAIR IMPLIES "THRU", WHILE AN "!" IMPLIED "THRU THE FOLLOWING"
;E.G., 100:105 IS EQUIVALENT TO 100!5
;A SINGLE NUMBER IMPLIES A RANGE OF 1
;
;ON RETURN (RANGLO,RANGLO+1) HOLDS THE RANGE START, AND
;          (RANGHI,RANGHI+1) HOLDS THE RANGE END.
;ACCA, ACCB, & IX ARE NOT PRESERVED

GTRANG BSR    NUMBER   ;PICK UP FIRST NUMBER
       BGT    GTRAN1
       BLT    GTRAN2
       RTS             ;NOTHING MORE ON INPUT LINE

;GOOD SINGLE NUMBER - TRANSFER IT TO RANGLO
GTRAN1 LDX    NBRHI
       STX    RANGLO
       BRA    GTRAN3   ;AND TO RANGHI

;BAD NUMBER, BUT IS IT BAD DUE TO A ":" OR "!" DELIMITER?
GTRAN2 LDX    LINPTR
       LDA    ,X
       CMPA   #':'     ;WAS IT A COLON
       BNE    GTRAN4   ;IF NOT, GO TEST FOR "!"

       BSR    GTRAN8   ;WAS ":", PROCESS NUMBER & GET NEXT ONE
       BLE    GTRAN5   ;ILLEGAL IF END OF LINE OR NON-NUMERIC

;TRANSFER SECOND NUMBER TO RANGHI
GTRAN3 LDX    NBRHI
       STX    RANGHI
       BRA    GTRAN7

GTRAN4 CMPA   #'!'     ;WAS DELIMITER A "!"?
       BEQ    GTRAN6   ;IF YES, GET 2ND NUMBER

;ILLEGAL DELIMITER, RETURN
       CLRA
       DECA
GTRAN5 RTS

GTRAN6 BSR    GTRAN8   ;WAS "!", PROCESS FIRST NUMBER & GET NEXT ONE
       BLE    GTRAN5
       BSR    SUMNUM   ;COMPUTE RANGE END, PUT INTO RANGHI

;SUCCESSFUL EXIT
GTRAN7 LDA    #1
       RTS

;UPDATE SYNTAX POINTER, MOVE FIRST NUMBER TO RANGLO, & GET 2ND NUMBER
GTRAN8 STX    SYNPTR   ;UPDATE SYNTAX POINTER
       LDX    NBRHI    ;GET FIRST NUMBER OF THE PAIR
       STX    RANGLO   ;SAVE IT IN "LOW RANGE" VALUE
       BSR    NUMBER   ;PICK UP THE SECOND NUMBER OF THE PAIR
       RTS

;======================================================
;GET A 2 BYTE NUMBER & RETURN IT IN THE INDEX REGISTER
NUMINX BSR    NUMBER
       BGT    NUMIN1
       LBRA   BADSYN
NUMIN1 LDX    NBRHI
       RTS

;======================================================
;SCAN FOR A NUMBER
;RETURN THE MOST SIGNIFICANT BYTE IN NBRHI
;  AND THE LEAST SIGNIFICANT BYTE IN NBRLO
;THE RESULT OF THE SCAN FOR A NUMBER IF RETURNED IN
;ACCA AS FOLLOWS:
;
;      ACCA=-1: THE MATCH WAS UNSUCCESSFUL.  THE SYNTAX
;               POINTER (SYNPTR) WAS NOT UPDATED.
;
;      ACCA= 0: THE MATCH WAS UNSUCCESSFUL SINCE THERE WERE NO
;               MORE CHARACTERS. (I.E., THE END OF THE
;               LINE WAS ENCOUNTERED.)
;
;      ACCA=+1: THE SCAN WAS SUCCESSFUL.  THE SYNTAX POINTER
;               WAS UPDATED TO THE FIRST CHARACTER FOLLOWING
;               THE COMMAND.

;IX IS PRESERVED
;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
;NBRHI - NUMBER HI BYTE
;NBRLO - NUMBER LO BYTE
;IBCODE - INPUT BASE CODE
;DBCODE - DISPLAY BASE CODE

;LOCAL VARIABLES
;NBR2X - USED IN DECIMAL CONVERSION
;XTEMP2 - SAVES IX

;INITIALIZE BOTH BYTES TO ZERO
NUMBER STX    XTEMP2   ;SAVE IX
       CLR    NBRHI
       CLR    NBRLO

;INITIALIZE THE LINE SCANNING POINTER
       LDX    SYNPTR
       STX    LINPTR

;ARE WE AT END OF LINE?
       JSR    SKPDLM
       BCC    NUMLUP
       LDX    XTEMP2
       CLRA            ;YES, ZERO ACCA
       RTS

NUMLUP JSR    GETCHR   ;GET A CHARACTER FROM THE INPUT LINE INTO ACCB

;TEST FOR A DELIMITER
       JSR    TSTDLM
       BNE    GUDNUM   ;GOOD DELIMITER IF ACCA NON-ZERO

;NOT A DELIMITER, TEST IF CHARACTER IS < ASCII 0
       SUBB   #'0'     ;SUBTRACT ASCII 0
       BMI    CONERR   ;ERROR IF LESS

;DETERMINE INPUT BASE & GO TO RIGHT ROUTINE
       LDA    IBCODE
       CMPA   #1
       BEQ    HEXNUM

       CMPA   #2
       BEQ    DECNUM

       CMPA   #3
       BEQ    OCTNUM

;DEFAULT AN ILLEGAL INPUT BASE TO HEX
;*****
;INPUT A HEX NUMBER
;TEST FOR A LEGAL DIGIT
HEXNUM CMPB   #$09
       BLE    HEXN1    ;OR IF 9 OR LESS
       CMPB   #$11
       BMI    CONERR    ;NOT HEX IF < A
       CMPB   #$16
       BGT    CONERR    ;NOT HEX IF > F
       SUBB   #7        ;MOVE A-F ABOVE 0-9

;SHIFT LO & HI BYTES LEFT 4 BITS
HEXN1  BSR    SHIFT2
       BSR    SHIFT2

       ORB    NBRLO
       STB    NBRLO

       BRA    NUMLUP

;*****
;INPUT A DECIMAL NUMBER
;TEST FOR A LEGAL DIGIT
DECNUM CMPB   #$09
       BGT    CONERR   ;NOT DECIMAL IF > 9

;MULTIPLE SAVED VALUE BY 10 & ADD IN NEW DIGIT
;NOTE THAT 10X=2X+8x
;MULTIPLY CURRENT NUMBER BY 2 TO GET 2X VALUE
       BSR    SHIFT
;SAVE THIS *2 NUMBER TEMPORARILY
       LDX    NBRHI
       STX    NBR2X
;MULTIPLY THIS # BY 4 TO GET 8X VALUE
       BSR    SHIFT2
;(NBRHI,NBRLO) NOW HOLDS *8
;GENERATE DIGIT+8x+2x
       CLRA            ;ACCA WILL HOLD MS BYTE
       ADDB   NBR2X+1  ;ADD 2X LS BYTE TO DIGIT
       ADCA   NBR2X    ;ADD 2X MS BYTE
       BCS    CONERR   ;CARRY OUT OF MS BYTE IS AN ERROR
       ADDB   NBRLO    ;ADD 8X LS BYTE
       ADCA   NBRHI    ;ADD 8X MS BYTE
       BCS    CONERR   ;CARRY OUT OF MS BYTE IS AN ERROR
       STB    NBRLO    ;SAVE FINAL LS BYTE
       STA    NBRHI    ;SAVE FINAL MS BYTE

       BRA    NUMLUP
;*****
;INPUT AN OCTAL NUMBER
OCTNUM CMPB   #$07
       BGT    CONERR   ;NOT OCTAL IF > 7

;SHIFT HI & LO BYTES 2 PLACES LEFT - CARRY OUT OF HI BYTE IS ILLEGAL
       BSR    SHIFT2
       BSR    SHIFT

       ORB    NBRLO    ;ADD IN NEW DIGIT
       STB    NBRLO

       BRA    NUMLUP

;*****
;GOOD NUMBER - SCAN WAS SUCCESSFUL
;UPDATE GOOD SYNTAX LINE POINTER
GUDNUM LDX    LINPTR
       STX    SYNPTR
       LDX    XTEMP2
       LDA    #1       ;SET "GOOD SCAN" FLAG
       RTS

;*****
;CONVERSION ERROR - SCAN WAS UNSUCCESSFUL
CONERR LDX    XTEMP2
       CLRA
       DECA
       RTS
;----------------------------------
;SHIFT LEFT 2 POSITIONS
SHIFT2 BSR    SHIFT
       BSR    SHIFT
       RTS
;----------------------------------
;SHIFT A TWO BYTE NUMBER LEFT ONE POSITION
SHIFT  ASL    NBRLO
       ROL    NBRHI
       BCS    SHFTER
       RTS
;ERROR - HI ORDER BYTE OVERFLOW
;ABORT NUMBER ROUTINE DIRECTLY THRU STACK ADJ. & A JUMP
SHFTER LEAS   2,S
       BRA    CONERR

;======================================================
;OUTPUT A SPACE
OUTSP  LDA    #$20
       JSR    OUTCHR
       RTS

;======================================================
;OUTPUT AN "=" SIGN
OUTEQ  LDA    #'='
       JSR    OUTCHR
       RTS

;======================================================
;OUTPUT A 1 BYTE NUMBER
;ACCA, ACCB, & IX ARE PRESERVED
OUT1BY PSHS   B
       LDB    #1
       BSR    OUTNUM
       PULS   B
       RTS

;======================================================
;OUTPUT A 2 BYTE NUMBER
;ACCA, ACCB, & IX ARE PRESERVED
OUT2BY PSHS   B
       LDB    #2
       BSR    OUTNUM
       PULS   B
       RTS

;======================================================
;DISPLAY THE NUMBER POINTED AT BY THE ADDRESS IN THE INDEX REGISTER
;AND OUTPUT IT ACCORDING TO THE BASE SPECIFIED IN "DBCODE"
;LEADING ZEROES ARE INCLUDED
;ACCA & IX ARE PRESERVED
;ACCB IS INPUT AS THE NUMBER OF BYTES COMPRISING THE NUMBER
;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
;IBCODE - INPUT BASE CODE
;DBCODE - DISPLAY BASE CODE

;LOCAL VARIABLES
;DECDIG - DECIMAL DIGIT BEING BUILT
;NUMBHI - HI BYTE OF NUMBER BEING OUTPUT
;NUMBLO - LO BYTE OF NUMBER BEING OUTPUT

OUTNUM STX    XTEMP1
       PSHS   A
       LDX    ,X       ;GET THE TO BYTES AT THAT ADDRESS
       STX    NUMBHI   ;PUT THEM IN A SCRATCH AREA FOR PROCESSING
       LDA    DBCODE   ;GET DISPLAY BASE

       CMPA   #1
       BEQ    OUTHEX
       CMPA   #2
       BEQ    OUTDEC
       CMPA   #3
       BEQ    OUTOCT
       CMPA   #4
       BEQ    OUTBIN

;*****
;OUTPUT A HEX NUMBER
OUTHEX ASLB            ;1 BYTE=2 CHARS, 2 BYTES=4 CHARS
;GET NEXT 4 BITS
DISNU1 JSR    LSH2
       JSR    LSH2

       ANDA   #$F      ;EXTRACT 4 BITS
       CMPA   #9
       BLE    DISNU2
       ADDA   #7       ;CONVERT 10:15 TO A:F

DISNU2 BSR    OUTIT
       DECB
       BNE    DISNU1
       BRA    OUTDE5

;*****
;OUTPUT A DECIMAL NUMBER
OUTDEC DECB            ;TEST # OF BYTES TO OUTPUT
       BEQ    OUTDE1
;INITIALIZE FOR OUTPUT OF A 2 BYTE NUMBER
       LDX    #C10K
       LDA    NUMBHI
       LDB    NUMBLO
       BRA    OUTDE2

;INITIALIZE FOR OUTPUT OF A 1 BYTE NUMBER
OUTDE1 LDX    #C100
       CLRA
       LDB    NUMBHI

OUTDE2 CLR    DECDIG   ;CLEAR THE DIGIT TO OUTPUT

;SUBTRACT THE POWER OF 10 CONVERSION CONSTANT
OUTDE3 SUBB   1,X
       SBCA   0,X
       BCS    OUTDE4   ;TEST FOR BORROW (CARRY)

       INC    DECDIG   ;NO BORROW YET - INC DIGIT BEING BUILT
       BRA    OUTDE3   ;REPEAT LOOP
;BORROW GENERATED - CANCEL LAST SUBTRACTION
OUTDE4 ADDB   1,X
       ADCA   0,X

;BUILDING OF DIGIT TO OUTPUT COMPLETE - PRINT IT
       PSHS   A        ;SAVE LO BYTE OF NUMBER BEING OUTPUT
       LDA    DECDIG   ;GET DIGIT
       BSR    OUTIT    ;PRINT IT
       PULS   A        ;RESTORE LO BYTE
;GET NEXT LOWER POWER OF 10
       LEAX   2,X
       CPX    #C10K+10 ;ARE WE THRU WITH UNITS CONVERSION?
       BNE    OUTDE2   ;IF NOT, BACK TO GET NEXT DIGIT
OUTDE5 PULS   A        ;IF YES, RESTORE REGISTERS & RETURN
       LDX    XTEMP1
       RTS

;DECIMAL OUTPUT CONVERSION CONSTANTS
C10K   FDB    10000
       FDB    1000
C100   FDB    100
       FDB    10
       FDB    1

;*****
;OUTPUT AN OCTAL NUMBER
;FIRST DIGIT IS A ONE OR A ZERO
OUTOCT ASLB            ;FIRST APPROXIMATION OF # OF DIGITS TO OUTPUT
       CLRA
       CMPB   #2
       BGT    OUTOC1
       BSR    LSH2     ;1 BYTE - GET FIRST 2 BITS
       BSR    OUTIT
       BRA    DISNU3   ;GO OUTPUT LAST 2 DIGITS
;TWO BYTE # - OUTPUT HI ORDER BIT/DIGIT
OUTOC1 BSR    LEFSHF
       BSR    OUTIT
       INCB           ;5 MORE DIGITS TO GO
;GET NEXT 3 BITS
DISNU3 BSR    LSH2
       BSR    LEFSHF

       ANDA   #7      ;EXTRACT 3 BITS
       BSR    OUTIT
       DECB           ;COUNT THIS DIGIT
       BNE    DISNU3  ;ARE WE DONE?
       BRA    OUTDE5  ;YES
;*****
;OUTPUT A BINARY NUMBER
OUTBIN ASLB
       ASLB
       ASLB
;GET NEXT BIT
DISNU4 BSR    LEFSHF
       ANDA   #1       ;EXTRACT THE BIT

       BSR    OUTIT    ;OUTPUT IT
       DECB            ;COUNT IT
       BNE    DISNU4   ;ARE WE DONE?
       BRA    OUTDE5   ;YES

;**
;CONVERT TO A NUMERIC ASCII DIGIT & OUTPUT IT
OUTIT  ADDA   #$30
       JSR    OUTCHR
       RTS
;**
;LEFT SHIFT 2 BITS
LSH2   BSR    LEFSHF
       BSR    LEFSHF
       RTS

;**
;LEFT SHIFT THE 3 BYTE NUMBER 1 BIT
LEFSHF ASL    NUMBLO
       ROL    NUMBHI
       ROLA
       RTS

;======================================================
;THIS ROUTINE GETS THE NEXT CHARACTER FROM THE INPUT LINE BUFFER
;ACCA IS PRESERVED
;ACCB IS LOADED WITH THE CHARACTER
;IX IS INCREMENTED & LEFT POINTING TO THE CHARACTER RETURNED
GETCHR LDX    LINPTR
       LEAX   1,X
       LDB    ,X
       STX    LINPTR
       CLR    BOLFLG   ;SET FLAG TO NOT AT "BEGINNING OF LINE"
       RTS

;======================================================
;THIS ROUTINE GETS THE NEXT CHARACTER IN THE COMMAND LISTS
;ACCA IS THE CHARACTER RETRIEVED
;ACCB IS PRESERVED
;IX IS INCREMENTED & LEFT POINTING TO THE CHARACTER RETURNED
GETLST LDX    LISPTR   ;GET CURRENT LIST POINTER
       LEAX   1,X      ;MOVE POINTER TO NEXT CHAR
       LDA    ,X       ;GET CHARACTER POINTED AT
       STX    LISPTR   ;SAVE POINTER
       RTS             ;AND RETURN

;======================================================
; COMMAND LISTS
;  A CARRIAGE RETURN SIGNIFIES END-OF-COMMAND
;  A LINE FEED SIGNIFIES END-OF-COMMAND-LST
;LIST 1 - MAJOR COMMANDS
COMLST EQU    *
       FCC    "REG"    ; DISPLAY REGISTERS
       FCB    CR
       FCC    "GOTO"   ;GO TO MEMORY ADDRESS
       FCB    CR
       FCC    "SEI"    ;SET INTERRUPT MASK
       FCB    CR
       FCC    "CLI"    ; CLEAR INTERRUPT MAST
       FCB    CR
       FCC    "COPY"   ;COPY FROM ONE LOCATION TO ANOTHER
       FCB    CR
       FCC    "BREAK"  ;SET BREAKPOINT (SWI CODE)
       FCB    CR
       FCC    "IBASE"  ;SET INPUT BASE
       FCB    CR
       FCC    "DBASE"  ;SET DISPLAY BASE
       FCB    CR
       FCC    "CONTINUE" ;CONTINUE FROM "SWI"
       FCB    CR
       FCC    "DISPLAY" ;DISPLAY MEMORY DATA
       FCB    CR
       FCC    "SET"    ;SET MEMORY DATA
       FCB    CR
       FCC    "VERIFY" ;VERIFY THAT MEMORY CONTENT IS UNCHANGED
       FCB    CR
       FCC    "SEARCH" ;SEARCH MEMORY FOR A BYTE STRING
       FCB    CR
       FCC    "TEST"   ;TEST A RANGE OF MEMORY
       FCB    CR
       FCC    "INT"    ;SET INTERRUPT POINTER
       FCB    CR
       FCC    "NMI"    ;SET NON-MASKABLE INTERRUPT POINTER
       FCB    CR
       FCC    "SWI"    ;SET SOFTWARE INTERRUPT POINTER
       FCB    CR
       FCC    "COMPARE" ;PRINT SUM & DIFFERENCE OF 2 NUMBERS
       FCB    CR
       FCC    "DUMP"   ;DUMP MEMORY IN MIKBUG OR IMAGE FORMAT
       FCB    CR
       FCC    "LOAD"   ;LOAD MIKBUG TAPE
       FCB    CR
       FCC    "DELAY"  ;DELAY SPECIFIED # OF MSECS
       FCB    CR
       FCC    "HELP"   ;HELP LISTING
       FCB    CR
       FCC    "CLF"    ;CLEAR FAST INTERRUPT MASK
       FCB    CR
       FCC    "SEF"    ;SET FAST INTERRUPT MASK
       FCB    CR
       FCC    "FIRQ"   ;SET FAST INTERRUPT POINTER
       FCB    CR
       FCC    "RSRVD"  ;SET RESERVED INTERRUPT POINTER
       FCB    CR
       FCC    "SWI2"   ;SET SWI2 INTERRUPT POINTER
       FCB    CR
       FCC    "SWI3"   ;SET SWI3 INTERRUPT POINTER
       FCB    CR
       FCB    LF       ;END OF LIST 1

;LIST 2 - MODIFIER TO DUMP
       FCC    "TO"     ;DESTINATION ACIA
       FCB    CR
       FCB    LF       ;END OF LIST 2

;LIST 3 - NUMBER BASE SPECIFIERS
       FCC    "HEX"    ;BASE 16
       FCB    CR
       FCC    "DEC"    ;BASE 10
       FCB    CR
       FCC    "OCT"    ;BASE 8
       FCB    CR
       FCC    "BIN"    ;BASE 2
       FCB    CR
       FCB    LF       ;END OF LIST 3

;LIST 4 - INFORMATION REQUEST
       FCC    "?"
       FCB    CR
       FCB    LF       ; END OF LIST 4

;LIST 5 - REGISTER NAMES
       FCC    ".CC"
       FCB    CR
       FCC    ".A"
       FCB    CR
       FCC    ".B"
       FCB    CR
       FCC    ".DP"
       FCB    CR
       FCC    ".X"
       FCB    CR
       FCC    ".Y"
       FCB    CR
       FCC    ".U"
       FCB    CR
       FCC    ".PC"
       FCB    CR
       FCC    ".S"
       FCB    CR
       FCB    LF       ;END OF LIST 5

;LIST 6 - MODIFIERS TO "DISPLAY"
       FCC    "DATA"
       FCB    CR
       FCC    "USED"
       FCB    CR
       FCB    LF       ;END OF LIST 6

;LIST 7 - MODIFIER TO "LOAD"
       FCC    "FROM"   ;SOURCE ACIA
       FCB    CR
       FCB    LF       ;END OF LIST 7

;======================================================

; THIS ROUTINE CONSTRUCTS A LINE OF INPUT BY GETTING ALL INPUT
; CHARACTERS UP TO AND INCLUDING A CARRIAGE RETURN (WHICH THEN
; DESIGNATES "END OF LINE").
; TYPING RUBOUT WILL DELETE THE PREVIOUS CHARACTER
; TYPING CONTROL-C WILL ABORT THE LINE
; TYPING CONTROL-Z WILL USE THE PREVIOUS LINE
; THE INPUT LINE IS STORED BEGINNING AT THE ADDRESS STORED IN BUFBEG
; AND ENDING AT THE ADDRESS STORED IN BUFEND
;ACCA, ACCB, & IX ARE NOT PRESERVED
;
;GLOBAL VARIABLES
;BUFBEG - INPUT LINE START OF BUFFER
;BUFEND - INPUT LINE END OF BUFFER

;LOCAL CONSTANTS
BAKSLA EQU    92       ;A BACKSLASH
DELETE EQU    8        ;CODE TO DELETE THE PREVIOUS CHARACTER (BACKSPACE)
;
;
;*** ROUTINE ENTRY POINT

GETLIN LDX    BUFBEG   ;SET POINTER TO ONE LESS THAN THE BEGINNING OF THE LINE BUFFER
       CLRB            ;ACCB HOLS THE LAST INPUT CHAR

NXTCHR CPX    BUFEND   ;CHECK CURRENT LINE END AGAINST BUFFER END
       BNE    GETIT

;LINE TOO LONG - ABORT IT AS IF A CONTROL-C HAD BEEN TYPED
       LDX    #MSGLTL  ;GET MESSAGE
       JSR    OUTSTR   ;OUTPUT IT
       LDB    #3       ;PUT CTL-C IN ACCB
       RTS

GETIT  JSR    INPCHR   ;GET A CHARACTER (RETURNED IN ACCA)
       ANDA   #127     ;DROP PARITY BIT

;CONTROL-Z COPIES FROM PRESENT POSITION TO PREVIOUS END OF LINE
       CMPA   #26      ;IS CHAR A CONTROL-A?
       BNE    TSTCR
       JSR    DOCRLF   ;YES, TYPE CR-LF
       RTS
TSTCR  CMPA   #13      ;IS CHAR A CR?
       BEQ    TSTCR1
       CMPA   #10      ;OR A LF?
       BNE    NOTEOL
TSTCR1 LEAX   1,X
       STA    ,X       ;YES, STORE THE TERMINATOR
       TST    HDXFLG   ;TEST FOR HALF-DUPLEX TERMINAL
       BNE    TSTCR2
       JSR    DOCRLF   ;TYPE CR-LF
TSTCR2 RTS             ;NOW RETURN

NOTEOL CMPA   #3       ;IS CHAR A CONTROL-C?
       BNE    NOTCTC
;ECHO AN UP-ARROW
       TFR    A,B      ;RETURN CONTROL-C IN ACCB
       LDA    #'^'
       JSR    OUTCHR
       RTS

NOTCTC CMPA   #DELETE  ;NO, IS IT DELETE
       BEQ    RUBNOW   ;IF YES, GO TO RUBNOW

;CONVERT LOWER CASE TO UPPER CASE
       CMPA   #$60     ;BELOW L.C. A?
       BLS    STORIT
       CMPA   #$7A     ;ABOVE L.C. Z?
       BHI    STORIT
       SUBA   #32      ;CONVERT L.C. ALPHABETIC TO U.C.

STORIT LEAX   1,X      ;NOT A DELETE, SO ADVANCE TO NEXT CHARACTER
       STA    ,X       ;STORE IT IN INPLIN

       CMPB   #DELETE  ;IS LAST CHAR A DELETE?
       BEQ    OUTBAK   ;IF SO. GO TO OUTBAK
       TFR    A,B      ;ITS NOT, UPDATE LAST CHAR
       BRA    ECHO     ;GO ECHO IT

;LAST CHAR WAS A DELETE, BUT THIS ONE ISN'T
OUTBAK TFR    A,B      ;UPDATE LAST CHAR
       LDA    #BAKSLA  ;PRINT A -
       JSR    OUTCHR   ;BACKSLASH
       TFR    B,A      ;RESTORE CURRENT CHAR FOR ECHO
ECHO   TST    HDXFLG   ;TEST FOR HALF DUPLEX TERMINAL
       BNE    ECHO1
       JSR    OUTCHR   ;NOW ECHO IT
ECHO1  BRA    NXTCHR   ;GET ANOTHER
;
; CURRENT CHARACTER IS A DELETE
; TEST LINE LENGTH - IT ITS ZERO, IGNORE THIS DELETE SINCE
; WE CAN'T DELETE PRIOR TO FIRST CHARACTER IN INPUT LINE
RUBNOW CPX    BUFBEG
       BEQ    NXTCHR
       CMPB   #DELETE  ;WAS LAST CHAR A DELETE?
       BEQ    LASWAS

;LAST CHAR WASN'T A DELETE
      TFR     A,B      ;UPDATE LAST CHAR (WITH A DELETE)
      LDA     #BAKSLA  ;PRINT A -
      JSR     OUTCHR   ;BACKSLASH
;LAST CHAR WAS A DELETE
LASWAS LDA    ,X       ;GET THE CHAR TO BE DELETED
       LEAX   -1,X     ;DECREMENT LINE POINTER
       BRA    ECHO     ;ECHO DELETED CHARACTER

;======================================================
;INITIALIZATION ROUTINE
;DISABLE INTERRUPTS
       ORCC   #$10     ;SEI
INITAL LDA    #1
       STA    IBCODE   ;SET INPUT BASE TO HEX
       STA    DBCODE   ;SET DISPLAY BASE TO HEX
;SET UP DISPLAY BASE NUMBER
       LDA    #16
       STA    DBNBR
;MAX # OF CHARACTERS PER LINE
       LDA    #72
       STA    CPLMAX
       CLR    INPFLG   ;DEFAULT INPUT FROM THE TERMINAL
       CLR    OUTFLG   ;DEFAULT OUTPUT TO THE TERMINAL
       CLR    HDXFLG   ;CLEAR HALF-DUPLEX FLAG
;INITIALIZE ACIA1 & ACIA2 TO 8 BITS AND NO PARITY
;RESET BOTH
       LDA    #3
       STA    ACIA1-1
       STA    ACIA2-1
;SET EM UP
       LDA    #$15
       STA    ACIA1-1
       STA    ACIA2-1
;SET UP SWI INTERRUPT ADDRESS POINTER
       LDX    #TYPSWI  ;TYPE "SWI" & DO "REG" COMMAND
       STX    SWIVEC
;INITIALIZE TO MONDEB'S COMMAND LISTS
       LDX    #COMLST-1
       STX    COMADR
;TIME CONSTANT FOR A 2 MICROSECOND CLOCK
       LDA    #256
       STA    TIMCON
       RTS

;======================================================
;OUTPUT A CHARACTER STRING WHICH BEGINS AT THE ADDRESS IN THE INDEX REGISTER
;ACCA & ACCB ARE PRESERVED
;IX IS LEFT POINTING TO THE STRING TERMINATOR
OUTSTR PSHS   A
OUTST1 LDA    ,X       ;GET CHAR POINTED TO
       CMPA   #4       ;IS IT A STRING TERMINATOR?
       BEQ    OUTEND   ;DONE IF IT IS
       BSR    OUTCHR   ;ISN'T, OUTPUT IT
       LEAX   1,X      ;ON TO NEXT CHARACTER
       BRA    OUTST1
OUTEND PULS   A
       RTS             ;RETURN

;======================================================
;INPUT A CHARACTER FROM AN ACIA TO ACCA
;IF INPFLG = 0, INPUT IS FROM TERMINAL ACIA
;IF INPFLG = 0, INPUT IS FROM ANY ACIA
;ACCB & IX ARE PRESERVED

INPCHR STX    XTEMP    ;SAVE IX
       TST    INPFLG   ;TEST INPUT SOURCE FLAG
       BNE    INPCH1
;INPFLG=0: INPUT FROM TERMINAL ACIA
       LDX    #ACIA1
       BRA    INPCH2
;INPFLG=1: INPUT FROM ANY ACIA
INPCH1 LDX    INPADR   ;GET ITS ADDRESS
INPCH2 LEAX   -1,X     ;POINT TO CONTROL REG
INPCH3 LDA    ,X       ;GET ACIA STATUS BYTE
       BITA   #1       ;CHAR WAITING?
       BEQ    INPCH3   ;IF NOT, TRY AGAIN
       LDA    1,X      ;YES, GET IT
       LDX    XTEMP    ;RESTORE IX
       RTS

;======================================================
;OUTPUT THE CHARACTER IN ACCA TO THE DESIRED OUTPUT DEVICE/LOCATION
; IF OUTFLG = 0, OUTPUT IS TO TERMINAL
; IF OUTFLG = 1, OUTPUT IS TO ACIA ADDRESS STORED IN OUTADR
; IF OUTFLG = 2, OUTPUT IS TO ADDRESS IN OUTADR & THIS ADDR IS THEN INCREMENTED
;ACCA, ACCB, & IX ARE PRESERVED
OUTCHR PSHS   B        ;SAVE ACCB
       TST    OUTFLG   ;TEST OUTPUT DESTINATION FLAG
       BEQ    OUTCH4   ;SKIP THIS CODE IF TERMINAL OUTPUT

;OUTPUT TO SOMETHING OTHER THAN THE TERMINAL
      STX     XTEMP    ;SAVE IX
      LDX     OUTADR   ;GET OUTPUT CHAR DESTINATION ADDRESS
      LDB     #2
      CMPB    OUTFLG
      BEQ     OUTCH2

;OUTFLG = 1: ANY ACIA OUTPUT
       LEAX   -1,X     ;POINT TO ACIA STATUS REG
OUTCH1 BITB   ,X       ;TEST TDRE BIT
       BEQ    OUTCH1   ;LOOP IF NOT READY TO ACCEPT A NEW CHAR
       STA    1,X      ;NOW READY - SEND IT
       BRA    OUTCH3

;OUTCLF = 2: MEMORY OUTPUT
OUTCH2 STA    ,X       ;SAVE CHAR IN MEMORY
       LEAX   1,X
       STX    OUTADR   ; UPDATE OUTPUT ADDRESS

OUTCH3 LDX    XTEMP    ;RESTORE IX
       PULS   B        ;RESTORE ACCB
       RTS

;OUTFLG = 0: TERMINAL ACIA OUTPUT
;IGNORE LINE FEEDS
OUTCH4 CMPA   #LF
       BNE    OUTCH5
       PULS   B
       RTS

OUTCH5 CMPA   #CR      ;TEST FOR CARRIAGE RETURN
       BNE    OUTCH6
       BSR    DOCRLF
       PULS   B
       RTS

OUTCH6 LDB    CPLCNT   ;GET "CHARACTERS PER LINE" COUNT
       CMPB   CPLMAX   ;COMPARE TO MAX PERMISSIBLE
       BGE    OUTCH7   ;SEND CR-LF IF GREATER
;LESS THAN MAX, BUT ALSO SEND CR-LF IF 10 FROM END AND PRINTING A SPACE
       ADDB   #10
       CMPB   CPLMAX
       BLT    OUTCH8
       CMPA   #$20     ;NEAR END, TEST IF ABOUT TO PRINT A SPACE
       BNE    OUTCH8

;TERMINAL LINE FULL OR NEARLY FULL - INTERJECT A CR-LF
OUTCH7 BSR    DOCRLF
OUTCH8 INC    CPLCNT   ;BUMP COUNTER
       BSR    TOACIA   ;SEND IT TO ACIA1
       PULS   B
       RTS

;======================================================
;SEND A CARRIAGE RETURN-LINE FEED TO THE TERMINAL
;ACCA, ACCB, & IX ARE PRESERVED
DOCRLF PSHS   A
       PSHS   B
       LDA    #CR
       BSR    TOACIA
       LDA    #LF
       BSR    TOACIA
       CLR    CPLCNT   ;ZERO "CHARACTERS PER LINE" COUNT
       PULS   B
       PULS   A
       RTS

;======================================================
;PUT CHAR IN ACCA INTO TERMINAL ACIA
;ACCA, ACCB, & IX ARE PRESERVED
TOACIA PSHS   A        ;SAVE CHAR
       LDA    #2       ;GET ACIA TRANSMIT REG STATUS BIT
TOACI1 BITA   ACIA1-1  ;REGISTER EMPTY?
       BEQ    TOACI1   ;IF NOT, LOOP BACK
       PULS   A        ;YES, RESTORE CHARACTER
       STA    ACIA1    ;SEND IT
       RTS

;======================================================
;MISC TEST
MSGHED FCC    "MONDEB 6809 1.01 10-Mar-2019" ;MONITOR HEADER TYPEOUT
       FCB    CR,4

MSGPRM FCC   "*"        ;PROMPT STRING
       FCB    4

MSGSWI FCB    CR
       FCC    "SWI:"
       FCB    4

MSGLTL FCC    "TOO LONG" ; TYPED IF INPUT LINE IS TOO LONG
       FCB    4

MSGNBR FCC    "NOT SET" ; BREAK NOT SET
       FCB    4

MSGBAT FCC    "SET @ " ; BREAK AT -
       FCB    4

MSGVER FCC    "OK"     ;CHECKSUM VERIFIES
       FCB    4

MSGNVE FCC    "CHECKSUM ERROR " ; FOR VERIFY & LOAD COMMANDS
       FCB    4

MSGCCL FCC    "CAN'T CLEAR" ; TEST COMMAND
       FCB    4

MSGCSO FCC    "CAN'T SET TO ONES" ; TEST COMMAND
       FCB    4

MSGSIS FCC    "SUM IS " ; COMPARE COMMAND
       FCB    4

MSGDIS FCC    ", DIFF IS " ; COMPARE COMMAND
       FCB    4

MSGS0  FCB    CR,LF
       FCC    "S00600004844521B"
       FCB    4

MSGS1  FCB    CR,LF
       FCC    "S1"
       FCB    4

MSGS9  FCB    CR,LF
       FCC    "S9030000FC"
       FCB    CR,LF,4

MSGCNH FCC    "CHAR NOT HEX" ;USE IN LOAD COMMAND
       FCB    CR,4

;======================================================
;INTERRUPT HANDLING CODE
INTADR JMP    [INTVEC]

;*****
FIRQADR JMP   [FIRQVC]

;*****
NMIADR JMP    [NMIVEC]

;*****
RSRVDADR JMP  [RSRVDVC]

;*****
RESADR LBRA   START

;*****
SWIADR STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
       JMP    [SWIVEC]

;*****
SWI2ADR
       STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
       JMP    [SWI2VC]

;*****
SWI3ADR
       STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
       JMP    [SWI3VC]

;*****
; Comment out the next two lines if running from RAM.
       FILL   $FF, $FFB1-*
       ORG    $FFB1    ;CALCULATED SO INTERRUPT VECTORS BELOW ARE AT CORRECT ADDRESSES
;**************************************************

       LBRA   TIMDEL   ;TIME DELAY FOR # OF MS SPECIFIED BY IX
       LBRA   CKSUM    ;RETURN CHECKSUM OF AN ADDRESS RANGE IN ACCA
       LBRA   GETCHR   ;RETURN (IN ACCB) CHAR POINTED TO BY LINPTR
       LBRA   GETLST   ;RETURN (IN ACCA) CHAR POINTED TO BY LISPTR
       LBRA   GTRANG   ;PICK UP AN ADDRESS RANGE IN RANGLO & RANGHI
       LBRA   NUMBER   ;PICK UP A NUMBER & RETURN IT IN NBRHI & NBRLO
       LBRA   SKPDLM   ;SKIP OVER INPUT LINE DELIMITERS
       LBRA   TSTDLM   ;TEST CHAR IN ACCB FOR A DELIMITER
       LBRA   TSTEOL   ;TEST CHAR IN ACCA FOR END-OF-LINE
       LBRA   COMAND   ;SEARCH SPECIFIED COMMAND LIST FOR A COMMAND
       LBRA   TYPCMD   ;TYPES OUT COMMAND NUMBER "COMNUM" IN LIST ACCA
       LBRA   OUT1BY   ;DISPLAY THE 1 BYTE NUMBER POINTED AT BY IX
       LBRA   OUT2BY   ;DISPLAY THE 2 BYTE NUMBER POINTED AT BY IX
       LBRA   GETLIN   ;GET A LINE OF INPUT INTO THE TTY BUFFER
       LBRA   OUTSTR   ;OUTPUT CHAR STRING IX POINTS TO
       LBRA   DOCRLF   ;SEND CR-LF WITH DELAY & ZERO LINE COUNT
       LBRA   OUTCHR   ;LIKE TOACIA, BUT WITH FOLDING, CR DELAY, & LF INSERTION
       LBRA   TOACIA   ;SEND ACCA TO ACIA1
       LBRA   INPCHR   ;GET A CHAR FROM AN ACIA & RETURN IT IN ACCA
       LBRA   PROMPT   ;TO PROMPT FOR A NEW COMMAND
       LBRA   START    ;START OF MONDEB
;**************************************************
;INTERRUPT VECTORS
       FDB   RSRVDADR  ;RESERVED INTERRUPT
       FDB   SWI3ADR   ;SWI3 INTERRUPT
       FDB   SWI2ADR   ;SWI2 INTERRUPT
       FDB   FIRQADR   ;FAST INTERRUPT
       FDB   INTADR    ;REGULAR INTERRUPT
       FDB   SWIADR    ;SOFTWARE INTERRUPT
       FDB   NMIADR    ;NON-MASKABLE INTERRUPT
       FDB   RESADR    ;RESET INTERRUPT

;**************************************************
;VARIABLES FOR INTER-ROUTINE COMMUNICATION
       ORG    $7F00
INTVEC RMB    2        ;INTERRUPT ADDRESS POINTER
FIRQVC RMB    2        ;FAST INTERRUPT ADDRESS POINTER
NMIVEC RMB    2        ;NON-MASKABLE INTERRUPT ADDRESS POINTER
RSRVDVC RMB   2        ;RESERVED INTERRUPT ADDRESS POINTER
SWIVEC RMB    2        ;SOFTWARE INTERRUPT ADDRESS POINTER
SWI2VC RMB    2        ;SOFTWARE INTERRUPT2 ADDRESS POINTER
SWI3VC RMB    2        ;SOFTWARE INTERRUPT3 ADDRESS POINTER
SP     RMB    2        ;SAVED STACK POINTER
COMADR RMB    2        ;ADDRESS OF BEGINNING OF COMMAND LISTS FOR COMMAND
SYNPTR RMB    2        ;INPUT LINE CHARACTER POINTER FOR GOOD SYNTAX
LINPTR RMB    2        ;INPUT LINE CHARACTER POINTER (CONTENT = OR > CONTENT OF SYNPTR)
BOLFLG RMB    1        ;"BEGINNING OF LINE" FLAG
DELIM  RMB    1        ;CHARACTER(S) PERMITTED AS VALID COMMAND/MODIFIER DELIMITER
IBCODE RMB    1        ;INPUT BASE (1=HEX, 2=DEC, 3=OCT)
DBCODE RMB    1        ;DISPLAY BASE (1=HEX, 2=DEC, 3=OCT, 4=BIN)
DBNBR  RMB    1        ;DISPLAY BASE NUMBER (E.G., 16,10M8M OR 2)

NBRHI  RMB    1        ;MOST SIGNIFICANT BYTE OF SCANNED NUMBER
NBRLO  RMB    1        ;LEAST SIGNIFICANT BYTE OF SCANNED NUMBER

RANGLO RMB    2        ;RANGE LOWER LIMIT PICKED UP BY GTRANG
RANGHI RMB    2        ;RANGE UPPER LIMIT PICKED UP BY GTRANG

LASTGO RMB    2        ;LAST SPECIFIED GOTO ADDRESS

VERFRM RMB    2        ;BEGINNING ADDRESS OF RANGE TO CHECKSUM VERIFY
VERTO  RMB    2        ;ENDING ADDRESS OF RANGE TO CHECKSUM VERIFY

CHKSUM RMB    1        ;CHECKSUM OF RANGE GIVEN IN THE VERIFY COMMAND

BRKADR RMB    2        ;ADDRESS OF INSERTED BREAKPOINT
BRKINS RMB    1        ;INSTRUCTION WHICH SHOULD BE THERE NORMALLY

INPFLG RMB    1        ;ALTERNATE INPUT DESTINATION FLAG
INPADR RMB    2        ;ALTERNATE ADDRESS THAT THE INPUT CHARACTERS ARE TO COME FROM

OUTFLG RMB    1        ;ALTERNATE OUTPUT DESTINATION FLAG
OUTADR RMB    2        ;ALTERNATE ADDRESS THAT THE OUTPUT CHARACTERS ARE TO GO TO

HDXFLG RMB    1        ;HALF-DUPLEX TERMINAL FLAG (IF NON-ZERO, NO ECHO)

CPLCNT RMB    1        ;"CHARACTERS PER LINE" COUNT
CPLMAX RMB    1        ;"CHARACTERS PER LINE" MAXIMUM
BUFBEG RMB    2        ;INPUT LINE START OF BUFFER
BUFEND RMB    2        ;INPUT LINE END OF BUFFER
TTYBUF RMB    72       ;START OF INPUT LINE BUFFER
TTYEND RMB    1        ;END OF INPUT LINE BUFFER
       RMB    56       ;MAIN STACK STORAGE
STACK  RMB    12       ;STACK STORAGE FOR RTI INSTRUCTION

;TEMPORARY (LOCALLY USED) VARIABLES
TEMP1  RMB    2        ;IN: MAIN
TEMP2  RMB    2        ;IN: MAIN
TEMP3  RMB    2        ;IN: FNDSTR,MAIN
TEMP4  RMB    2        ;IN: MAIN
TEMP5  RMB    2        ;IN: MAIN
TEMP6  RMB    2        ;IN: MAIN
TEMP7  RMB    2        ;IN: MAIN
TEMP8  RMB    2        ;IN: MAIN
TEMP9  RMB    2        ;IN: MAIN
TEMP10 RMB    2        ;IN: MAIN
TEMP11 RMB    2        ;IN: MAIN

;XTEMP IS NOT TO BE USED TO SAVE IX BETWEEN ROUTINES
XTEMP  RMB    2        ;USED BY DUMP,TYPCMD,OUTNUM
XTEMP1 RMB    2        ;USED BY OUTNUM
XTEMP2 RMB    2        ;USED BY NUMBER
NUMMAT RMB    1        ;USED IN COMMAND
LISNUM RMB    1        ;USED ON COMMAND
COMNUM RMB    1        ;USED IN COMMAND
LISPTR RMB    2        ;USED IN COMMAND
DECDIG RMB    1        ;DECIMAL DIGIT BEING BUILT (DECIMAL OUTPUT BASE)
NUMBHI RMB    1        ;USED BY OUTNUM
NUMBLO RMB    1        ;USED BY OUTNUM
NBR2X  RMB    2        ;USED BY NUMBER
TIMCON RMB    2        ;DELAY TIME CONSTANT
BYTECT RMB    1        ;RECORD BYTE COUNT USED IN LOAD COMMAND
CKSM   RMB    1        ;RECORD CHECKSUM USED IN LOAD COMMAND

;CONVENIENT EQUIVALENCES FOR LOCAL VARIABLES
MEMADR EQU    TEMP1    ;DISPLAY,SET,SEARCH,TEST
STRNUM EQU    TEMP2    ;FNDSTR
EOSCHR EQU    TEMP2+1  ;FNDSTR

;FOR "SEARCH" COMMAND
BYTPTR EQU    TEMP2
NBYTES EQU    TEMP3
NBRMAT EQU    TEMP3+1
BYTSTR EQU    TEMP4

;      END
