                      (                  monitor1v4.ASM):00001 ;  6309 Debug monitor for use with NOICE09
                      (                  monitor1v4.ASM):00002 ;  Adapted for HD6309 SBC March 2020
                      (                  monitor1v4.ASM):00003 ;
                      (                  monitor1v4.ASM):00004 ;  This is intended as a generic 6309 monitor.
                      (                  monitor1v4.ASM):00005 ;
                      (                  monitor1v4.ASM):00006 ;  Copyright (c) 1992-2006 by John Hartman
                      (                  monitor1v4.ASM):00007 ;
                      (                  monitor1v4.ASM):00008 ;  Modification History:
                      (                  monitor1v4.ASM):00009 ;    13-Mar-2006 JLH ported from 6809 version with assistance from Robert Gault
                      (                  monitor1v4.ASM):00010 ;     8-Mar-2016 TJL corrected bug in the RUN_TARGET handler 
                      (                  monitor1v4.ASM):00011 ;    11-Mar-2020 TJL ported to HD6309 SBC platform, lwasm assembler
                      (                  monitor1v4.ASM):00012 ;
                      (                  monitor1v4.ASM):00013 ;============================================================================
                      (                  monitor1v4.ASM):00014 ;  HARDWARE PLATFORM CUSTOMIZATIONS
                      (                  monitor1v4.ASM):00015 ;
     DE00             (                  monitor1v4.ASM):00016 RAM_START       EQU     $DE00           ; START OF MONITOR RAM
     C000             (                  monitor1v4.ASM):00017 ROM_START       EQU     $C000           ; START OF ROM IMAGE
     E200             (                  monitor1v4.ASM):00018 ROM_HSTART              EQU             $E200                   ; START OF HIGH ROM (above IO)
     FFC0             (                  monitor1v4.ASM):00019 JUMP_TABLE              EQU             $FFC0                   ; START OF UTILITY JUMP TABLE
     FFF0             (                  monitor1v4.ASM):00020 HARD_VECT       EQU     $FFF0           ; START OF HARDWARE VECTORS
                      (                  monitor1v4.ASM):00021                                          
                      (                  monitor1v4.ASM):00022 ; Configured to run on a system with 7.5K of ROM at the top of the
                      (                  monitor1v4.ASM):00023 ; memory map ($E200-$FFFF), and 56K of RAM from $0000-$DFFF. 
                      (                  monitor1v4.ASM):00024 ; NoICE uses 512 bytes of RAM from $DE00-$DFFF, and the system stack 
                      (                  monitor1v4.ASM):00025 ; stack pointer is initialized to point to the beginning of this area,
                      (                  monitor1v4.ASM):00026 ; allowing the user stack to grow downward into free user RAM.
                      (                  monitor1v4.ASM):00027 ;
                      (                  monitor1v4.ASM):00028 ; 512B from $E000-$E1FF is reserved for I/O devices:
                      (                  monitor1v4.ASM):00029 ; Z8536 CIO at $E000, Z85C30 SCC at $E010
                      (                  monitor1v4.ASM):00030 
     E000             (                  monitor1v4.ASM):00031 IOPAGE                  EQU             $E000                   ; Base address of I/O page
     E000             (                  monitor1v4.ASM):00032 ZCIO                    EQU             IOPAGE+$00              ; CIO base address
     E000             (                  monitor1v4.ASM):00033 CIOC                    EQU             ZCIO            ; CIO port C access
     E001             (                  monitor1v4.ASM):00034 CIOB                    EQU             ZCIO+1                  ; CIO port B access
     E002             (                  monitor1v4.ASM):00035 CIOA                    EQU             ZCIO+2                  ; CIO port A access
     E003             (                  monitor1v4.ASM):00036 CIOCTL                  EQU             ZCIO+3          ; CIO control register
                      (                  monitor1v4.ASM):00037 
     E010             (                  monitor1v4.ASM):00038 ZSCC                    EQU             IOPAGE+$10              ; SCC base address
     E010             (                  monitor1v4.ASM):00039 ZSCCBC                  EQU             ZSCC                    ;       SCC channel B comamnd reg
     E012             (                  monitor1v4.ASM):00040 ZSCCAC                  EQU             ZSCC+2                  ;       SCC channel A comamnd reg
     E013             (                  monitor1v4.ASM):00041 ZSCCAD                  EQU             ZSCC+3                  ;       SCC channel A data reg
     0001             (                  monitor1v4.ASM):00042 ZSCC.RXBF               EQU     $01             ; BIT MASK FOR RX BUFFER FULL
     0004             (                  monitor1v4.ASM):00043 ZSCC.TXBE               EQU     $04             ; BIT MASK FOR TX BUFFER EMPTY
                      (                  monitor1v4.ASM):00044 
                      (                  monitor1v4.ASM):00045 ; I2CPORT at $E020
                      (                  monitor1v4.ASM):00046 ;
                      (                  monitor1v4.ASM):00047 ;       7     6    5    4     3     2    1    0
                      (                  monitor1v4.ASM):00048 ;        [DSCL][DSDA][---][---][MSCL][MSDA][---][---]
                      (                  monitor1v4.ASM):00049 ;      rw    rw    r    r    r     r     r    r
                      (                  monitor1v4.ASM):00050 ;      1     1     0    0    x     x     0    0
                      (                  monitor1v4.ASM):00051 ;
                      (                  monitor1v4.ASM):00052 ; DSCL == drive SCL 1 --> float SCL ; 0 --> drive SCL low
                      (                  monitor1v4.ASM):00053 ; DSDA == drive SDA 1 --> float SDA ; 0 --> drive SDA low
                      (                  monitor1v4.ASM):00054 ; MSCK == monitor SCL --> state of SCL
                      (                  monitor1v4.ASM):00055 ; MSDA == monitor SDA --> state of SDA
                      (                  monitor1v4.ASM):00056 
     E020             (                  monitor1v4.ASM):00057 I2CPORT                 EQU             IOPAGE+$20              ;soft I2C port
     0080             (                  monitor1v4.ASM):00058 I2C.DSCL                EQU     $80
     0040             (                  monitor1v4.ASM):00059 I2C.DSDA                EQU     $40
     0008             (                  monitor1v4.ASM):00060 I2C.MSCL                EQU     $08
     0004             (                  monitor1v4.ASM):00061 I2C.MSDA                EQU     $04
                      (                  monitor1v4.ASM):00062 
                      (                  monitor1v4.ASM):00063 ; SDCARD port at $E030
                      (                  monitor1v4.ASM):00064 ;    8 bits of data to transfer via SPI
                      (                  monitor1v4.ASM):00065 
     E030             (                  monitor1v4.ASM):00066 SDPORT                  EQU             IOPAGE+$30              ; SDPORT register address
                      (                  monitor1v4.ASM):00067 
                      (                  monitor1v4.ASM):00068 ; SYSTEM CONFIG port at $E040
                      (                  monitor1v4.ASM):00069 ;       7    6    5    4    3     2     1      0
                      (                  monitor1v4.ASM):00070 ;        [---][---][---][CONF][RA14][ROMH][ROML][ROMWS]
                      (                  monitor1v4.ASM):00071 ;      r    r    r    r     rw    rw    rw    rw
                      (                  monitor1v4.ASM):00072 ;      0    0    0    x     1     1     1     1
                      (                  monitor1v4.ASM):00073 ;
                      (                  monitor1v4.ASM):00074 ;  CONF == status of CONFIG jumper 
                      (                  monitor1v4.ASM):00075 ;  RA14 == control ROM pin 27 (default to CONFIG jumper at reset)
                      (                  monitor1v4.ASM):00076 ;  ROMH == 1 --> bank ROM over $E200-$FFFF during reads (writes always go to RAM)
                      (                  monitor1v4.ASM):00077 ;  ROML == 1 --> bank ROM over $C000-$DFFF during reads (writes always go to RAM)
                      (                  monitor1v4.ASM):00078 ;  ROMWS == 1 --> insert wait state for ROM access; 0 --> no wait states for ROM
                      (                  monitor1v4.ASM):00079 
     E040             (                  monitor1v4.ASM):00080 SYSCFG                  EQU             IOPAGE+$40              ; SYSCFG register address
     0001             (                  monitor1v4.ASM):00081 SYS.ROMWS               EQU             $01
     0002             (                  monitor1v4.ASM):00082 SYS.ROMSEL              EQU             $02
     0004             (                  monitor1v4.ASM):00083 SYS.ROMSEH              EQU             $04
                      (                  monitor1v4.ASM):00084 
                      (                  monitor1v4.ASM):00085 ; INPUT-OUTPUT port at $E050
                      (                  monitor1v4.ASM):00086 ;       7     6      5      4    3  2    1     0
                      (                  monitor1v4.ASM):00087 ;    [SDSW][SDBSY][SDCLK][SDCS][PB][0][LED2][LED1]
                      (                  monitor1v4.ASM):00088 ;       I     I      O      O    x       O     O
                      (                  monitor1v4.ASM):00089 ;  all bits readable, output bits readback
                      (                  monitor1v4.ASM):00090 ;
                      (                  monitor1v4.ASM):00091 ;  SDSW == 1 when SD card is inserted
                      (                  monitor1v4.ASM):00092 ;  SDBSY == 1 while SPI transaction is taking place
                      (                  monitor1v4.ASM):00093 ;  SDCLK = 1 --> slow SPI clock; 0 --> fast SPI clock
                      (                  monitor1v4.ASM):00094 ;  SDCS = 1 --> CS signal to SDcard negated; 0 --> asserted
                      (                  monitor1v4.ASM):00095 ;  PB == 1 when pushbutton is pressed
                      (                  monitor1v4.ASM):00096 ;  LEDn = 1 --> illuminate corresponding LED
                      (                  monitor1v4.ASM):00097 
     E050             (                  monitor1v4.ASM):00098 IOPORT                  EQU             IOPAGE+$50              ; INOUT register address
     0001             (                  monitor1v4.ASM):00099 IO.LED1                 EQU             $01
     0002             (                  monitor1v4.ASM):00100 IO.LED2                 EQU             $02
     0008             (                  monitor1v4.ASM):00101 IO.PB                   EQU             $08
     0010             (                  monitor1v4.ASM):00102 IO.SDCS                 EQU             $10
     0020             (                  monitor1v4.ASM):00103 IO.SDCLK                EQU             $20
     0040             (                  monitor1v4.ASM):00104 IO.SDBSY                EQU             $40
     0080             (                  monitor1v4.ASM):00105 IO.SDSW                 EQU             $80
                      (                  monitor1v4.ASM):00106 
     E060             (                  monitor1v4.ASM):00107 CPLDVER                 EQU             IOPAGE+$60              ; CPLD VERSION register address
                      (                  monitor1v4.ASM):00108 
                      (                  monitor1v4.ASM):00109 ;
                      (                  monitor1v4.ASM):00110 ;  Other constants
                      (                  monitor1v4.ASM):00111 ;
                      (                  monitor1v4.ASM):00112 
                      (                  monitor1v4.ASM):00113 
                      (                  monitor1v4.ASM):00114 ;
                      (                  monitor1v4.ASM):00115 ;  Condition code bits
     0001             (                  monitor1v4.ASM):00116 C                       EQU     $01
     0004             (                  monitor1v4.ASM):00117 Z                               EQU             $04
     0010             (                  monitor1v4.ASM):00118 I                       EQU     $10
     0040             (                  monitor1v4.ASM):00119 F                       EQU     $40                 
     0080             (                  monitor1v4.ASM):00120 E                       EQU     $80
                      (                  monitor1v4.ASM):00121 ;
                      (                  monitor1v4.ASM):00122 ;============================================================================
                      (                  monitor1v4.ASM):00123 ;  RAM definitions:
                      (                  monitor1v4.ASM):00124                                 ORG     RAM_START
                      (                  monitor1v4.ASM):00125                                 
                      (                  monitor1v4.ASM):00126 ;
                      (                  monitor1v4.ASM):00127 ;  RAM for WOZMON
DE00                  (                  monitor1v4.ASM):00128 RAM_WOZMON              RMB             128+7                   ; storage for WOZMON input buffer, vars
                      (                  monitor1v4.ASM):00129                                 
                      (                  monitor1v4.ASM):00130 ;
                      (                  monitor1v4.ASM):00131 ;  RAM interrupt vectors (first in SEG for easy addressing, else move to
                      (                  monitor1v4.ASM):00132 ;  their own SEG)
     0008             (                  monitor1v4.ASM):00133 NVEC            EQU     8               ; number of vectors
DE87                  (                  monitor1v4.ASM):00134 RAMVEC          RMB     2*NVEC
                      (                  monitor1v4.ASM):00135 ;
                      (                  monitor1v4.ASM):00136 ;  Initial user stack
                      (                  monitor1v4.ASM):00137 ;  (Size and location is user option)
DE97                  (                  monitor1v4.ASM):00138                 RMB     64
                      (                  monitor1v4.ASM):00139 INITSTACK
                      (                  monitor1v4.ASM):00140 ;
                      (                  monitor1v4.ASM):00141 ;  Monitor stack
                      (                  monitor1v4.ASM):00142 ;  (Calculated use is at most 7 bytes.  Leave plenty of spare)
DED7                  (                  monitor1v4.ASM):00143                 RMB     32
                      (                  monitor1v4.ASM):00144 MONSTACK
                      (                  monitor1v4.ASM):00145 ;
                      (                  monitor1v4.ASM):00146 TEMP
DEF7                  (                  monitor1v4.ASM):00147 TEST_STACK      RMB     14
                      (                  monitor1v4.ASM):00148 ; It is not possible to read bits 0 and 1 of regMD so the next three 
                      (                  monitor1v4.ASM):00149 ; lines enable testing of these bits.
DF05                  (                  monitor1v4.ASM):00150 E_FLAG          RMB     1               ; 0=not set $80=set
DF06                  (                  monitor1v4.ASM):00151 S_IMAGE         RMB     2               ; temporary store for regS
                      (                  monitor1v4.ASM):00152 ;  Target registers:  order must match that in TRGHC11.C
                      (                  monitor1v4.ASM):00153 TASK_REGS
DF08                  (                  monitor1v4.ASM):00154 REG_STATE       RMB     1
DF09                  (                  monitor1v4.ASM):00155 REG_PAGE        RMB     1
DF0A                  (                  monitor1v4.ASM):00156 REG_SP          RMB     2
DF0C                  (                  monitor1v4.ASM):00157 REG_U           RMB     2
DF0E                  (                  monitor1v4.ASM):00158 REG_Y           RMB     2
DF10                  (                  monitor1v4.ASM):00159 REG_X           RMB     2
DF12                  (                  monitor1v4.ASM):00160 REG_F           RMB     1               ; F BEFORE E, SO W IS LEAST SIG. FIRST
DF13                  (                  monitor1v4.ASM):00161 REG_E           RMB     1
DF14                  (                  monitor1v4.ASM):00162 REG_B           RMB     1               ; B BEFORE A, SO D IS LEAST SIG. FIRST
DF15                  (                  monitor1v4.ASM):00163 REG_A           RMB     1
DF16                  (                  monitor1v4.ASM):00164 REG_DP          RMB     1
DF17                  (                  monitor1v4.ASM):00165 REG_CC          RMB     1
DF18                  (                  monitor1v4.ASM):00166 REG_MD          RMB     1
DF19                  (                  monitor1v4.ASM):00167 REG_V           RMB     2
DF1B                  (                  monitor1v4.ASM):00168 REG_PC          RMB     2
     0015             (                  monitor1v4.ASM):00169 TASK_REG_SZ     EQU     *-TASK_REGS
                      (                  monitor1v4.ASM):00170 ;
                      (                  monitor1v4.ASM):00171 ;  Communications buffer
                      (                  monitor1v4.ASM):00172 ;  (Must be at least as long as TASK_REG_SZ.  At least 19 bytes recommended.
                      (                  monitor1v4.ASM):00173 ;  Larger values may improve speed of NoICE memory move commands.)
     0080             (                  monitor1v4.ASM):00174 COMBUF_SIZE     EQU     128             ; DATA SIZE FOR COMM BUFFER  
DF1D                  (                  monitor1v4.ASM):00175 COMBUF          RMB     2+COMBUF_SIZE+1 ; BUFFER ALSO HAS FN, LEN, AND CHECK
DFA0                  (                  monitor1v4.ASM):00176 COMCH                   RMB             1               ; SCC address used for NoICE monitor
                      (                  monitor1v4.ASM):00177                                                                                 ; ($10=Ch B, $12=Ch A, >$80 not assigned)
                      (                  monitor1v4.ASM):00178 ;
                      (                  monitor1v4.ASM):00179 ;  RTC read/write buffer & pointer
DFA1                  (                  monitor1v4.ASM):00180 RTCBUFFER               RMB             32                              ; buffer for 32 byte block of RTC registers
DFC1                  (                  monitor1v4.ASM):00181 RTCBUFPTR               RMB             2                               ; points to a 32-byte block in RAM for RTC
                      (                  monitor1v4.ASM):00182                                                                                 ; register reading & writing
                      (                  monitor1v4.ASM):00183 
     DFC3             (                  monitor1v4.ASM):00184 RAM_END         EQU     *               ; ADDRESS OF TOP+1 OF RAM
                      (                  monitor1v4.ASM):00185 
                      (                  monitor1v4.ASM):00186 ;===========================================================================
                      (                  monitor1v4.ASM):00187 ; MC6809 Floating Point functions (available as binary file only)
                      (                  monitor1v4.ASM):00188                 ORG             ROM_START
C000 87CD2000001EB182 (                  monitor1v4.ASM):00189                 INCLUDEBIN float09.bin
     B8025245C7003D00
     00009B535441CB00
     3F000000B9004650
     4FB9434F50595249
     4748542028432920
     4D4F544F524F4C41
     2031393832200220
     083477308D002220
     063477308D004410
     AE69E6A4C43FC126
     2F02C628EC85308B
     A6A010AF69316D6E
     8400800080008000
     80008000C800C800
     CB00CB007B007B01
     040100015501A900
     7B007B0193013F01
     2800AF019A019A01
     9A019A019A01F901
     F901F901F901D901
     D902780287034903
     D701D901D903B002
     EE02BB0085316933
     A5ECA4EDC4EFA435
     7710EEE4395032E5
     3432306550CB0531
     E5C60DA6A0A7805A
     26F935B217065720
     1017065210AEC83B
     30C8255F1703B224
     1CC60110AEC83930
     C8181703A4240E17
     12011705F42406AE
     C83717050C170666
     35F710AEC83B30C8
     255F2009C60110AE
     C83930C818170379
     395F2002C601AE63
     17060334048DDB24
     268DE124221711C3
     1705B624
                      (                  monitor1v4.ASM):00190 ;
                      (                  monitor1v4.ASM):00191 ;===========================================================================
                      (                  monitor1v4.ASM):00192         ORG     ROM_HSTART
                      (                  monitor1v4.ASM):00193 ;
                      (                  monitor1v4.ASM):00194 ;  Power on reset
                      (                  monitor1v4.ASM):00195 RESET
                      (                  monitor1v4.ASM):00196 ;
                      (                  monitor1v4.ASM):00197 ;  Set CPU mode to safe state
E200 1A50             (                  monitor1v4.ASM):00198         ORCC    #I+F                            ; INTERRUPTS OFF
E202 10CEDEF7         (                  monitor1v4.ASM):00199                 LDS     #MONSTACK                       ; CLEAN STACK IS HAPPY STACK
E206 BDE254           (                  monitor1v4.ASM):00200                 JSR             STARTUP                                 ; call platform dependent startup code          
                      (                  monitor1v4.ASM):00201 ;
                      (                  monitor1v4.ASM):00202 ;  Initialize RAM interrupt vectors
E209 108EE33E         (                  monitor1v4.ASM):00203         LDY     #INT_ENTRY                      ; ADDRESS OF DEFAULT HANDLER
E20D 8EDE87           (                  monitor1v4.ASM):00204         LDX     #RAMVEC                         ; POINTER TO RAM VECTORS
E210 C608             (                  monitor1v4.ASM):00205         LDB     #NVEC                           ; NUMBER OF VECTORS
E212 10AF81           (                  monitor1v4.ASM):00206 RES10   STY     ,X++                            ; SET VECTOR
E215 5A               (                  monitor1v4.ASM):00207         DECB
E216 26FA             (                  monitor1v4.ASM):00208         BNE     RES10
                      (                  monitor1v4.ASM):00209 ;
                      (                  monitor1v4.ASM):00210 ;  Initialize user registers
E218 CCDED7           (                  monitor1v4.ASM):00211         LDD     #INITSTACK
E21B B7DF0B           (                  monitor1v4.ASM):00212         STA     REG_SP+1                ; INIT USER'S STACK POINTER MSB
E21E F7DF0A           (                  monitor1v4.ASM):00213         STB     REG_SP                  ; LSB
                      (                  monitor1v4.ASM):00214 ;
E221 104F             (                  monitor1v4.ASM):00215         CLRD
E223 FDDF1B           (                  monitor1v4.ASM):00216         STD     REG_PC
E226 B7DF15           (                  monitor1v4.ASM):00217         STA     REG_A
E229 B7DF14           (                  monitor1v4.ASM):00218         STA     REG_B
E22C B7DF13           (                  monitor1v4.ASM):00219         STA     REG_E
E22F B7DF12           (                  monitor1v4.ASM):00220         STA     REG_F
E232 B7DF16           (                  monitor1v4.ASM):00221         STA     REG_DP
E235 B7DF18           (                  monitor1v4.ASM):00222         STA     REG_MD
E238 FDDF10           (                  monitor1v4.ASM):00223         STD     REG_X
E23B FDDF0E           (                  monitor1v4.ASM):00224         STD     REG_Y
E23E FDDF0C           (                  monitor1v4.ASM):00225         STD     REG_U
E241 FDDF19           (                  monitor1v4.ASM):00226         STD     REG_V
E244 B7DF08           (                  monitor1v4.ASM):00227         STA     REG_STATE               ; initial state is "RESET"
                      (                  monitor1v4.ASM):00228 ;
E247 86D0             (                  monitor1v4.ASM):00229         LDA     #E+I+F                  ; state "all regs pushed", no ints
E249 B7DF17           (                  monitor1v4.ASM):00230         STA     REG_CC
                      (                  monitor1v4.ASM):00231 ;
                      (                  monitor1v4.ASM):00232 ;  Set function code for "GO".  Then if we reset after being told to
                      (                  monitor1v4.ASM):00233 ;  GO, we will come back with registers so user can see the crash
E24C 86FA             (                  monitor1v4.ASM):00234         LDA     #FN_RUN_TARG
E24E B7DF1D           (                  monitor1v4.ASM):00235         STA     COMBUF
E251 7EE4AA           (                  monitor1v4.ASM):00236         JMP     RETURN_REGS             ; DUMP REGS, ENTER MONITOR
                      (                  monitor1v4.ASM):00237                 
                      (                  monitor1v4.ASM):00238 ;======================================================================
                      (                  monitor1v4.ASM):00239 ; BEGINNING OF PLATFORM DEPENDENT STARTUP AND INPUT/OUTPUT CODE
                      (                  monitor1v4.ASM):00240 ;======================================================================
                      (                  monitor1v4.ASM):00241 STARTUP
E254 7230E050         (                  monitor1v4.ASM):00242                 AIM             #%00110000,IOPORT               ; un-select SDcard, slow SPI clock freq
E258 7101E050         (                  monitor1v4.ASM):00243                 OIM             #%00000001,IOPORT               ; LED1 on
E25C 72FDE040         (                  monitor1v4.ASM):00244                 AIM             #%11111101,SYSCFG               ; deselect ROMSEL to map RAM from $C000-$BFFF
                      (                  monitor1v4.ASM):00245 
                      (                  monitor1v4.ASM):00246 ;  Initialize HD6309 SBC Zilog Z85C30 SCC CH A and CH B for 115.2kbps 
E260 BDE2EC           (                  monitor1v4.ASM):00247                 JSR             SCC_INITA                               ; init SCC channel A
E263 BDE2F7           (                  monitor1v4.ASM):00248                 JSR             SCC_INITB                               ; init SCC channel B
E266 8690             (                  monitor1v4.ASM):00249                 LDA             #(128+ZSCC-IOPAGE)              ; offset of DUART channel B + 128 ($90)
E268 B7DFA0           (                  monitor1v4.ASM):00250                 STA             COMCH                                   ; no assigned DUART channel for monitor at reset
                      (                  monitor1v4.ASM):00251                 
                      (                  monitor1v4.ASM):00252 ;  Initialize RTCBUFPTR to point to RTCBUFFER
E26B CCDFA1           (                  monitor1v4.ASM):00253                 LDD             #RTCBUFFER
E26E FDDFC1           (                  monitor1v4.ASM):00254                 STD             RTCBUFPTR               
E271 39               (                  monitor1v4.ASM):00255                 RTS
                      (                  monitor1v4.ASM):00256 ;
                      (                  monitor1v4.ASM):00257 ;===========================================================================
                      (                  monitor1v4.ASM):00258 ;  Get a character to A
                      (                  monitor1v4.ASM):00259 ;
                      (                  monitor1v4.ASM):00260 ;  Return A=char, CY=0 if data received
                      (                  monitor1v4.ASM):00261 ;         CY=1 if timeout (0.5 seconds)
                      (                  monitor1v4.ASM):00262 ;
                      (                  monitor1v4.ASM):00263 ;  Uses 7 bytes of stack including return address
                      (                  monitor1v4.ASM):00264 ;  (increases to 9 bytes if the REWDT function is called)
                      (                  monitor1v4.ASM):00265 ;
                      (                  monitor1v4.ASM):00266 GETCHAR
E272 3434             (                  monitor1v4.ASM):00267                 PSHS    Y,X,B                                   ; preserve X,Y,B 
E274 8EE000           (                  monitor1v4.ASM):00268                 LDX             #IOPAGE                                 ; point to base IOPAGE address
E277 F6DFA0           (                  monitor1v4.ASM):00269                 LDB             COMCH                                   ; get offset to monitor command channel (+10/+12)
E27A C47F             (                  monitor1v4.ASM):00270                 ANDB    #%01111111                              ; ignore the "unassigned" bit
E27C 3A               (                  monitor1v4.ASM):00271                 ABX                                                             ; X is address of specific monitor command channel
E27D 108E0000         (                  monitor1v4.ASM):00272 GC05?   LDY             #0                                              ; clear Y for longest timeout           
                      (                  monitor1v4.ASM):00273 GC10?   ;BSR    REWDT                                   ; service watchdog
E281 313F             (                  monitor1v4.ASM):00274                 LEAY    -1,Y                                    ; decrement timeout counter
E283 270E             (                  monitor1v4.ASM):00275         BEQ     GC90?                           ;       EXIT IF TIMEOUT
E285 E684             (                  monitor1v4.ASM):00276                 LDB             ,X                                              ; reset register pointer to WR0/RR0
E287 E684             (                  monitor1v4.ASM):00277                 LDB             ,X                                              ; read RR0
E289 C401             (                  monitor1v4.ASM):00278                 ANDB    #ZSCC.RXBF                              ; examine the RX char available bit
E28B 27F4             (                  monitor1v4.ASM):00279                 BEQ             GC10?                                   ;       LOOP UNTIL CHARACTER AVAILABLE
E28D A601             (                  monitor1v4.ASM):00280                 LDA             1,X                                             ; read character from monitor data channel (+11/+13)
E28F 1CFE             (                  monitor1v4.ASM):00281                 ANDCC   #~C                                             ; CY=0 indicates character is available
E291 35B4             (                  monitor1v4.ASM):00282                 PULS    Y,X,B,PC                                ; restore X and B and return
E293 1A01             (                  monitor1v4.ASM):00283 GC90?   ORCC    #C                              ; CY=1 indicates timeout
E295 35B4             (                  monitor1v4.ASM):00284                 PULS    Y,X,B,PC                                ; restore Y,X,B and return
                      (                  monitor1v4.ASM):00285 ; alternate entry point - GETCHAR from UART CHANNEL A, with standard timeout duration
E297 3434             (                  monitor1v4.ASM):00286 GETA2   PSHS    Y,X,B                                   ; preserve X,Y,B
E299 8EE012           (                  monitor1v4.ASM):00287                 LDX             #ZSCCAC                                 ; point X to SCC Channel A ($E012)
E29C 20DF             (                  monitor1v4.ASM):00288                 BRA             GC05?                                   ; process as GETCHAR
                      (                  monitor1v4.ASM):00289 ; alternate entry point - GETCHAR from UART CHANNEL A, with no retry
E29E 3434             (                  monitor1v4.ASM):00290 GETA1   PSHS    Y,X,B                                   ; preserve X,Y,B
E2A0 8EE012           (                  monitor1v4.ASM):00291                 LDX             #ZSCCAC                                 ; point X to SCC Channel A ($E012)              
E2A3 108E0002         (                  monitor1v4.ASM):00292                 LDY             #2                                              ; only check once for a character in channel A
E2A7 20D8             (                  monitor1v4.ASM):00293                 BRA             GC10?                                   ; process as GETCHAR            
                      (                  monitor1v4.ASM):00294 ; alternate entry point - GETCHAR from UART CHANNEL A, with infinite retry duration
E2A9 3434             (                  monitor1v4.ASM):00295 GETA    PSHS    Y,X,B                                   ; preserve X,Y,B
E2AB 8EE012           (                  monitor1v4.ASM):00296 GA0?    LDX             #ZSCCAC                                 ; point X to SCC Channel A ($E012)
E2AE 8DCD             (                  monitor1v4.ASM):00297                 BSR             GC05?                                   ; process as GETCHAR
E2B0 24F9             (                  monitor1v4.ASM):00298                 BCC             GA0?                                    ;       if no character, keep trying
E2B2 39               (                  monitor1v4.ASM):00299                 RTS                                                             ;       otherwise, return with CY=1
                      (                  monitor1v4.ASM):00300 ;                       
                      (                  monitor1v4.ASM):00301 ;===========================================================================
                      (                  monitor1v4.ASM):00302 ;  Output character in A
                      (                  monitor1v4.ASM):00303 ;
                      (                  monitor1v4.ASM):00304 ;  Uses 5 bytes of stack including return address
                      (                  monitor1v4.ASM):00305 ;
                      (                  monitor1v4.ASM):00306 PUTCHAR
E2B3 3414             (                  monitor1v4.ASM):00307                 PSHS    X,B                                             ; preserve X,B 
E2B5 8EE000           (                  monitor1v4.ASM):00308                 LDX             #IOPAGE                                 ; point to base IOPAGE address
E2B8 F6DFA0           (                  monitor1v4.ASM):00309                 LDB             COMCH                                   ; get offset to monitor command channel (+10/+12)
E2BB C47F             (                  monitor1v4.ASM):00310                 ANDB    #%01111111                              ; ignore the "unassigned" bit
E2BD 3A               (                  monitor1v4.ASM):00311                 ABX                                                             ; X is address of specific monitor command channel
                      (                  monitor1v4.ASM):00312 PC10?   ;BSR    REWDT                                   ; service watchdog
E2BE E684             (                  monitor1v4.ASM):00313                 LDB             ,X                                              ; reset register pointer to WR0/RR0
E2C0 E684             (                  monitor1v4.ASM):00314                 LDB             ,X                                              ; read RR0
E2C2 C404             (                  monitor1v4.ASM):00315                 ANDB    #ZSCC.TXBE                              ;       examine the TX buffer empty bit
E2C4 27F8             (                  monitor1v4.ASM):00316                 BEQ             PC10?                                   ;       LOOP UNTIL EMPTY
E2C6 A701             (                  monitor1v4.ASM):00317                 STA             1,X                                             ; write character to monitor data channel (+11/+13)
E2C8 3594             (                  monitor1v4.ASM):00318                 PULS    X,B,PC                                  ; restore X and B and return
                      (                  monitor1v4.ASM):00319 ; alternate entry point - PURCHAR to UART CHANNEL A
E2CA 3414             (                  monitor1v4.ASM):00320 PUTA    PSHS    X,B                                             ; preserve X,B
E2CC 8EE012           (                  monitor1v4.ASM):00321                 LDX             #ZSCCAC                                 ; point X to SCC Channel A ($E012)
E2CF 20ED             (                  monitor1v4.ASM):00322                 BRA             PC10?                                   ; process as PUTCHAR
                      (                  monitor1v4.ASM):00323 ;
                      (                  monitor1v4.ASM):00324 ;======================================================================
                      (                  monitor1v4.ASM):00325 ;  RESET WATCHDOG TIMER.  MUST BE CALLED AT LEAST ONCE EVERY LITTLE WHILE
                      (                  monitor1v4.ASM):00326 ;  OR COP INTERRUPT WILL OCCUR
                      (                  monitor1v4.ASM):00327 ;
                      (                  monitor1v4.ASM):00328 ;  Uses 2 bytes of stack including return address
                      (                  monitor1v4.ASM):00329 ;
                      (                  monitor1v4.ASM):00330 ;REWDT  CLRA
                      (                  monitor1v4.ASM):00331 ;       STA     WDT
                      (                  monitor1v4.ASM):00332 ;       INCA
                      (                  monitor1v4.ASM):00333 ;       STA     WDT                             ; CU-style WDT:  must leave bit high
                      (                  monitor1v4.ASM):00334 ;       RTS
                      (                  monitor1v4.ASM):00335 ;
                      (                  monitor1v4.ASM):00336 ;======================================================================
                      (                  monitor1v4.ASM):00337 ;  Response string for GET TARGET STATUS request
                      (                  monitor1v4.ASM):00338 ;  Reply describes target:
E2D1 11               (                  monitor1v4.ASM):00339 TSTG    FCB     17                      ; 2: PROCESSOR TYPE = 6309
E2D2 80               (                  monitor1v4.ASM):00340         FCB     COMBUF_SIZE             ; 3: SIZE OF COMMUNICATIONS BUFFER
E2D3 00               (                  monitor1v4.ASM):00341         FCB     0                       ; 4: NO TASKING SUPPORT
E2D4 00000000         (                  monitor1v4.ASM):00342         FDB     0,0                     ; 5-8: LOW AND HIGH LIMIT OF MAPPED MEM (NONE)
E2D8 01               (                  monitor1v4.ASM):00343         FCB     B1-B0                   ; 9:  BREAKPOINT INSTR LENGTH
E2D9 3F               (                  monitor1v4.ASM):00344 B0      SWI                             ; 10: BREAKPOINT INSTRUCTION
E2DA 36333039206D6F6E (                  monitor1v4.ASM):00345 B1      FCC     '6309 monitor V1.0'     ; DESCRIPTION TEXT
     69746F722056312E
     30
E2EB 00               (                  monitor1v4.ASM):00346         FCB     0                       ; DESCRIPTION NULL TERMINATOR
     001B             (                  monitor1v4.ASM):00347 TSTG_SIZE       EQU     *-TSTG          ; SIZE OF STRING
                      (                  monitor1v4.ASM):00348 
                      (                  monitor1v4.ASM):00349 ;======================================================================
                      (                  monitor1v4.ASM):00350 ; INITIALIZE SCC DUART CHANNEL A
                      (                  monitor1v4.ASM):00351 ;
                      (                  monitor1v4.ASM):00352 SCC_INITA
E2EC 3432             (                  monitor1v4.ASM):00353                 PSHS    A,X,Y                                   ; preserve A,X,Y
E2EE 108EE012         (                  monitor1v4.ASM):00354                 LDY             #ZSCCAC                                 ; Y points to DUART channel A command reg
E2F2 8EE312           (                  monitor1v4.ASM):00355                 LDX             #SCCATBL                                ; X points to channel A config table
E2F5 2009             (                  monitor1v4.ASM):00356                 BRA             IS0                                             ; perform channel init
                      (                  monitor1v4.ASM):00357 
                      (                  monitor1v4.ASM):00358 ;======================================================================
                      (                  monitor1v4.ASM):00359 ; INITIALIZE SCC DUART CHANNEL B                
                      (                  monitor1v4.ASM):00360 ;               
                      (                  monitor1v4.ASM):00361 SCC_INITB
E2F7 3432             (                  monitor1v4.ASM):00362                 PSHS    A,X,Y                                   ; preserve A,X,Y
E2F9 108EE010         (                  monitor1v4.ASM):00363                 LDY             #ZSCCBC                                 ; Y points to DUART channel B command reg
E2FD 8EE328           (                  monitor1v4.ASM):00364                 LDX             #SCCBTBL                                ; X points to channel B config table
E300 A6A4             (                  monitor1v4.ASM):00365 IS0             LDA             ,Y                                              ; reset register pointer to WR0/RR0
E302 A680             (                  monitor1v4.ASM):00366 IS1?    LDA             ,X+                                             ; load address from table
E304 81FF             (                  monitor1v4.ASM):00367                 CMPA    #$FF                                    ; is it $ff? (end of table)
E306 2708             (                  monitor1v4.ASM):00368                 BEQ             IS2?                                    ;    yes, done with init of channel
E308 A7A4             (                  monitor1v4.ASM):00369                 STA             ,Y                                              ;    no, write the register pointer to WR0
E30A A680             (                  monitor1v4.ASM):00370                 LDA             ,X+                                             ; get data byte from table
E30C A7A4             (                  monitor1v4.ASM):00371                 STA             ,Y                                              ; write data to SCC command register
E30E 20F2             (                  monitor1v4.ASM):00372                 BRA             IS1?                                    ; repeat until EOT reached..
E310 35B2             (                  monitor1v4.ASM):00373 IS2?    PULS    A,X,Y,PC                                ; restore registers and return
                      (                  monitor1v4.ASM):00374 
                      (                  monitor1v4.ASM):00375 ;======================================================================
                      (                  monitor1v4.ASM):00376 ; Initialization table for SCC Channel A in ASYNC mode, external 16x clock
                      (                  monitor1v4.ASM):00377 ; ACLK from CPLD is 1.843 MHz. 1.843 / 16 = 115.2kbps (USB VCP interface)
                      (                  monitor1v4.ASM):00378 SCCATBL:
E312 0980             (                  monitor1v4.ASM):00379                 FCB $09,$80     ; WR9, reset channel A
E314 0900             (                  monitor1v4.ASM):00380                 FCB     $09,$00         ; WR9, un-reset channel A
E316 0444             (                  monitor1v4.ASM):00381                 FCB     $04,$44         ; WR4, X16 clock,1 Stop,NP
E318 03C1             (                  monitor1v4.ASM):00382                 FCB $03,$C1             ; WR3, Enable receiver, No Auto Enable (Hardware CTS), Receive 8 bits
E31A 05EA             (                  monitor1v4.ASM):00383                 FCB     $05,$EA         ; WR5, Enable transmitter, Transmit 8 bits RTS,DTR
E31C 0B05             (                  monitor1v4.ASM):00384                 FCB     $0B,$05         ; WR11, RX clock = TX clock = RTXC pin; TRXC pin = xmit clock
E31E 0C04             (                  monitor1v4.ASM):00385                 FCB     $0C,$04         ; WR12, Low byte 9600 Baud (optional)
E320 0D00             (                  monitor1v4.ASM):00386                 FCB     $0D,$00         ; WR13, High byte for Baud (optional)
E322 0E01             (                  monitor1v4.ASM):00387                 FCB     $0E,$01         ; WR14, Using a 1,8432 MHz BRG Clock (ECLK)
E324 0F00             (                  monitor1v4.ASM):00388                 FCB     $0F,$00         ; WR15, No INT from hardware CTS/RTS
E326 FFFF             (                  monitor1v4.ASM):00389                 FCB     $FF,$FF         ; EOT marker
                      (                  monitor1v4.ASM):00390 
                      (                  monitor1v4.ASM):00391 ;======================================================================
                      (                  monitor1v4.ASM):00392 ; Initialization table for SCC Channel B in ASYNC mode, external 32x clock
                      (                  monitor1v4.ASM):00393 ; BCLK from CPLD is 3.686 MHz. 3.686M / 32 = 115.2kbps (ChB Header)
                      (                  monitor1v4.ASM):00394 SCCBTBL:
E328 0940             (                  monitor1v4.ASM):00395                 FCB $09,$40     ; WR9, reset channel B
E32A 0900             (                  monitor1v4.ASM):00396                 FCB     $09,$00         ; WR9, un-reset channel B
E32C 0484             (                  monitor1v4.ASM):00397                 FCB     $04,$84         ; WR4, X32 clock,1 Stop,NP
E32E 03C1             (                  monitor1v4.ASM):00398                 FCB $03,$C1             ; WR3, Enable receiver, No Auto Enable (Hardware CTS), Receive 8 bits
E330 05EA             (                  monitor1v4.ASM):00399                 FCB     $05,$EA         ; WR5, Enable transmitter, Transmit 8 bits RTS,DTR
E332 0B05             (                  monitor1v4.ASM):00400                 FCB     $0B,$05         ; WR11, RX clock = TX clock = RTXC pin; TRXC pin = xmit clock
E334 0C04             (                  monitor1v4.ASM):00401                 FCB     $0C,$04         ; WR12, Low byte 9600 Baud (optional)
E336 0D00             (                  monitor1v4.ASM):00402                 FCB     $0D,$00         ; WR13, High byte for Baud (optional)
E338 0E01             (                  monitor1v4.ASM):00403                 FCB     $0E,$01         ; WR14, Using a 1,8432 MHz BRG Clock (ECLK)
E33A 0F00             (                  monitor1v4.ASM):00404                 FCB     $0F,$00         ; WR15, No INT from hardware CTS/RTS
E33C FFFF             (                  monitor1v4.ASM):00405                 FCB     $FF,$FF         ; EOT marker
                      (                  monitor1v4.ASM):00406                 
                      (                  monitor1v4.ASM):00407 ;======================================================================
                      (                  monitor1v4.ASM):00408 ; END OF PLATFORM DEPENDENT STARTUP AND INPUT/OUTPUT CODE
                      (                  monitor1v4.ASM):00409 ;======================================================================
                      (                  monitor1v4.ASM):00410 
                      (                  monitor1v4.ASM):00411 ;======================================================================
                      (                  monitor1v4.ASM):00412 ;  HARDWARE PLATFORM INDEPENDENT EQUATES AND CODE
                      (                  monitor1v4.ASM):00413 ;
                      (                  monitor1v4.ASM):00414 ;  Communications function codes.
     00FF             (                  monitor1v4.ASM):00415 FN_GET_STAT     EQU     $FF                     ; reply with device info
     00FE             (                  monitor1v4.ASM):00416 FN_READ_MEM     EQU     $FE                     ; reply with data
     00FD             (                  monitor1v4.ASM):00417 FN_WRITE_M      EQU     $FD                     ; reply with status (+/-)
     00FC             (                  monitor1v4.ASM):00418 FN_READ_RG      EQU     $FC                     ; reply with registers
     00FB             (                  monitor1v4.ASM):00419 FN_WRITE_RG     EQU     $FB                     ; reply with status
     00FA             (                  monitor1v4.ASM):00420 FN_RUN_TARG     EQU     $FA                     ; reply (delayed) with registers
     00F9             (                  monitor1v4.ASM):00421 FN_SET_BYTE     EQU     $F9                     ; reply with data (truncate if error)
     00F8             (                  monitor1v4.ASM):00422 FN_IN           EQU     $F8                     ; input from port
     00F7             (                  monitor1v4.ASM):00423 FN_OUT          EQU     $F7                     ; output to port
                      (                  monitor1v4.ASM):00424 ;                                               ; 
     00F7             (                  monitor1v4.ASM):00425 FN_MIN          EQU     $F7                     ; MINIMUM RECOGNIZED FUNCTION CODE
     00F0             (                  monitor1v4.ASM):00426 FN_ERROR        EQU     $F0                     ; error reply to unknown op-code
                      (                  monitor1v4.ASM):00427 ;
                      (                  monitor1v4.ASM):00428 ;===========================================================================
                      (                  monitor1v4.ASM):00429 ;  Common handler for default interrupt handlers
                      (                  monitor1v4.ASM):00430 ;  Enter with A=interrupt code = processor state
                      (                  monitor1v4.ASM):00431 ;  All registers stacked, PC=next instruction
                      (                  monitor1v4.ASM):00432 ;
                      (                  monitor1v4.ASM):00433 ;  If 6809 mode, stack has CC A B DP XH XL YH YL UH UL PCH PCL
                      (                  monitor1v4.ASM):00434 ;  If 6309 mode, stack has CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      (                  monitor1v4.ASM):00435 ;
                      (                  monitor1v4.ASM):00436 INT_ENTRY
E33E B7DF08           (                  monitor1v4.ASM):00437         STA     REG_STATE                       ; SAVE STATE
                      (                  monitor1v4.ASM):00438 ;
                      (                  monitor1v4.ASM):00439 ;  Save registers from stack to reg block for return to master
                      (                  monitor1v4.ASM):00440 ;  Host wants least significant bytes first, so flip as necessary
E341 3502             (                  monitor1v4.ASM):00441         PULS    A
E343 B7DF17           (                  monitor1v4.ASM):00442         STA     REG_CC                          ; CONDITION CODES
E346 3502             (                  monitor1v4.ASM):00443         PULS    A                               
E348 B7DF15           (                  monitor1v4.ASM):00444         STA     REG_A                           ; A
E34B 3502             (                  monitor1v4.ASM):00445         PULS    A                               
E34D B7DF14           (                  monitor1v4.ASM):00446         STA     REG_B                           ; B
                      (                  monitor1v4.ASM):00447 
                      (                  monitor1v4.ASM):00448 ;  If native mode, E and F are on stack
                      (                  monitor1v4.ASM):00449 ;  If 6809 mode, E and F are in registers, unchanged from interrupt til here
E350 BDE639           (                  monitor1v4.ASM):00450         JSR     MD_TEST
E353 2602             (                  monitor1v4.ASM):00451         BNE     IE_10                           ; Jump if 6809 mode
E355 1039             (                  monitor1v4.ASM):00452         PULSW                                   ; else native: get from stack
E357 11B7DF13         (                  monitor1v4.ASM):00453 IE_10   STE     REG_E
E35B 11F7DF12         (                  monitor1v4.ASM):00454         STF     REG_F
                      (                  monitor1v4.ASM):00455 
                      (                  monitor1v4.ASM):00456 ;  V isn't on the stack, but we haven't touched it.  Copy to RAM
E35F 1F70             (                  monitor1v4.ASM):00457         TFR     V,D
E361 B7DF1A           (                  monitor1v4.ASM):00458         STA     REG_V+1                         ; MSB V
E364 F7DF19           (                  monitor1v4.ASM):00459         STB     REG_V                           ; LSB V
                      (                  monitor1v4.ASM):00460 
                      (                  monitor1v4.ASM):00461 ;  There seems to be no way to store MD, and no way to load it except immediate
                      (                  monitor1v4.ASM):00462 ;  Thus we have to construct it by BITMD
E367 B6DF18           (                  monitor1v4.ASM):00463         LDA     REG_MD
E36A 8403             (                  monitor1v4.ASM):00464         ANDA    #$03                            ; save only bits 1 and 0 (set by MD_TEST)
E36C 113C40           (                  monitor1v4.ASM):00465         BITMD   #$40
E36F 2702             (                  monitor1v4.ASM):00466         BEQ     IE_11
E371 8A40             (                  monitor1v4.ASM):00467         ORA     #$40
E373 113C80           (                  monitor1v4.ASM):00468 IE_11   BITMD   #$80
E376 2702             (                  monitor1v4.ASM):00469         BEQ     IE_12
E378 8A80             (                  monitor1v4.ASM):00470         ORA     #$80
E37A B7DF18           (                  monitor1v4.ASM):00471 IE_12   STA     REG_MD
                      (                  monitor1v4.ASM):00472 
E37D 3502             (                  monitor1v4.ASM):00473         PULS    A
E37F B7DF16           (                  monitor1v4.ASM):00474         STA     REG_DP                          ; DP
E382 3506             (                  monitor1v4.ASM):00475         PULS    D
E384 B7DF11           (                  monitor1v4.ASM):00476         STA     REG_X+1                         ; MSB X
E387 F7DF10           (                  monitor1v4.ASM):00477         STB     REG_X                           ; LSB X
E38A 3506             (                  monitor1v4.ASM):00478         PULS    D
E38C B7DF0F           (                  monitor1v4.ASM):00479         STA     REG_Y+1                         ; MSB Y
E38F F7DF0E           (                  monitor1v4.ASM):00480         STB     REG_Y                           ; LSB Y
E392 3506             (                  monitor1v4.ASM):00481         PULS    D
E394 B7DF0D           (                  monitor1v4.ASM):00482         STA     REG_U+1                         ; MSB U
E397 F7DF0C           (                  monitor1v4.ASM):00483         STB     REG_U                           ; LSB U
                      (                  monitor1v4.ASM):00484 ;
                      (                  monitor1v4.ASM):00485 ;  If this is a breakpoint (state = 1), then back up PC to point at SWI
E39A 3510             (                  monitor1v4.ASM):00486         PULS    X                               ; PC AFTER INTERRUPT
E39C B6DF08           (                  monitor1v4.ASM):00487         LDA     REG_STATE    
E39F 8101             (                  monitor1v4.ASM):00488         CMPA    #1           
E3A1 2602             (                  monitor1v4.ASM):00489         BNE     NOTBP                           ; BR IF NOT A BREAKPOINT
E3A3 301F             (                  monitor1v4.ASM):00490         LEAX    -1,X                            ; ELSE BACK UP TO POINT AT SWI LOCATION
E3A5 1F10             (                  monitor1v4.ASM):00491 NOTBP   TFR     X,D                             ; TRANSFER PC TO D
E3A7 B7DF1C           (                  monitor1v4.ASM):00492         STA     REG_PC+1                        ; MSB
E3AA F7DF1B           (                  monitor1v4.ASM):00493         STB     REG_PC                          ; LSB
E3AD 7EE53D           (                  monitor1v4.ASM):00494         JMP     ENTER_MON                       ; REG_PC POINTS AT POST-INTERRUPT OPCODE
                      (                  monitor1v4.ASM):00495 ;
                      (                  monitor1v4.ASM):00496 ;===========================================================================
                      (                  monitor1v4.ASM):00497 ;  Main loop  wait for command frame from master
                      (                  monitor1v4.ASM):00498 ;
                      (                  monitor1v4.ASM):00499 ;  Uses 6 bytes of stack including return address
                      (                  monitor1v4.ASM):00500 ;
E3B0 10CEDEF7         (                  monitor1v4.ASM):00501 MAIN    LDS     #MONSTACK               ; CLEAN STACK IS HAPPY STACK
E3B4 8EDF1D           (                  monitor1v4.ASM):00502         LDX     #COMBUF                 ; BUILD MESSAGE HERE
                      (                  monitor1v4.ASM):00503 ;
                      (                  monitor1v4.ASM):00504 ; check to see if a DUART channel has been already established
E3B7 B6DFA0           (                  monitor1v4.ASM):00505                 LDA     COMCH                                   ; examine the COMCH byte
E3BA 2A11             (                  monitor1v4.ASM):00506                 BPL             MA05                                    ;       <128 means channel is set already
                      (                  monitor1v4.ASM):00507 ; if not, then alternate channel (XOR with $02) after each timeout or message failure
                      (                  monitor1v4.ASM):00508 ; update LED2 to reflect the channel being tried
E3BC 8802             (                  monitor1v4.ASM):00509                 EORA    #%00000010                              ; select alternate channel ($10 -> $12, $12 -> $10)
E3BE B7DFA0           (                  monitor1v4.ASM):00510                 STA             COMCH                                   ; store new COMCH byte
E3C1 8402             (                  monitor1v4.ASM):00511                 ANDA    #%00000010                              ; isolate the channel A/B bit in COMCH                                          
E3C3 72FDE050         (                  monitor1v4.ASM):00512                 AIM             #%11111101,IOPORT               ; clear IOPORT bit 2 (LED2 control)
E3C7 BAE050           (                  monitor1v4.ASM):00513                 ORA             IOPORT                                  ; OR the IOPORT and channel A/B bit
E3CA B7E050           (                  monitor1v4.ASM):00514                 STA             IOPORT                                  ; store back to IOPORT
                      (                  monitor1v4.ASM):00515 ;
                      (                  monitor1v4.ASM):00516 ;  First byte is a function code
E3CD BDE272           (                  monitor1v4.ASM):00517 MA05    JSR     GETCHAR                 ; GET A FUNCTION (6 bytes of stack)
E3D0 25DE             (                  monitor1v4.ASM):00518         BCS     MAIN                    ; JIF TIMEOUT: RESYNC
E3D2 81F7             (                  monitor1v4.ASM):00519         CMPA    #FN_MIN
E3D4 25DA             (                  monitor1v4.ASM):00520         BLO     MAIN                    ; JIF BELOW MIN: ILLEGAL FUNCTION
E3D6 A780             (                  monitor1v4.ASM):00521         STA     ,X+                     ; SAVE FUNCTION CODE
                      (                  monitor1v4.ASM):00522 ;
                      (                  monitor1v4.ASM):00523 ;  Second byte is data byte count (may be zero)
E3D8 BDE272           (                  monitor1v4.ASM):00524         JSR     GETCHAR                 ; GET A LENGTH BYTE
E3DB 25D3             (                  monitor1v4.ASM):00525         BCS     MAIN                    ; JIF TIMEOUT: RESYNC
E3DD 8180             (                  monitor1v4.ASM):00526         CMPA    #COMBUF_SIZE
E3DF 22CF             (                  monitor1v4.ASM):00527         BHI     MAIN                    ; JIF TOO LONG: ILLEGAL LENGTH
E3E1 A780             (                  monitor1v4.ASM):00528         STA     ,X+                     ; SAVE LENGTH
E3E3 8100             (                  monitor1v4.ASM):00529         CMPA    #0
E3E5 270C             (                  monitor1v4.ASM):00530         BEQ     MA80                    ; SKIP DATA LOOP IF LENGTH = 0
                      (                  monitor1v4.ASM):00531 ;
                      (                  monitor1v4.ASM):00532 ;  Loop for data
E3E7 1F89             (                  monitor1v4.ASM):00533         TFR     A,B                     ; SAVE LENGTH FOR LOOP
E3E9 BDE272           (                  monitor1v4.ASM):00534 MA10    JSR     GETCHAR                 ; GET A DATA BYTE
E3EC 25C2             (                  monitor1v4.ASM):00535         BCS     MAIN                    ; JIF TIMEOUT: RESYNC
E3EE A780             (                  monitor1v4.ASM):00536         STA     ,X+                     ; SAVE DATA BYTE
E3F0 5A               (                  monitor1v4.ASM):00537         DECB
E3F1 26F6             (                  monitor1v4.ASM):00538         BNE     MA10
                      (                  monitor1v4.ASM):00539 ;
                      (                  monitor1v4.ASM):00540 ;  Get the checksum
E3F3 BDE272           (                  monitor1v4.ASM):00541 MA80    JSR     GETCHAR                 ; GET THE CHECKSUM
E3F6 25B8             (                  monitor1v4.ASM):00542         BCS     MAIN                    ; JIF TIMEOUT: RESYNC
E3F8 3402             (                  monitor1v4.ASM):00543         PSHS    A                       ; SAVE CHECKSUM
                      (                  monitor1v4.ASM):00544 ;
                      (                  monitor1v4.ASM):00545 ;  Compare received checksum to that calculated on received buffer
                      (                  monitor1v4.ASM):00546 ;  (Sum should be 0)
E3FA BDE5BA           (                  monitor1v4.ASM):00547         JSR     CHECKSUM
E3FD ABE0             (                  monitor1v4.ASM):00548         ADDA    ,S+                     ; ADD SAVED CHECKSUM TO COMPUTED
E3FF 26AF             (                  monitor1v4.ASM):00549         BNE     MAIN                    ; JIF BAD CHECKSUM
                      (                  monitor1v4.ASM):00550 ;
                      (                  monitor1v4.ASM):00551 ; at this point, we've received a valid message from the host via the
                      (                  monitor1v4.ASM):00552 ; current DUART channel. We'll clear the msb of COMCH to indicate
                      (                  monitor1v4.ASM):00553 ; that the current channel is now "assigned" for use
E401 727FDFA0         (                  monitor1v4.ASM):00554                 AIM             #%01111111,COMCH                ; clear the msbit
                      (                  monitor1v4.ASM):00555 ;
                      (                  monitor1v4.ASM):00556 ;  Process the message.
E405 8EDF1D           (                  monitor1v4.ASM):00557         LDX     #COMBUF
E408 A680             (                  monitor1v4.ASM):00558         LDA     ,X+                     ; GET THE FUNCTION CODE
E40A E680             (                  monitor1v4.ASM):00559         LDB     ,X+                     ; GET THE LENGTH
E40C 81FF             (                  monitor1v4.ASM):00560         CMPA    #FN_GET_STAT
E40E 2742             (                  monitor1v4.ASM):00561         BEQ     TARGET_STAT
E410 81FE             (                  monitor1v4.ASM):00562         CMPA    #FN_READ_MEM
E412 2726             (                  monitor1v4.ASM):00563         BEQ     JREAD_MEM
E414 81FD             (                  monitor1v4.ASM):00564         CMPA    #FN_WRITE_M
E416 2725             (                  monitor1v4.ASM):00565         BEQ     JWRITE_MEM
E418 81FC             (                  monitor1v4.ASM):00566         CMPA    #FN_READ_RG
E41A 2724             (                  monitor1v4.ASM):00567         BEQ     JREAD_REGS
E41C 81FB             (                  monitor1v4.ASM):00568         CMPA    #FN_WRITE_RG
E41E 2723             (                  monitor1v4.ASM):00569         BEQ     JWRITE_REGS
E420 81FA             (                  monitor1v4.ASM):00570         CMPA    #FN_RUN_TARG
E422 2722             (                  monitor1v4.ASM):00571         BEQ     JRUN_TARGET
E424 81F9             (                  monitor1v4.ASM):00572         CMPA    #FN_SET_BYTE
E426 2721             (                  monitor1v4.ASM):00573         BEQ     JSET_BYTES
E428 81F8             (                  monitor1v4.ASM):00574         CMPA    #FN_IN
E42A 2720             (                  monitor1v4.ASM):00575         BEQ     JIN_PORT
E42C 81F7             (                  monitor1v4.ASM):00576         CMPA    #FN_OUT
E42E 271F             (                  monitor1v4.ASM):00577         BEQ     JOUT_PORT
                      (                  monitor1v4.ASM):00578 ;
                      (                  monitor1v4.ASM):00579 ;  Error: unknown function.  Complain
E430 86F0             (                  monitor1v4.ASM):00580         LDA     #FN_ERROR
E432 B7DF1D           (                  monitor1v4.ASM):00581         STA     COMBUF                          ; SET FUNCTION AS "ERROR"
E435 8601             (                  monitor1v4.ASM):00582         LDA     #1
E437 7EE598           (                  monitor1v4.ASM):00583         JMP     SEND_STATUS                     ; VALUE IS "ERROR"
                      (                  monitor1v4.ASM):00584 ;
                      (                  monitor1v4.ASM):00585 ;  long jumps to handlers
E43A 7EE467           (                  monitor1v4.ASM):00586 JREAD_MEM       JMP     READ_MEM
E43D 7EE47E           (                  monitor1v4.ASM):00587 JWRITE_MEM      JMP     WRITE_MEM
E440 7EE4AA           (                  monitor1v4.ASM):00588 JREAD_REGS      JMP     READ_REGS
E443 7EE4BF           (                  monitor1v4.ASM):00589 JWRITE_REGS     JMP     WRITE_REGS
E446 7EE4D1           (                  monitor1v4.ASM):00590 JRUN_TARGET     JMP     RUN_TARGET
E449 7EE551           (                  monitor1v4.ASM):00591 JSET_BYTES      JMP     SET_BYTES
E44C 7EE57F           (                  monitor1v4.ASM):00592 JIN_PORT        JMP     IN_PORT
E44F 7EE58A           (                  monitor1v4.ASM):00593 JOUT_PORT       JMP     OUT_PORT
                      (                  monitor1v4.ASM):00594 
                      (                  monitor1v4.ASM):00595 ;===========================================================================
                      (                  monitor1v4.ASM):00596 ;
                      (                  monitor1v4.ASM):00597 ;  Target Status:  FN, len
                      (                  monitor1v4.ASM):00598 ;
                      (                  monitor1v4.ASM):00599 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00600 ;
                      (                  monitor1v4.ASM):00601 TARGET_STAT
E452 8EE2D1           (                  monitor1v4.ASM):00602         LDX     #TSTG                   ; DATA FOR REPLY
E455 108EDF1E         (                  monitor1v4.ASM):00603         LDY     #COMBUF+1               ; POINTER TO RETURN BUFFER
E459 C61B             (                  monitor1v4.ASM):00604         LDB     #TSTG_SIZE              ; LENGTH OF REPLY
E45B E7A0             (                  monitor1v4.ASM):00605         STB     ,Y+                     ; SET SIZE IN REPLY BUFFER
E45D A680             (                  monitor1v4.ASM):00606 TS10    LDA     ,X+                     ; MOVE REPLY DATA TO BUFFER
E45F A7A0             (                  monitor1v4.ASM):00607         STA     ,Y+
E461 5A               (                  monitor1v4.ASM):00608         DECB
E462 26F9             (                  monitor1v4.ASM):00609         BNE     TS10
                      (                  monitor1v4.ASM):00610 ;
                      (                  monitor1v4.ASM):00611 ;  Compute checksum on buffer, and send to master, then return
E464 7EE5A2           (                  monitor1v4.ASM):00612         JMP     SEND
                      (                  monitor1v4.ASM):00613 
                      (                  monitor1v4.ASM):00614 ;===========================================================================
                      (                  monitor1v4.ASM):00615 ;
                      (                  monitor1v4.ASM):00616 ;  Read Memory:  FN, len, page, Alo, Ahi, Nbytes
                      (                  monitor1v4.ASM):00617 ;
                      (                  monitor1v4.ASM):00618 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00619 ;
                      (                  monitor1v4.ASM):00620 READ_MEM
                      (                  monitor1v4.ASM):00621 ;
                      (                  monitor1v4.ASM):00622 ;  Set map
                      (                  monitor1v4.ASM):00623 ;;;;    LDA     0,X
                      (                  monitor1v4.ASM):00624 ;;;;    STA     MAPIMG
                      (                  monitor1v4.ASM):00625 ;;;;    STA     MAPREG
                      (                  monitor1v4.ASM):00626 ;
                      (                  monitor1v4.ASM):00627 ;  Get address
E467 A602             (                  monitor1v4.ASM):00628         LDA     2,X                     ; MSB OF ADDRESS IN A
E469 E601             (                  monitor1v4.ASM):00629         LDB     1,X                     ; LSB OF ADDRESS IN B
E46B 1F02             (                  monitor1v4.ASM):00630         TFR     D,Y                     ; ADDRESS IN Y
                      (                  monitor1v4.ASM):00631 ;
                      (                  monitor1v4.ASM):00632 ;  Prepare return buffer: FN (unchanged), LEN, DATA
E46D E603             (                  monitor1v4.ASM):00633         LDB     3,X                     ; NUMBER OF BYTES TO RETURN
E46F F7DF1E           (                  monitor1v4.ASM):00634         STB     COMBUF+1                ; RETURN LENGTH = REQUESTED DATA
E472 2707             (                  monitor1v4.ASM):00635         BEQ     GLP90                   ; JIF NO BYTES TO GET
                      (                  monitor1v4.ASM):00636 ;
                      (                  monitor1v4.ASM):00637 ;  Read the requested bytes from local memory
E474 A6A0             (                  monitor1v4.ASM):00638 GLP     LDA     ,Y+                     ; GET BYTE
E476 A780             (                  monitor1v4.ASM):00639         STA     ,X+                     ; STORE TO RETURN BUFFER
E478 5A               (                  monitor1v4.ASM):00640         DECB
E479 26F9             (                  monitor1v4.ASM):00641         BNE     GLP
                      (                  monitor1v4.ASM):00642 ;
                      (                  monitor1v4.ASM):00643 ;  Compute checksum on buffer, and send to master, then return
E47B 7EE5A2           (                  monitor1v4.ASM):00644 GLP90   JMP     SEND
                      (                  monitor1v4.ASM):00645 
                      (                  monitor1v4.ASM):00646 ;===========================================================================
                      (                  monitor1v4.ASM):00647 ;
                      (                  monitor1v4.ASM):00648 ;  Write Memory:  FN, len, page, Alo, Ahi, (len-3 bytes of Data)
                      (                  monitor1v4.ASM):00649 ;
                      (                  monitor1v4.ASM):00650 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00651 ;
                      (                  monitor1v4.ASM):00652 ;  Uses 6 bytes of stack
                      (                  monitor1v4.ASM):00653 ;
                      (                  monitor1v4.ASM):00654 WRITE_MEM
                      (                  monitor1v4.ASM):00655 ;
                      (                  monitor1v4.ASM):00656 ;  Set map
E47E A680             (                  monitor1v4.ASM):00657         LDA     ,X+
                      (                  monitor1v4.ASM):00658 ;;;;    STA     MAPIMG
                      (                  monitor1v4.ASM):00659 ;;;;    STA     MAPREG
                      (                  monitor1v4.ASM):00660 ;
                      (                  monitor1v4.ASM):00661 ;  Get address
E480 E680             (                  monitor1v4.ASM):00662         LDB     ,X+                     ; LSB OF ADDRESS IN B
E482 A680             (                  monitor1v4.ASM):00663         LDA     ,X+                     ; MSB OF ADDRESS IN A
E484 1F02             (                  monitor1v4.ASM):00664         TFR     D,Y                     ; ADDRESS IN Y
                      (                  monitor1v4.ASM):00665 ;
                      (                  monitor1v4.ASM):00666 ;  Compute number of bytes to write
E486 F6DF1E           (                  monitor1v4.ASM):00667         LDB     COMBUF+1                ; NUMBER OF BYTES TO RETURN
E489 C003             (                  monitor1v4.ASM):00668         SUBB    #3                      ; MINUS PAGE AND ADDRESS
E48B 2714             (                  monitor1v4.ASM):00669         BEQ     WLP50                   ; JIF NO BYTES TO PUT
                      (                  monitor1v4.ASM):00670 ;
                      (                  monitor1v4.ASM):00671 ;  Write the specified bytes to local memory
E48D 3434             (                  monitor1v4.ASM):00672         PSHS    B,X,Y
E48F A680             (                  monitor1v4.ASM):00673 WLP     LDA     ,X+                     ; GET BYTE TO WRITE
E491 A7A0             (                  monitor1v4.ASM):00674         STA     ,Y+                     ; STORE THE BYTE AT ,Y
E493 5A               (                  monitor1v4.ASM):00675         DECB
E494 26F9             (                  monitor1v4.ASM):00676         BNE     WLP
                      (                  monitor1v4.ASM):00677 ;
                      (                  monitor1v4.ASM):00678 ;  Compare to see if the write worked
E496 3534             (                  monitor1v4.ASM):00679         PULS    B,X,Y
E498 A680             (                  monitor1v4.ASM):00680 WLP20   LDA     ,X+                     ; GET BYTE JUST WRITTEN
E49A A1A0             (                  monitor1v4.ASM):00681         CMPA    ,Y+
E49C 2607             (                  monitor1v4.ASM):00682         BNE     WLP80                   ; BR IF WRITE FAILED
E49E 5A               (                  monitor1v4.ASM):00683         DECB
E49F 26F7             (                  monitor1v4.ASM):00684         BNE     WLP20
                      (                  monitor1v4.ASM):00685 ;
                      (                  monitor1v4.ASM):00686 ;  Write succeeded:  return status = 0
E4A1 8600             (                  monitor1v4.ASM):00687 WLP50   LDA     #0                      ; RETURN STATUS = 0
E4A3 2002             (                  monitor1v4.ASM):00688         BRA     WLP90
                      (                  monitor1v4.ASM):00689 ;
                      (                  monitor1v4.ASM):00690 ;  Write failed:  return status = 1
E4A5 8601             (                  monitor1v4.ASM):00691 WLP80   LDA     #1
                      (                  monitor1v4.ASM):00692 
                      (                  monitor1v4.ASM):00693 ;  Return OK status
E4A7 7EE598           (                  monitor1v4.ASM):00694 WLP90   JMP     SEND_STATUS
                      (                  monitor1v4.ASM):00695 
                      (                  monitor1v4.ASM):00696 ;===========================================================================
                      (                  monitor1v4.ASM):00697 ;
                      (                  monitor1v4.ASM):00698 ;  Read registers:  FN, len=0
                      (                  monitor1v4.ASM):00699 ;
                      (                  monitor1v4.ASM):00700 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00701 ;
                      (                  monitor1v4.ASM):00702 READ_REGS
                      (                  monitor1v4.ASM):00703 ;
                      (                  monitor1v4.ASM):00704 ;  Enter here from SWI after "RUN" and "STEP" to return task registers
                      (                  monitor1v4.ASM):00705 RETURN_REGS
E4AA 108EDF08         (                  monitor1v4.ASM):00706         LDY     #TASK_REGS              ; POINTER TO REGISTERS
E4AE C615             (                  monitor1v4.ASM):00707         LDB     #TASK_REG_SZ            ; NUMBER OF BYTES
E4B0 8EDF1E           (                  monitor1v4.ASM):00708         LDX     #COMBUF+1               ; POINTER TO RETURN BUFFER
E4B3 E780             (                  monitor1v4.ASM):00709         STB     ,X+                     ; SAVE RETURN DATA LENGTH
                      (                  monitor1v4.ASM):00710 ;
                      (                  monitor1v4.ASM):00711 ;  Copy the registers
E4B5 A6A0             (                  monitor1v4.ASM):00712 GRLP    LDA     ,Y+                     ; GET BYTE TO A
E4B7 A780             (                  monitor1v4.ASM):00713         STA     ,X+                     ; STORE TO RETURN BUFFER
E4B9 5A               (                  monitor1v4.ASM):00714         DECB
E4BA 26F9             (                  monitor1v4.ASM):00715         BNE     GRLP
                      (                  monitor1v4.ASM):00716 ;
                      (                  monitor1v4.ASM):00717 ;  Compute checksum on buffer, and send to master, then return
E4BC 7EE5A2           (                  monitor1v4.ASM):00718         JMP     SEND
                      (                  monitor1v4.ASM):00719 
                      (                  monitor1v4.ASM):00720 ;===========================================================================
                      (                  monitor1v4.ASM):00721 ;
                      (                  monitor1v4.ASM):00722 ;  Write registers:  FN, len, (register image)
                      (                  monitor1v4.ASM):00723 ;
                      (                  monitor1v4.ASM):00724 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00725 ;
                      (                  monitor1v4.ASM):00726 WRITE_REGS
                      (                  monitor1v4.ASM):00727 ;
E4BF 5D               (                  monitor1v4.ASM):00728         TSTB                            ; NUMBER OF BYTES
E4C0 270B             (                  monitor1v4.ASM):00729         BEQ     WRR80                   ; JIF NO REGISTERS
                      (                  monitor1v4.ASM):00730 ;
                      (                  monitor1v4.ASM):00731 ;  Copy the registers
E4C2 108EDF08         (                  monitor1v4.ASM):00732         LDY     #TASK_REGS              ; POINTER TO REGISTERS
E4C6 A680             (                  monitor1v4.ASM):00733 WRRLP   LDA     ,X+                     ; GET BYTE TO A
E4C8 A7A0             (                  monitor1v4.ASM):00734         STA     ,Y+                     ; STORE TO REGISTER RAM
E4CA 5A               (                  monitor1v4.ASM):00735         DECB
E4CB 26F9             (                  monitor1v4.ASM):00736         BNE     WRRLP
                      (                  monitor1v4.ASM):00737 ;
                      (                  monitor1v4.ASM):00738 ;  Return OK status
E4CD 4F               (                  monitor1v4.ASM):00739 WRR80   CLRA
E4CE 7EE598           (                  monitor1v4.ASM):00740         JMP     SEND_STATUS
                      (                  monitor1v4.ASM):00741 
                      (                  monitor1v4.ASM):00742 ;===========================================================================
                      (                  monitor1v4.ASM):00743 ;
                      (                  monitor1v4.ASM):00744 ;  Run Target:  FN, len
                      (                  monitor1v4.ASM):00745 ;
                      (                  monitor1v4.ASM):00746 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00747 ;
                      (                  monitor1v4.ASM):00748 RUN_TARGET
                      (                  monitor1v4.ASM):00749 ;
                      (                  monitor1v4.ASM):00750 ;  Restore user's map
                      (                  monitor1v4.ASM):00751 ;*      LDA     REG_PAGE                ; USER'S PAGE
                      (                  monitor1v4.ASM):00752 ;*      STA     MAPIMG                  ; SET IMAGE
                      (                  monitor1v4.ASM):00753 ;*      STA     MAPREG                  ; SET MAPPING REGISTER
                      (                  monitor1v4.ASM):00754 ;
                      (                  monitor1v4.ASM):00755 ;  Switch to user stack
E4D1 B6DF0B           (                  monitor1v4.ASM):00756         LDA     REG_SP+1                ; BACK TO USER STACK
E4D4 F6DF0A           (                  monitor1v4.ASM):00757         LDB     REG_SP
E4D7 1F04             (                  monitor1v4.ASM):00758         TFR     D,S                     ; TO S
                      (                  monitor1v4.ASM):00759 ;
                      (                  monitor1v4.ASM):00760 ;  Restore MD, as it affects stack building and RTI
                      (                  monitor1v4.ASM):00761 ;  Only bits 1 and 0 can be written, and only using LDMD #
                      (                  monitor1v4.ASM):00762 ;  It's time for some self-modifying code!  Build LDMD #xxx, RTS in RAM and call it.
E4D9 CC113D           (                  monitor1v4.ASM):00763         LDD     #$113D                  ; LDMD #imm
E4DC FDDF3B           (                  monitor1v4.ASM):00764         STD     COMBUF+30               ; Start code string
E4DF B6DF18           (                  monitor1v4.ASM):00765         LDA     REG_MD                  ; #imm is desired MD value
E4E2 B7DF3D           (                  monitor1v4.ASM):00766         STA     COMBUF+32
E4E5 8639             (                  monitor1v4.ASM):00767         LDA     #$39                    ; RTS
E4E7 B7DF3E           (                  monitor1v4.ASM):00768         STA     COMBUF+33
E4EA BDDF3B           (                  monitor1v4.ASM):00769         JSR     COMBUF+30
                      (                  monitor1v4.ASM):00770 ;
                      (                  monitor1v4.ASM):00771 ;  Restore V, which isn't on the stack
E4ED B6DF1A           (                  monitor1v4.ASM):00772         LDA     REG_V+1
E4F0 F6DF19           (                  monitor1v4.ASM):00773         LDB     REG_V
E4F3 1F07             (                  monitor1v4.ASM):00774         TFR     D,V
                      (                  monitor1v4.ASM):00775 ;
                      (                  monitor1v4.ASM):00776 ;  Restore registers
E4F5 B6DF1C           (                  monitor1v4.ASM):00777         LDA     REG_PC+1                ; MS USER PC FOR RTI
E4F8 F6DF1B           (                  monitor1v4.ASM):00778         LDB     REG_PC                  ; LS USER PC FOR RTI
E4FB 3406             (                  monitor1v4.ASM):00779         PSHS    D
                      (                  monitor1v4.ASM):00780 ;
E4FD B6DF0D           (                  monitor1v4.ASM):00781         LDA     REG_U+1
E500 F6DF0C           (                  monitor1v4.ASM):00782         LDB     REG_U
E503 3406             (                  monitor1v4.ASM):00783         PSHS    D
                      (                  monitor1v4.ASM):00784 ;
E505 B6DF0F           (                  monitor1v4.ASM):00785         LDA     REG_Y+1
E508 F6DF0E           (                  monitor1v4.ASM):00786         LDB     REG_Y
E50B 3406             (                  monitor1v4.ASM):00787         PSHS    D
                      (                  monitor1v4.ASM):00788 ;
E50D B6DF11           (                  monitor1v4.ASM):00789         LDA     REG_X+1
E510 F6DF10           (                  monitor1v4.ASM):00790         LDB     REG_X
E513 3406             (                  monitor1v4.ASM):00791         PSHS    D
                      (                  monitor1v4.ASM):00792 ;
E515 B6DF16           (                  monitor1v4.ASM):00793         LDA     REG_DP
E518 3402             (                  monitor1v4.ASM):00794         PSHS    A
                      (                  monitor1v4.ASM):00795 ;
                      (                  monitor1v4.ASM):00796 ;  Restore W from memory (not used between here and RTI)
E51A 11B6DF13         (                  monitor1v4.ASM):00797         LDE     REG_E
E51E 11F6DF12         (                  monitor1v4.ASM):00798         LDF     REG_F
E522 B6DF18           (                  monitor1v4.ASM):00799         LDA     REG_MD
E525 8501             (                  monitor1v4.ASM):00800         BITA    #1
E527 2702             (                  monitor1v4.ASM):00801         BEQ     RT_10                   ; jump if 6809 mode
E529 1038             (                  monitor1v4.ASM):00802         PSHSW                           ; else push W on stack for RTI
                      (                  monitor1v4.ASM):00803 RT_10
                      (                  monitor1v4.ASM):00804 ;
E52B B6DF14           (                  monitor1v4.ASM):00805         LDA     REG_B
E52E 3402             (                  monitor1v4.ASM):00806         PSHS    A
                      (                  monitor1v4.ASM):00807 ;
E530 B6DF15           (                  monitor1v4.ASM):00808         LDA     REG_A
E533 3402             (                  monitor1v4.ASM):00809         PSHS    A
                      (                  monitor1v4.ASM):00810 ;
E535 B6DF17           (                  monitor1v4.ASM):00811         LDA     REG_CC                  ; SAVE USER CONDITION CODES FOR RTI
E538 8A80             (                  monitor1v4.ASM):00812         ORA     #E                      ; _MUST_ BE "ALL REGS PUSHED"
E53A 3402             (                  monitor1v4.ASM):00813         PSHS    A
                      (                  monitor1v4.ASM):00814 ;
                      (                  monitor1v4.ASM):00815 ;  Return to user (conditioned by MD.0)
E53C 3B               (                  monitor1v4.ASM):00816         RTI
                      (                  monitor1v4.ASM):00817 ;
                      (                  monitor1v4.ASM):00818 ;===========================================================================
                      (                  monitor1v4.ASM):00819 ;
                      (                  monitor1v4.ASM):00820 ;  Common continue point for all monitor entrances
                      (                  monitor1v4.ASM):00821 ;  SP = user stack
                      (                  monitor1v4.ASM):00822 ENTER_MON
E53D 1F40             (                  monitor1v4.ASM):00823         TFR     S,D                             ; USER STACK POINTER
E53F B7DF0B           (                  monitor1v4.ASM):00824         STA     REG_SP+1                        ; SAVE USER'S STACK POINTER (MSB)
E542 F7DF0A           (                  monitor1v4.ASM):00825         STB     REG_SP                          ; LSB
                      (                  monitor1v4.ASM):00826 ;
                      (                  monitor1v4.ASM):00827 ;  Change to our own stack
E545 10CEDEF7         (                  monitor1v4.ASM):00828         LDS     #MONSTACK                       ; AND USE OURS INSTEAD
                      (                  monitor1v4.ASM):00829 ;
                      (                  monitor1v4.ASM):00830 ;  Operating system variables
                      (                  monitor1v4.ASM):00831 ;*      LDA     MAPIMG                          ; GET CURRENT USER MAP
E549 8600             (                  monitor1v4.ASM):00832         LDA     #0                              ; ... OR ZERO IF UNMAPPED TARGET
E54B B7DF09           (                  monitor1v4.ASM):00833         STA     REG_PAGE                        ; SAVE USER'S PAGE
                      (                  monitor1v4.ASM):00834 ;
                      (                  monitor1v4.ASM):00835 ;  Return registers to master
E54E 7EE4AA           (                  monitor1v4.ASM):00836         JMP     RETURN_REGS
                      (                  monitor1v4.ASM):00837 
                      (                  monitor1v4.ASM):00838 ;===========================================================================
                      (                  monitor1v4.ASM):00839 ;
                      (                  monitor1v4.ASM):00840 ;  Set target byte(s):  FN, len { (page, alow, ahigh, data), (...)... }
                      (                  monitor1v4.ASM):00841 ;
                      (                  monitor1v4.ASM):00842 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00843 ;
                      (                  monitor1v4.ASM):00844 ;  Return has FN, len, (data from memory locations)
                      (                  monitor1v4.ASM):00845 ;
                      (                  monitor1v4.ASM):00846 ;  If error in insert (memory not writable), abort to return short data
                      (                  monitor1v4.ASM):00847 ;
                      (                  monitor1v4.ASM):00848 ;  This function is used primarily to set and clear breakpoints
                      (                  monitor1v4.ASM):00849 ;
                      (                  monitor1v4.ASM):00850 ;  Uses 1 byte of stack
                      (                  monitor1v4.ASM):00851 ;
                      (                  monitor1v4.ASM):00852 SET_BYTES
E551 CEDF1E           (                  monitor1v4.ASM):00853         LDU     #COMBUF+1               ; POINTER TO RETURN BUFFER
E554 8600             (                  monitor1v4.ASM):00854         LDA     #0 
E556 A7C0             (                  monitor1v4.ASM):00855         STA     ,U+                     ; SET RETURN COUNT AS ZERO
E558 54               (                  monitor1v4.ASM):00856         LSRB       
E559 54               (                  monitor1v4.ASM):00857         LSRB                            ; LEN/4 = NUMBER OF BYTES TO SET
E55A 2720             (                  monitor1v4.ASM):00858         BEQ     SB99                    ; JIF NO BYTES (COMBUF+1 = 0)
                      (                  monitor1v4.ASM):00859 ;                          
                      (                  monitor1v4.ASM):00860 ;  Loop on inserting bytes 
E55C 3404             (                  monitor1v4.ASM):00861 SB10    PSHS    B                       ; SAVE LOOP COUNTER
                      (                  monitor1v4.ASM):00862 ;
                      (                  monitor1v4.ASM):00863 ;  Set map
                      (                  monitor1v4.ASM):00864 ;;;;    LDA     0,X
                      (                  monitor1v4.ASM):00865 ;;;;    STA     MAPIMG
                      (                  monitor1v4.ASM):00866 ;;;;    STA     MAPREG
                      (                  monitor1v4.ASM):00867 ;
                      (                  monitor1v4.ASM):00868 ;  Get address
E55E A602             (                  monitor1v4.ASM):00869         LDA     2,X                     ; MSB OF ADDRESS IN A
E560 E601             (                  monitor1v4.ASM):00870         LDB     1,X                     ; LSB OF ADDRESS IN B
E562 1F02             (                  monitor1v4.ASM):00871         TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      (                  monitor1v4.ASM):00872 ;
                      (                  monitor1v4.ASM):00873 ;  Read current data at byte location
E564 A6A4             (                  monitor1v4.ASM):00874         LDA     0,Y
                      (                  monitor1v4.ASM):00875 ;
                      (                  monitor1v4.ASM):00876 ;  Insert new data at byte location
E566 E603             (                  monitor1v4.ASM):00877         LDB     3,X                     ; GET BYTE TO STORE
E568 E7A4             (                  monitor1v4.ASM):00878         STB     0,Y                     ; WRITE TARGET MEMORY
                      (                  monitor1v4.ASM):00879 ;
                      (                  monitor1v4.ASM):00880 ;  Verify write
E56A E1A4             (                  monitor1v4.ASM):00881         CMPB    0,Y                     ; READ TARGET MEMORY
E56C 3504             (                  monitor1v4.ASM):00882         PULS    B                       ; RESTORE LOOP COUNT, CC'S INTACT
E56E 260C             (                  monitor1v4.ASM):00883         BNE     SB90                    ; BR IF INSERT FAILED: ABORT
                      (                  monitor1v4.ASM):00884 ;
                      (                  monitor1v4.ASM):00885 ;  Save target byte in return buffer
E570 A7C0             (                  monitor1v4.ASM):00886         STA     ,U+
E572 7CDF1E           (                  monitor1v4.ASM):00887         INC     COMBUF+1                ; COUNT ONE RETURN BYTE
                      (                  monitor1v4.ASM):00888 ;
                      (                  monitor1v4.ASM):00889 ;  Loop for next byte
E575 3004             (                  monitor1v4.ASM):00890         LEAX    4,X                     ; STEP TO NEXT BYTE SPECIFIER
E577 F1DF1E           (                  monitor1v4.ASM):00891         CMPB    COMBUF+1
E57A 26E0             (                  monitor1v4.ASM):00892         BNE     SB10                    ; *LOOP FOR ALL BYTES
                      (                  monitor1v4.ASM):00893 ;
                      (                  monitor1v4.ASM):00894 ;  Return buffer with data from byte locations
                      (                  monitor1v4.ASM):00895 SB90
                      (                  monitor1v4.ASM):00896 ;
                      (                  monitor1v4.ASM):00897 ;  Compute checksum on buffer, and send to master, then return
E57C 7EE5A2           (                  monitor1v4.ASM):00898 SB99    JMP     SEND
                      (                  monitor1v4.ASM):00899 
                      (                  monitor1v4.ASM):00900 ;===========================================================================
                      (                  monitor1v4.ASM):00901 ;
                      (                  monitor1v4.ASM):00902 ;  Input from port:  FN, len, PortAddressLo, PAhi (=0)
                      (                  monitor1v4.ASM):00903 ;
                      (                  monitor1v4.ASM):00904 ;  While the 6809 has no input or output instructions, we retain these
                      (                  monitor1v4.ASM):00905 ;  to allow write-without-verify
                      (                  monitor1v4.ASM):00906 ;
                      (                  monitor1v4.ASM):00907 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00908 ;
                      (                  monitor1v4.ASM):00909 IN_PORT
                      (                  monitor1v4.ASM):00910 ;
                      (                  monitor1v4.ASM):00911 ;  Get port address
E57F A601             (                  monitor1v4.ASM):00912         LDA     1,X                     ; MSB OF ADDRESS IN A
E581 E684             (                  monitor1v4.ASM):00913         LDB     0,X                     ; LSB OF ADDRESS IN B
E583 1F02             (                  monitor1v4.ASM):00914         TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      (                  monitor1v4.ASM):00915 ;
                      (                  monitor1v4.ASM):00916 ;  Read the requested byte from local memory
E585 A6A4             (                  monitor1v4.ASM):00917         LDA     0,Y
                      (                  monitor1v4.ASM):00918 ;
                      (                  monitor1v4.ASM):00919 ;  Return byte read as "status"
E587 7EE598           (                  monitor1v4.ASM):00920         JMP     SEND_STATUS
                      (                  monitor1v4.ASM):00921 
                      (                  monitor1v4.ASM):00922 ;===========================================================================
                      (                  monitor1v4.ASM):00923 ;
                      (                  monitor1v4.ASM):00924 ;  Output to port  FN, len, PortAddressLo, PAhi (=0), data
                      (                  monitor1v4.ASM):00925 ;
                      (                  monitor1v4.ASM):00926 ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (                  monitor1v4.ASM):00927 ;
                      (                  monitor1v4.ASM):00928 OUT_PORT
                      (                  monitor1v4.ASM):00929 ;
                      (                  monitor1v4.ASM):00930 ;  Get port address
E58A A601             (                  monitor1v4.ASM):00931         LDA     1,X                     ; MSB OF ADDRESS IN A
E58C E684             (                  monitor1v4.ASM):00932         LDB     0,X                     ; LSB OF ADDRESS IN B
E58E 1F02             (                  monitor1v4.ASM):00933         TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      (                  monitor1v4.ASM):00934 ;
                      (                  monitor1v4.ASM):00935 ;  Get data
E590 A602             (                  monitor1v4.ASM):00936         LDA     2,X
                      (                  monitor1v4.ASM):00937 ;
                      (                  monitor1v4.ASM):00938 ;  Write value to port
E592 A7A4             (                  monitor1v4.ASM):00939         STA     0,Y
                      (                  monitor1v4.ASM):00940 ;
                      (                  monitor1v4.ASM):00941 ;  Do not read port to verify (some I/O devices don't like it)
                      (                  monitor1v4.ASM):00942 ;
                      (                  monitor1v4.ASM):00943 ;  Return status of OK
E594 4F               (                  monitor1v4.ASM):00944         CLRA
E595 7EE598           (                  monitor1v4.ASM):00945         JMP     SEND_STATUS
                      (                  monitor1v4.ASM):00946 
                      (                  monitor1v4.ASM):00947 ;===========================================================================
                      (                  monitor1v4.ASM):00948 ;  Build status return with value from "A"
                      (                  monitor1v4.ASM):00949 ;
                      (                  monitor1v4.ASM):00950 SEND_STATUS
E598 B7DF1F           (                  monitor1v4.ASM):00951         STA     COMBUF+2                ; SET STATUS
E59B 8601             (                  monitor1v4.ASM):00952         LDA     #1
E59D B7DF1E           (                  monitor1v4.ASM):00953         STA     COMBUF+1                ; SET LENGTH
E5A0 2000             (                  monitor1v4.ASM):00954         BRA     SEND
                      (                  monitor1v4.ASM):00955 
                      (                  monitor1v4.ASM):00956 ;===========================================================================
                      (                  monitor1v4.ASM):00957 ;  Append checksum to COMBUF and send to master
                      (                  monitor1v4.ASM):00958 ;
E5A2 BDE5BA           (                  monitor1v4.ASM):00959 SEND    JSR     CHECKSUM                ; GET A=CHECKSUM, X->checksum location
E5A5 40               (                  monitor1v4.ASM):00960         NEGA
E5A6 A784             (                  monitor1v4.ASM):00961         STA     0,X                     ; STORE NEGATIVE OF CHECKSUM
                      (                  monitor1v4.ASM):00962 ;
                      (                  monitor1v4.ASM):00963 ;  Send buffer to master
E5A8 8EDF1D           (                  monitor1v4.ASM):00964         LDX     #COMBUF                 ; POINTER TO DATA
E5AB E601             (                  monitor1v4.ASM):00965         LDB     1,X                     ; LENGTH OF DATA
E5AD CB03             (                  monitor1v4.ASM):00966         ADDB    #3                      ; PLUS FUNCTION, LENGTH, CHECKSUM
E5AF A680             (                  monitor1v4.ASM):00967 SND10   LDA     ,X+
E5B1 BDE2B3           (                  monitor1v4.ASM):00968         JSR     PUTCHAR                 ; SEND A BYTE
E5B4 5A               (                  monitor1v4.ASM):00969         DECB
E5B5 26F8             (                  monitor1v4.ASM):00970         BNE     SND10
E5B7 7EE3B0           (                  monitor1v4.ASM):00971         JMP     MAIN                    ; BACK TO MAIN LOOP
                      (                  monitor1v4.ASM):00972 
                      (                  monitor1v4.ASM):00973 ;===========================================================================
                      (                  monitor1v4.ASM):00974 ;  Compute checksum on COMBUF.  COMBUF+1 has length of data,
                      (                  monitor1v4.ASM):00975 ;  Also include function byte and length byte
                      (                  monitor1v4.ASM):00976 ;
                      (                  monitor1v4.ASM):00977 ;  Returns:
                      (                  monitor1v4.ASM):00978 ;       A = checksum
                      (                  monitor1v4.ASM):00979 ;       X = pointer to next byte in buffer (checksum location)
                      (                  monitor1v4.ASM):00980 ;       B is scratched
                      (                  monitor1v4.ASM):00981 ;
                      (                  monitor1v4.ASM):00982 CHECKSUM
E5BA 8EDF1D           (                  monitor1v4.ASM):00983         LDX     #COMBUF                 ; pointer to buffer
E5BD E601             (                  monitor1v4.ASM):00984         LDB     1,X                     ; length of message
E5BF CB02             (                  monitor1v4.ASM):00985         ADDB    #2                      ; plus function, length
E5C1 8600             (                  monitor1v4.ASM):00986         LDA     #0                      ; init checksum to 0
E5C3 AB80             (                  monitor1v4.ASM):00987 CHK10   ADDA    ,X+
E5C5 5A               (                  monitor1v4.ASM):00988         DECB
E5C6 26FB             (                  monitor1v4.ASM):00989         BNE     CHK10                   ; loop for all
E5C8 39               (                  monitor1v4.ASM):00990         RTS                             ; return with checksum in A
                      (                  monitor1v4.ASM):00991 
                      (                  monitor1v4.ASM):00992 ;**********************************************************************
                      (                  monitor1v4.ASM):00993 ;
                      (                  monitor1v4.ASM):00994 ;  Interrupt handlers to catch unused interrupts and traps
                      (                  monitor1v4.ASM):00995 ;  Registers are stacked.  Jump through RAM vector using X, type in A
                      (                  monitor1v4.ASM):00996 ;
                      (                  monitor1v4.ASM):00997 ;  This will affect only interrupt routines looking for register values!
                      (                  monitor1v4.ASM):00998 ;
                      (                  monitor1v4.ASM):00999 ;  Our default handler uses the code in "A" as the processor state to be
                      (                  monitor1v4.ASM):01000 ;  passed back to the host.
                      (                  monitor1v4.ASM):01001 ;
                      (                  monitor1v4.ASM):01002 
                      (                  monitor1v4.ASM):01003 ;  This is "reserved" on 6809
                      (                  monitor1v4.ASM):01004 ;  Used for Divide-by-zero and Illegal-instruction on 6309
E5C9 8607             (                  monitor1v4.ASM):01005 RES_ENT     LDA     #7
E5CB BEDE87           (                  monitor1v4.ASM):01006             LDX     RAMVEC+0
E5CE 6E84             (                  monitor1v4.ASM):01007             JMP     0,X
                      (                  monitor1v4.ASM):01008 ;
E5D0 8606             (                  monitor1v4.ASM):01009 SWI3_ENT    LDA     #6
E5D2 BEDE89           (                  monitor1v4.ASM):01010             LDX     RAMVEC+2
E5D5 6E84             (                  monitor1v4.ASM):01011             JMP     0,X
                      (                  monitor1v4.ASM):01012 ;
E5D7 8605             (                  monitor1v4.ASM):01013 SWI2_ENT    LDA     #5
E5D9 BEDE8B           (                  monitor1v4.ASM):01014             LDX     RAMVEC+4
E5DC 6E84             (                  monitor1v4.ASM):01015             JMP     0,X
                      (                  monitor1v4.ASM):01016 ;
                      (                  monitor1v4.ASM):01017 ;  Will have only PC and CC's pushed unless we were waiting for an interrupt
                      (                  monitor1v4.ASM):01018 ;  or MD.1 is true.  Use CC's E bit to distinguish.
                      (                  monitor1v4.ASM):01019 ;  Push all registers here for common entry (else we can't use our RAM vector)
E5DE B7DF15           (                  monitor1v4.ASM):01020 FIRQ_ENT    STA     REG_A                       ; SAVE A REG
E5E1 3502             (                  monitor1v4.ASM):01021             PULS    A                           ; GET CC'S FROM STACK
E5E3 8580             (                  monitor1v4.ASM):01022             BITA    #E
E5E5 2629             (                  monitor1v4.ASM):01023             BNE     FIRQ9                       ; BR IF ALL REGISTERS PUSHED ALREADY
                      (                  monitor1v4.ASM):01024 
                      (                  monitor1v4.ASM):01025 ; CC.E was not set which means that regMD bit2 was not set and that bit in
                      (                  monitor1v4.ASM):01026 ; the image should be cleared. If CC.E is set, we can't tell what set it, a
                      (                  monitor1v4.ASM):01027 ; direct command, CWAI, or bit 1 of regMD.
                      (                  monitor1v4.ASM):01028 ;
                      (                  monitor1v4.ASM):01029 ; Push registers as if CC.E had been set
                      (                  monitor1v4.ASM):01030 ;  If 6809 mode, stack needs CC A B DP XH XL YH YL UH UL PCH PCL
                      (                  monitor1v4.ASM):01031 ;  If 6309 mode, stack needs CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      (                  monitor1v4.ASM):01032 ;
E5E7 7FDF05           (                  monitor1v4.ASM):01033             CLR     E_FLAG
E5EA B6DF18           (                  monitor1v4.ASM):01034             LDA     REG_MD
E5ED 84FD             (                  monitor1v4.ASM):01035             ANDA    #$FD                        ; BIT1 must be clear, else all regs would have been pushed
E5EF B7DF18           (                  monitor1v4.ASM):01036             STA     REG_MD
E5F2 3478             (                  monitor1v4.ASM):01037             PSHS    U,Y,X,DP                    ; push regs next below PC
                      (                  monitor1v4.ASM):01038 
E5F4 10B7DF12         (                  monitor1v4.ASM):01039             STW     REG_F                       ; MD_TEST will not preserve regW
E5F8 BDE639           (                  monitor1v4.ASM):01040             JSR     MD_TEST
E5FB 3401             (                  monitor1v4.ASM):01041             PSHS    CC                          ; Save result
E5FD 10B6DF12         (                  monitor1v4.ASM):01042             LDW     REG_F                       ; Recover regW
E601 3501             (                  monitor1v4.ASM):01043             PULS    CC                          ; Recover result of test
E603 2602             (                  monitor1v4.ASM):01044             BNE     FE1
E605 1038             (                  monitor1v4.ASM):01045             PSHSW
E607 3404             (                  monitor1v4.ASM):01046 FE1         PSHS    B
E609 F6DF15           (                  monitor1v4.ASM):01047             LDB     REG_A
E60C 3404             (                  monitor1v4.ASM):01048             PSHS    B
E60E 8A80             (                  monitor1v4.ASM):01049             ORA     #E                          ; SET AS "ALL REGS PUSHED"
                      (                  monitor1v4.ASM):01050 
E610 7DDF05           (                  monitor1v4.ASM):01051 FIRQ9       TST     E_FLAG
E613 2608             (                  monitor1v4.ASM):01052             BNE     FIRQ9B
E615 F6DF18           (                  monitor1v4.ASM):01053             LDB     REG_MD                      ; We got here with E_FLAG clear and CC.E set which
E618 CA02             (                  monitor1v4.ASM):01054             ORB     #2                          ; means regMD bit2 must be set.
E61A F7DF18           (                  monitor1v4.ASM):01055             STB     REG_MD
E61D 3402             (                  monitor1v4.ASM):01056 FIRQ9B      PSHS    A                           ; REPLACE CC'S
E61F 8604             (                  monitor1v4.ASM):01057             LDA     #4
E621 BEDE8D           (                  monitor1v4.ASM):01058             LDX     RAMVEC+6
E624 6E84             (                  monitor1v4.ASM):01059             JMP     0,X
                      (                  monitor1v4.ASM):01060 ;
E626 8603             (                  monitor1v4.ASM):01061 IRQ_ENT     LDA     #3
E628 BEDE8F           (                  monitor1v4.ASM):01062             LDX     RAMVEC+8
E62B 6E84             (                  monitor1v4.ASM):01063             JMP     0,X
                      (                  monitor1v4.ASM):01064 ;
E62D 8602             (                  monitor1v4.ASM):01065 NMI_ENT     LDA     #2
E62F BEDE93           (                  monitor1v4.ASM):01066             LDX     RAMVEC+12
E632 6E84             (                  monitor1v4.ASM):01067             JMP     0,X
                      (                  monitor1v4.ASM):01068 ;
E634 8601             (                  monitor1v4.ASM):01069 SWI_ENT     LDA     #1
E636 7EE33E           (                  monitor1v4.ASM):01070             JMP     INT_ENTRY
                      (                  monitor1v4.ASM):01071 ;
                      (                  monitor1v4.ASM):01072 ;============================================================================
                      (                  monitor1v4.ASM):01073 ; TEST FOR BIT0 OF regMD:
                      (                  monitor1v4.ASM):01074 ; Exit emulation mode: regW=$1234
                      (                  monitor1v4.ASM):01075 ;      native    mode: regW=$0000
                      (                  monitor1v4.ASM):01076 ;
                      (                  monitor1v4.ASM):01077 ; Preserves W and V.  Other registers destroyed.
                      (                  monitor1v4.ASM):01078 ;
                      (                  monitor1v4.ASM):01079 MD_TEST     
E639 1038             (                  monitor1v4.ASM):01080         PSHSW
                      (                  monitor1v4.ASM):01081 ;
                      (                  monitor1v4.ASM):01082 ; If 6809 mode, RTI will pop 12 bytes: CC A B DP XH XL YH YL UH UL PCH PCL
                      (                  monitor1v4.ASM):01083 ; If 6309 mode, RTI will pop 14 bytes: CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      (                  monitor1v4.ASM):01084 ;
                      (                  monitor1v4.ASM):01085 ; Initialize TEST_STACK used for fake RTI. The return address will be MD_RETURN
                      (                  monitor1v4.ASM):01086 ; in both emulation and native modes. If native mode, regW will be cleared.
                      (                  monitor1v4.ASM):01087 ;
E63B 8EDEF7           (                  monitor1v4.ASM):01088         LDX     #TEST_STACK
                      (                  monitor1v4.ASM):01089 
E63E 8680             (                  monitor1v4.ASM):01090         LDA     #$80
E640 A780             (                  monitor1v4.ASM):01091         STA     ,X+                             ; CC with E set
                      (                  monitor1v4.ASM):01092 
E642 C609             (                  monitor1v4.ASM):01093         LDB     #9
E644 6F80             (                  monitor1v4.ASM):01094 RES11   CLR     ,X+                             ; zeros for other registers, including W
E646 5A               (                  monitor1v4.ASM):01095         DECB
E647 26FB             (                  monitor1v4.ASM):01096         BNE     RES11
                      (                  monitor1v4.ASM):01097 
E649 CCE65D           (                  monitor1v4.ASM):01098         LDD     #MD_RETURN
E64C ED81             (                  monitor1v4.ASM):01099         STD     ,X++                            ; 6809 return address, or 6309 U
E64E ED81             (                  monitor1v4.ASM):01100         STD     ,X++                            ; 6309 return address, or past 6809 stack
                      (                  monitor1v4.ASM):01101 
E650 10FFDF06         (                  monitor1v4.ASM):01102         STS     S_IMAGE
E654 10CEDEF7         (                  monitor1v4.ASM):01103         LDS     #TEST_STACK
E658 10861234         (                  monitor1v4.ASM):01104         LDW     #$1234
E65C 3B               (                  monitor1v4.ASM):01105         RTI                                                             ; if 6309 mode, W gets 0; else unchanged
                      (                  monitor1v4.ASM):01106 
                      (                  monitor1v4.ASM):01107 MD_RETURN   
E65D 10FEDF06         (                  monitor1v4.ASM):01108         LDS     S_IMAGE
E661 105D             (                  monitor1v4.ASM):01109         TSTW                            ; adjust CC.Z: set if 6309 mode
E663 1039             (                  monitor1v4.ASM):01110         PULSW
E665 39               (                  monitor1v4.ASM):01111         RTS
                      (                  monitor1v4.ASM):01112                 
                      (                  monitor1v4.ASM):01113 ;;======================================================================
                      (                  monitor1v4.ASM):01114 ;; BEGINNING OF PLATFORM DEPENDENT UTILITY FUNCTIONS
                      (                  monitor1v4.ASM):01115 ;;======================================================================
                      (                  monitor1v4.ASM):01116 
                      (                  monitor1v4.ASM):01117 ;; ZILOG CIO INIT Function
                      (                  monitor1v4.ASM):01118 ;; necessary to put the Z8536 CIO into a known state
                      (                  monitor1v4.ASM):01119 CIO_INIT
E666 B6E003           (                  monitor1v4.ASM):01120                 LDA     CIOCTL          ; reset the chip to a known state and then clear the reset                      
E669 8D1C             (                  monitor1v4.ASM):01121                 BSR     ZI?                     ; a read will force the z8536 into state 0 if in state 1, otherwise it will     
                      (                  monitor1v4.ASM):01122                                                 ; not cause any changes                                                                                                                                    
E66B 4F               (                  monitor1v4.ASM):01123         CLRA                    ; if the z8536 was reset, writing a 0 will force it into state 0. if in         
E66C B7E003           (                  monitor1v4.ASM):01124                 STA     CIOCTL          ; state 0, this will set the pointer to register 0 and go to state 1.           
E66F 8D16             (                  monitor1v4.ASM):01125                 BSR     ZI?
E671 B6E003           (                  monitor1v4.ASM):01126                 LDA     CIOCTL          ; another read operation will force the 8536 into state 0, from where further   
E674 8D11             (                  monitor1v4.ASM):01127                 BSR     ZI?                     ; instructions can be done                                                      
E676 4F               (                  monitor1v4.ASM):01128         CLRA            ; set address pointer to master interrupt control register (addr 0)             
E677 B7E003           (                  monitor1v4.ASM):01129                 STA     CIOCTL                                                                                          
E67A 8D0B             (                  monitor1v4.ASM):01130                 BSR     ZI?
E67C 8601             (                  monitor1v4.ASM):01131                 LDA     #1                      ; reset the z8536 by enabling the reset bit (b0)                                
E67E B7E003           (                  monitor1v4.ASM):01132                 STA     CIOCTL                                                                                              
E681 8D04             (                  monitor1v4.ASM):01133                 BSR     ZI?                     ; next, by writing a 0 to register 0 during reset, the reset will be cleared.   
E683 4F               (                  monitor1v4.ASM):01134                 CLRA                    ; successive writes can only be done during reset (during normal operation,             
E684 B7E003           (                  monitor1v4.ASM):01135                 STA     CIOCTL      ; successive writes will change the address pointer to that output value).                                                                                      
E687 12               (                  monitor1v4.ASM):01136 ZI?             NOP
E688 12               (                  monitor1v4.ASM):01137                 NOP
E689 12               (                  monitor1v4.ASM):01138                 NOP
E68A 39               (                  monitor1v4.ASM):01139                 RTS             
                      (                  monitor1v4.ASM):01140 ;;
                      (                  monitor1v4.ASM):01141 ;; ZILOG CIOCTL READ Function
                      (                  monitor1v4.ASM):01142 ;; On Entry:    A = register number to read (0...3F)
                      (                  monitor1v4.ASM):01143 ;; On exit:     B = value from register                 
                      (                  monitor1v4.ASM):01144 ;;
                      (                  monitor1v4.ASM):01145 CIO_READ
E68B F6E003           (                  monitor1v4.ASM):01146                 LDB             CIOCTL                  ; read CIO control register to get to state 0
E68E 843F             (                  monitor1v4.ASM):01147                 ANDA    #$3F                    ; make sure register value is in range                                           
E690 B7E003           (                  monitor1v4.ASM):01148                 STA             CIOCTL                  ; set the address pointer to the desired register                   
E693 F6E003           (                  monitor1v4.ASM):01149                 LDB             CIOCTL                  ; read the contents of the register                                 
E696 39               (                  monitor1v4.ASM):01150                 RTS
                      (                  monitor1v4.ASM):01151 ;;
                      (                  monitor1v4.ASM):01152 ;; ZILOG CIOCTL WRITE Function
                      (                  monitor1v4.ASM):01153 ;; On Entry:    A = register number to read (0...3F)
                      (                  monitor1v4.ASM):01154 ;;                      B = value to write to register
                      (                  monitor1v4.ASM):01155 ;;
                      (                  monitor1v4.ASM):01156 CIO_WRITE
E697 3404             (                  monitor1v4.ASM):01157                 PSHS    B                               ; preserve value to write
E699 F6E003           (                  monitor1v4.ASM):01158                 LDB     CIOCTL                  ; read CIO control register to get to state 0
E69C 843F             (                  monitor1v4.ASM):01159         ANDA    #$3F            ; make sure it's in range                                           
E69E B7E003           (                  monitor1v4.ASM):01160         STA     CIOCTL          ; set the address pointer to the desired register                   
E6A1 3504             (                  monitor1v4.ASM):01161                 PULS    B                               ; restore value to write        
E6A3 F7E003           (                  monitor1v4.ASM):01162                 STB             CIOCTL
E6A6 39               (                  monitor1v4.ASM):01163                 RTS
                      (                  monitor1v4.ASM):01164 
                      (                  monitor1v4.ASM):01165 ;;
                      (                  monitor1v4.ASM):01166 ;; SCC CHANNEL A I/O FUNCTIONS
                      (                  monitor1v4.ASM):01167 ;; These are hardcoded to channel A, intended for console use
                      (                  monitor1v4.ASM):01168 
                      (                  monitor1v4.ASM):01169 ;; GETBYTE - acquire an ASCII HEX byte from UART A and return in A
                      (                  monitor1v4.ASM):01170 ;; CY=1 means input was valid, byte value in A
                      (                  monitor1v4.ASM):01171 ;; CY=0 means input was non-ASII HEX, A is destroyed
E6A7 8D13             (                  monitor1v4.ASM):01172 GETBYTE BSR             GETNIB                  ; Get FIRST nibble
E6A9 2410             (                  monitor1v4.ASM):01173                 BCC             GETB1?                  ; Invalid, abort (CY=0)
E6AB 48               (                  monitor1v4.ASM):01174                 LSLA                                    ; Rotate
E6AC 48               (                  monitor1v4.ASM):01175                 LSLA                                    ; into
E6AD 48               (                  monitor1v4.ASM):01176                 LSLA                                    ; high
E6AE 48               (                  monitor1v4.ASM):01177                 LSLA                                    ; nibble
E6AF 3402             (                  monitor1v4.ASM):01178                 PSHS    A                               ; Save for later
E6B1 8D09             (                  monitor1v4.ASM):01179                 BSR             GETNIB                  ; Get SECOND nibble
E6B3 2404             (                  monitor1v4.ASM):01180                 BCC             GETB2?                  ; Report error (CY=0)
E6B5 AAE4             (                  monitor1v4.ASM):01181                 ORA             ,S                              ; Include high
E6B7 1A01             (                  monitor1v4.ASM):01182                 ORCC    #C                              ; Indicate success (CY=1)
E6B9 3261             (                  monitor1v4.ASM):01183 GETB2?  LEAS    1,S                             ; Skip saved value
E6BB 39               (                  monitor1v4.ASM):01184 GETB1?  RTS
                      (                  monitor1v4.ASM):01185                 
                      (                  monitor1v4.ASM):01186 ;; GETBIN - acquire an ASCII HEX nibble from UART A and return in A
                      (                  monitor1v4.ASM):01187 ;; CY=1 means input was valid, nibble value in A
                      (                  monitor1v4.ASM):01188 ;; CY=0 means input was non-ASII HEX, A is restored
E6BC BDE2A9           (                  monitor1v4.ASM):01189 GETNIB  JSR             GETA                    ; get a character
E6BF 8030             (                  monitor1v4.ASM):01190                 SUBA    #'0'                    ; Convert numbers
E6C1 8109             (                  monitor1v4.ASM):01191                 CMPA    #9                              ; Numeric?
E6C3 230A             (                  monitor1v4.ASM):01192                 BLS             GETN1?                  ; Yes, OK
E6C5 8007             (                  monitor1v4.ASM):01193                 SUBA    #7                              ; Convert alphas
E6C7 810A             (                  monitor1v4.ASM):01194                 CMPA    #$A                             ; Under?
E6C9 2507             (                  monitor1v4.ASM):01195                 BLO             GETN2?                  ; Yes, error
E6CB 810F             (                  monitor1v4.ASM):01196                 CMPA    #$F                             ; Over?
E6CD 2203             (                  monitor1v4.ASM):01197                 BHI             GETN2?                  ; Yes, error (C and Z both clear)
E6CF 1A01             (                  monitor1v4.ASM):01198 GETN1?  ORCC    #C                              ; SET 'C' FLAG, INDICATE OK
E6D1 39               (                  monitor1v4.ASM):01199                 RTS
E6D2 8B37             (                  monitor1v4.ASM):01200 GETN2?  ADDA    #$37                    ; Normalize character 
E6D4 1CFE             (                  monitor1v4.ASM):01201                 ANDCC   #~C                             ; clear C to indicate non-hex input
E6D6 39               (                  monitor1v4.ASM):01202                 RTS
                      (                  monitor1v4.ASM):01203                 
                      (                  monitor1v4.ASM):01204 ;; PUTWORD - output D as ASCII HEX WORD to UART A
E6D7 8D02             (                  monitor1v4.ASM):01205 PUTWORD BSR     PUTBYTE                         ; Output first byte
E6D9 1F98             (                  monitor1v4.ASM):01206                 TFR     B,A                                     ; Get second byte
                      (                  monitor1v4.ASM):01207                                                     ; fall into PUTBYTE
                      (                  monitor1v4.ASM):01208                 
                      (                  monitor1v4.ASM):01209 ;; PUTBYTE - output A as ASCII HEX BYTE to UART A
E6DB 3402             (                  monitor1v4.ASM):01210 PUTBYTE PSHS    A                               ; Save low nibble
E6DD 44               (                  monitor1v4.ASM):01211                 LSRA                                    ; Rotate
E6DE 44               (                  monitor1v4.ASM):01212                 LSRA                                    ; upper nibble
E6DF 44               (                  monitor1v4.ASM):01213                 LSRA                                    ; into
E6E0 44               (                  monitor1v4.ASM):01214                 LSRA                                    ; lower nibble
E6E1 8D02             (                  monitor1v4.ASM):01215                 BSR             PUTHEX                  ; Output high nibble
E6E3 3502             (                  monitor1v4.ASM):01216                 PULS    A                               ; Rertore low nibble
                      (                  monitor1v4.ASM):01217                                                                 ; fall into PUTHEX
                      (                  monitor1v4.ASM):01218                 
                      (                  monitor1v4.ASM):01219 ;; PUTHEX - output A as ASCII HEX NIBBLE to UART A
E6E5 840F             (                  monitor1v4.ASM):01220 PUTHEX  ANDA    #$0F                    ; Remove upper half
E6E7 8B30             (                  monitor1v4.ASM):01221                 ADDA    #'0'                    ; Convert to printable
E6E9 8139             (                  monitor1v4.ASM):01222                 CMPA    #'9'                    ; In range?
E6EB 2302             (                  monitor1v4.ASM):01223                 BLS             PH1                             ; Yes, display
E6ED 8B07             (                  monitor1v4.ASM):01224                 ADDA    #7                              ; Convert to alpha
E6EF 7EE2CA           (                  monitor1v4.ASM):01225 PH1             JMP             PUTA                    ; exit via PUTA
                      (                  monitor1v4.ASM):01226                 
                      (                  monitor1v4.ASM):01227 ;; PUTCR - output CRLF to UART A
E6F2 860D             (                  monitor1v4.ASM):01228 PUTCR   LDA             #$0D                    ; output a carriage return
E6F4 BDE2CA           (                  monitor1v4.ASM):01229                 JSR             PUTA            ; 
E6F7 860A             (                  monitor1v4.ASM):01230                 LDA             #$0A                    ; output a line feed
E6F9 20F4             (                  monitor1v4.ASM):01231                 BRA             PH1                             ; exit via PUTA
                      (                  monitor1v4.ASM):01232                 
                      (                  monitor1v4.ASM):01233 ;; PUTMSG - output NULL/FF terminated string at PC to UART A
                      (                  monitor1v4.ASM):01234 ;; terminate with either 0, or $FF (CRLF before terminates)                                                       
E6FB 3410             (                  monitor1v4.ASM):01235 PUTMSG  PSHS    X                               ; save x                                     
E6FD AE62             (                  monitor1v4.ASM):01236                 LDX             2,S                             ; get old pc                                 
E6FF 8D04             (                  monitor1v4.ASM):01237                 BSR             PUTSTR                  ; output string
E701 AF62             (                  monitor1v4.ASM):01238                 STX             2,S                             ; update old pc                              
E703 3590             (                  monitor1v4.ASM):01239                 PULS    X,PC                    ; restore x, return                          
                      (                  monitor1v4.ASM):01240                 
                      (                  monitor1v4.ASM):01241 ;; PUTSTR - output NULL/FF terminated string at X to UART A
                      (                  monitor1v4.ASM):01242 ;; terminate with either 0, or $FF (CRLF before terminates)                                                       
E705 A680             (                  monitor1v4.ASM):01243 PUTSTR  LDA             ,X+                             ; get char from message                      
E707 2709             (                  monitor1v4.ASM):01244                 BEQ             PSTRX?                  ;       0 = end
E709 81FF             (                  monitor1v4.ASM):01245                 CMPA    #$FF                    ; FF = newline end?
E70B 27E5             (                  monitor1v4.ASM):01246                 BEQ             PUTCR                   ;       yes, new line, exit via PUTCR
E70D BDE2CA           (                  monitor1v4.ASM):01247                 JSR             PUTA                    ; output character to term                             
E710 20F3             (                  monitor1v4.ASM):01248                 BRA             PUTSTR                  ; keep going                                 
E712 39               (                  monitor1v4.ASM):01249 PSTRX?  RTS                                                              
                      (                  monitor1v4.ASM):01250 
                      (                  monitor1v4.ASM):01251 ;;
                      (                  monitor1v4.ASM):01252 ;; MACHINE SPECIFIC SOFT I2C ROUTINES 
                      (                  monitor1v4.ASM):01253 
                      (                  monitor1v4.ASM):01254 ;; READ REG     == [START], ADDR, [ack], <REG ADDR>, [ack], [START], ADDR, [ack], <read data>, [ACK], [STOP]
                      (                  monitor1v4.ASM):01255 ;; WRITE REG    == [START], ADDR, [ack], <REG ADDR>, [ack], <WRITE DATA>, [ack], [STOP]
                      (                  monitor1v4.ASM):01256 ;; READ MULTI   == [START], ADDR, [ack], <REG ADDR>, [ack], [START], ADDR, [ack], <read data>, [ACK], <read data>, [ACK], ... [STOP]
                      (                  monitor1v4.ASM):01257 ;; WRITE MULTI  == [START], ADDR, [ack], <REG ADDR>, [ack], <WRITE DATA>, [ack], <WRITE DATA>, [ack], ... [STOP]
                      (                  monitor1v4.ASM):01258 
                      (                  monitor1v4.ASM):01259 ;; I2C low-level routines
                      (                  monitor1v4.ASM):01260 
                      (                  monitor1v4.ASM):01261 ;; I2C status flags
     0000             (                  monitor1v4.ASM):01262 I2C_Success                     EQU     0
     0001             (                  monitor1v4.ASM):01263 I2C_NoSlaveAck          EQU 1
     0002             (                  monitor1v4.ASM):01264 I2C_BusError            EQU     2
                      (                  monitor1v4.ASM):01265 
                      (                  monitor1v4.ASM):01266 ;; I2C Acknowledge Constants
     0001             (                  monitor1v4.ASM):01267 I2C_ACKNOWLEDGE         EQU     1
     0000             (                  monitor1v4.ASM):01268 I2C_NOTACKNOWLEDGE      EQU     0
                      (                  monitor1v4.ASM):01269 
     00D0             (                  monitor1v4.ASM):01270 RTC_I2C_ADDR    EQU     $D0
                      (                  monitor1v4.ASM):01271 
                      (                  monitor1v4.ASM):01272 ;; I2C interface primitives - hardware dependent
                      (                  monitor1v4.ASM):01273 SDAStatus       MACRO 
                      (                  monitor1v4.ASM):01274                 TIM   #I2C.MSDA,I2CPORT         ;I2C.SDAStatus (Z = 1 if SDA is low)
                      (                  monitor1v4.ASM):01275                         ENDM
                      (                  monitor1v4.ASM):01276 
                      (                  monitor1v4.ASM):01277 SetSDALow       MACRO 
                      (                  monitor1v4.ASM):01278                 AIM   #~I2C.DSDA,I2CPORT        ;I2C.SetSDALow
                      (                  monitor1v4.ASM):01279                         ENDM
                      (                  monitor1v4.ASM):01280 
                      (                  monitor1v4.ASM):01281 SetSDAHigh      MACRO 
                      (                  monitor1v4.ASM):01282                 OIM       #I2C.DSDA,I2CPORT             ;I2C.SetSDAHigh
                      (                  monitor1v4.ASM):01283                         ENDM
                      (                  monitor1v4.ASM):01284         
                      (                  monitor1v4.ASM):01285 SCLStatus       MACRO 
                      (                  monitor1v4.ASM):01286                 TIM   #I2C.MSCL,I2CPORT         ;I2C.SCKStatus (Z = 1 if SCK is low)
                      (                  monitor1v4.ASM):01287                         ENDM
                      (                  monitor1v4.ASM):01288 
                      (                  monitor1v4.ASM):01289 SetSCLLow       MACRO 
                      (                  monitor1v4.ASM):01290                 AIM   #~I2C.DSCL,I2CPORT        ;I2C.SetSCLLow
                      (                  monitor1v4.ASM):01291                         ENDM
                      (                  monitor1v4.ASM):01292 
                      (                  monitor1v4.ASM):01293 SetSCLHigh      MACRO 
                      (                  monitor1v4.ASM):01294                 OIM       #I2C.DSCL,I2CPORT             ;I2C.SetSCLHigh
                      (                  monitor1v4.ASM):01295                         ENDM
                      (                  monitor1v4.ASM):01296 
                      (                  monitor1v4.ASM):01297 SetBothHigh MACRO
                      (                  monitor1v4.ASM):01298                 OIM       #(I2C.DSCL+I2C.DSDA),I2CPORT          ;set both SDA and SCL high
                      (                  monitor1v4.ASM):01299                         ENDM
                      (                  monitor1v4.ASM):01300 
                      (                  monitor1v4.ASM):01301 StretchSCLHigh  MACRO 
                      (                  monitor1v4.ASM):01302 I?SSH                   NOP
                      (                  monitor1v4.ASM):01303                                 SetSCLHigh      ; try to release SCL
                      (                  monitor1v4.ASM):01304                                 NOP
                      (                  monitor1v4.ASM):01305                                 SCLStatus               ; check is SCL is really high yet
                      (                  monitor1v4.ASM):01306                                 BEQ       I?SSH         ; if Z set, SCL is still low -> try again
                      (                  monitor1v4.ASM):01307                                 ENDM
                      (                  monitor1v4.ASM):01308 
                      (                  monitor1v4.ASM):01309 ;; I2C_Initialize - cycle SCK until SDA goes high, up to 255 times 
                      (                  monitor1v4.ASM):01310 ;; This is per the DS3232M datasheet to re-sync communication.
                      (                  monitor1v4.ASM):01311 ;; inputs: none
                      (                  monitor1v4.ASM):01312 ;; return: A = number of SCL cycles required (255 = fault)
                      (                  monitor1v4.ASM):01313 I2C_Initialize
E713 4F               (                  monitor1v4.ASM):01314                 CLRA                                                    ; clear cycle counter
E714 BDE7A1           (                  monitor1v4.ASM):01315 IN0?    JSR             I2C_SendNAK                             ; do a NAK cycle (toggles SCL with SDA high), SDA status in Z
E717 2609             (                  monitor1v4.ASM):01316                 BNE             I2C_SendStop                    ; SDA is high, so all is well, return via SendStop
E719 4C               (                  monitor1v4.ASM):01317                 INCA                                                    ; increment cycle counter
E71A 26F8             (                  monitor1v4.ASM):01318                 BNE             IN0?                                    ; not wrapped to '0' yet, keep trying
                      (                  monitor1v4.ASM):01319                 SetBothHigh                                     ; failed: release both SCL and SDA              
E71C 71C0E020         (                     SetBothHigh):00001                 OIM       #(I2C.DSCL+I2C.DSDA),I2CPORT          ;set both SDA and SCL high
E720 4A               (                  monitor1v4.ASM):01320                 DECA                                                    ; decrement counter back to 255
E721 39               (                  monitor1v4.ASM):01321                 RTS
                      (                  monitor1v4.ASM):01322 
                      (                  monitor1v4.ASM):01323 ;; I2C_SendStop - send a STOP condition
                      (                  monitor1v4.ASM):01324 ;; inputs: none
                      (                  monitor1v4.ASM):01325 ;; return: none
                      (                  monitor1v4.ASM):01326 I2C_SendStop
                      (                  monitor1v4.ASM):01327         SetSDALow                                               ; SCL high followed by SDA high is STOP condition
E722 72BFE020         (                       SetSDALow):00001                 AIM   #~I2C.DSDA,I2CPORT        ;I2C.SetSDALow
                      (                  monitor1v4.ASM):01328                 StretchSCLHigh
E726 12               (                  StretchSCLHigh):00001 I?SSH                   NOP
                      (                  StretchSCLHigh):00002                                 SetSCLHigh      ; try to release SCL
E727 7180E020         (                      SetSCLHigh):00001                 OIM       #I2C.DSCL,I2CPORT             ;I2C.SetSCLHigh
E72B 12               (                  StretchSCLHigh):00003                                 NOP
                      (                  StretchSCLHigh):00004                                 SCLStatus               ; check is SCL is really high yet
E72C 7B08E020         (                       SCLStatus):00001                 TIM   #I2C.MSCL,I2CPORT         ;I2C.SCKStatus (Z = 1 if SCK is low)
E730 27F4             (                  StretchSCLHigh):00005                                 BEQ       I?SSH         ; if Z set, SCL is still low -> try again
E732 8D04             (                  monitor1v4.ASM):01329                 BSR             I2C_BitDelay
                      (                  monitor1v4.ASM):01330                 SetSDAHigh              
E734 7140E020         (                      SetSDAHigh):00001                 OIM       #I2C.DSDA,I2CPORT             ;I2C.SetSDAHigh
                      (                  monitor1v4.ASM):01331                 ; fall into BitDelay...         
                      (                  monitor1v4.ASM):01332 
                      (                  monitor1v4.ASM):01333 ;; I2C_BitDelay - ensures minimum high and low clock times on I2C bus. 
                      (                  monitor1v4.ASM):01334 ;; no input parameters
                      (                  monitor1v4.ASM):01335 ;; no return value
                      (                  monitor1v4.ASM):01336 I2C_BitDelay
E738 12               (                  monitor1v4.ASM):01337                 NOP
E739 12               (                  monitor1v4.ASM):01338                 NOP
E73A 12               (                  monitor1v4.ASM):01339                 NOP
E73B 12               (                  monitor1v4.ASM):01340                 NOP
E73C 12               (                  monitor1v4.ASM):01341                 NOP
E73D 12               (                  monitor1v4.ASM):01342                 NOP
E73E 39               (                  monitor1v4.ASM):01343         RTS                                                               
                      (                  monitor1v4.ASM):01344 
                      (                  monitor1v4.ASM):01345 ;; I2C_SendByte - sends one byte of data to an I2C slave device and check for Slave ACK
                      (                  monitor1v4.ASM):01346 ;; inputs: A = byte to send to slave
                      (                  monitor1v4.ASM):01347 ;; return: A = byte sent to slave, Z = 1 if slave ACK
                      (                  monitor1v4.ASM):01348 I2C_SendByte
E73F 3406             (                  monitor1v4.ASM):01349                 PSHS    A,B                                             ; preserve ACC A and B
E741 C608             (                  monitor1v4.ASM):01350                 LDB             #8                                              ; init B as loop counter
                      (                  monitor1v4.ASM):01351 SB0?    SetSDAHigh                                              ; assume data bit is '1'
E743 7140E020         (                      SetSDAHigh):00001                 OIM       #I2C.DSDA,I2CPORT             ;I2C.SetSDAHigh
E747 4D               (                  monitor1v4.ASM):01352                 TSTA                                                    ; examine ACC A bits
E748 2B04             (                  monitor1v4.ASM):01353                 BMI             SB1?                                    ; if MSB is clear (positive value)...
                      (                  monitor1v4.ASM):01354                 SetSDALow                                               ; clear data bit to '0'
E74A 72BFE020         (                       SetSDALow):00001                 AIM   #~I2C.DSDA,I2CPORT        ;I2C.SetSDALow
                      (                  monitor1v4.ASM):01355 SB1?    StretchSCLHigh                                  ; release SCL, wait for stretch
E74E 12               (                  StretchSCLHigh):00001 I?SSH                   NOP
                      (                  StretchSCLHigh):00002                                 SetSCLHigh      ; try to release SCL
E74F 7180E020         (                      SetSCLHigh):00001                 OIM       #I2C.DSCL,I2CPORT             ;I2C.SetSCLHigh
E753 12               (                  StretchSCLHigh):00003                                 NOP
                      (                  StretchSCLHigh):00004                                 SCLStatus               ; check is SCL is really high yet
E754 7B08E020         (                       SCLStatus):00001                 TIM   #I2C.MSCL,I2CPORT         ;I2C.SCKStatus (Z = 1 if SCK is low)
E758 27F4             (                  StretchSCLHigh):00005                                 BEQ       I?SSH         ; if Z set, SCL is still low -> try again
E75A 8DDC             (                  monitor1v4.ASM):01356                 BSR             I2C_BitDelay                    ; half-bit delay
                      (                  monitor1v4.ASM):01357                 SetSCLLow                                               ; drive SCL low
E75C 727FE020         (                       SetSCLLow):00001                 AIM   #~I2C.DSCL,I2CPORT        ;I2C.SetSCLLow
E760 8DD6             (                  monitor1v4.ASM):01358                 BSR             I2C_BitDelay                    ; half-bit delay
E762 48               (                  monitor1v4.ASM):01359                 LSLA                                                    ; shift ACC A to expose next bit to send
E763 5A               (                  monitor1v4.ASM):01360                 DECB                                                    ; decrement loop counter
E764 26DD             (                  monitor1v4.ASM):01361                 BNE             SB0?                                    ; loop back until all bits are sent
E766 3506             (                  monitor1v4.ASM):01362                 PULS    A,B                             ; restore ACC A and B
                      (                  monitor1v4.ASM):01363                 SDAStatus                                               ; get ACK/NAK status into Z
E768 7B04E020         (                       SDAStatus):00001                 TIM   #I2C.MSDA,I2CPORT         ;I2C.SDAStatus (Z = 1 if SDA is low)
E76C 39               (                  monitor1v4.ASM):01364                 RTS
                      (                  monitor1v4.ASM):01365 
                      (                  monitor1v4.ASM):01366 ;; sI2C_RcvByte - receives one byte of data from an I2C slave device, with
                      (                  monitor1v4.ASM):01367 ;;                the ability to control NAK or ACK of the received data
                      (                  monitor1v4.ASM):01368 ;; inputs: A = 0 --> NAK, otherwise ACK
                      (                  monitor1v4.ASM):01369 ;; return: A = byte received from slave
                      (                  monitor1v4.ASM):01370 I2C_RcvByte
E76D 3424             (                  monitor1v4.ASM):01371                 PSHS    B,Y                                             ; preserve B and Y
E76F 1F89             (                  monitor1v4.ASM):01372                 TFR             A,B                                             ; copy ACC A to B (to save ACK/NAK status)
E771 108E0008         (                  monitor1v4.ASM):01373                 LDY             #8                                              ; init E as loop counter
E775 4F               (                  monitor1v4.ASM):01374                 CLRA                                                    ; clear A before shifting in bits               
                      (                  monitor1v4.ASM):01375 RB0?    StretchSCLHigh                                  ; release SCL, wait for stretch
E776 12               (                  StretchSCLHigh):00001 I?SSH                   NOP
                      (                  StretchSCLHigh):00002                                 SetSCLHigh      ; try to release SCL
E777 7180E020         (                      SetSCLHigh):00001                 OIM       #I2C.DSCL,I2CPORT             ;I2C.SetSCLHigh
E77B 12               (                  StretchSCLHigh):00003                                 NOP
                      (                  StretchSCLHigh):00004                                 SCLStatus               ; check is SCL is really high yet
E77C 7B08E020         (                       SCLStatus):00001                 TIM   #I2C.MSCL,I2CPORT         ;I2C.SCKStatus (Z = 1 if SCK is low)
E780 27F4             (                  StretchSCLHigh):00005                                 BEQ       I?SSH         ; if Z set, SCL is still low -> try again
E782 8DB4             (                  monitor1v4.ASM):01376                 BSR             I2C_BitDelay                    ; half-bit delay
                      (                  monitor1v4.ASM):01377                 SDAStatus                                               ; check SDA pin (Z = 1 if low)
E784 7B04E020         (                       SDAStatus):00001                 TIM   #I2C.MSDA,I2CPORT         ;I2C.SDAStatus (Z = 1 if SDA is low)
E788 2702             (                  monitor1v4.ASM):01378                 BEQ             RB1?                                    ; if SDA is low, leave ACC A alone
E78A 8A80             (                  monitor1v4.ASM):01379                 ORA             #$80                                    ; otherwise, set MSB
                      (                  monitor1v4.ASM):01380 RB1?    SetSCLLow                                               ; clear SCL to end bit          
E78C 727FE020         (                       SetSCLLow):00001                 AIM   #~I2C.DSCL,I2CPORT        ;I2C.SetSCLLow
E790 8DA6             (                  monitor1v4.ASM):01381                 BSR             I2C_BitDelay                    ; half-bit delay
E792 313F             (                  monitor1v4.ASM):01382                 LEAY    -1,Y                                    ; decrement loop counter
E794 26E0             (                  monitor1v4.ASM):01383                 BNE             RB0?                                    ; loop back until all bits are received
E796 5D               (                  monitor1v4.ASM):01384                 TSTB                                                    ; examine B (to determine ACK/NAK status)
E797 3524             (                  monitor1v4.ASM):01385                 PULS    B,Y                                             ; restore B and E (no flags affected)
E799 2706             (                  monitor1v4.ASM):01386                 BEQ             I2C_SendNAK                             ; if input parameter was zero, send a NAK
                      (                  monitor1v4.ASM):01387                 ; fall into I2C_SendACK
                      (                  monitor1v4.ASM):01388 
                      (                  monitor1v4.ASM):01389 ;; I2C_SendNAK & SendACK - send a NAK or ACK to I2C slave device
                      (                  monitor1v4.ASM):01390 ;; inputs: none
                      (                  monitor1v4.ASM):01391 ;; return: ACK/NAK status in Z (Z = 1 if either slave or master ACK)
                      (                  monitor1v4.ASM):01392 I2C_SendACK
                      (                  monitor1v4.ASM):01393                 SetSDALow                               ; assert SDA for MASTER ACK
E79B 72BFE020         (                       SetSDALow):00001                 AIM   #~I2C.DSDA,I2CPORT        ;I2C.SetSDALow
E79F 2004             (                  monitor1v4.ASM):01394                 BRA             I2C_SN1                 ; otherwise same as sending NAK
                      (                  monitor1v4.ASM):01395 I2C_SendNAK
                      (                  monitor1v4.ASM):01396                 SetSDAHigh                              ; release SDA line for MASTER NAK / or query slave ACK
E7A1 7140E020         (                      SetSDAHigh):00001                 OIM       #I2C.DSDA,I2CPORT             ;I2C.SetSDAHigh
                      (                  monitor1v4.ASM):01397 I2C_SN1 StretchSCLHigh                  ; send clock for NAK
E7A5 12               (                  StretchSCLHigh):00001 I?SSH                   NOP
                      (                  StretchSCLHigh):00002                                 SetSCLHigh      ; try to release SCL
E7A6 7180E020         (                      SetSCLHigh):00001                 OIM       #I2C.DSCL,I2CPORT             ;I2C.SetSCLHigh
E7AA 12               (                  StretchSCLHigh):00003                                 NOP
                      (                  StretchSCLHigh):00004                                 SCLStatus               ; check is SCL is really high yet
E7AB 7B08E020         (                       SCLStatus):00001                 TIM   #I2C.MSCL,I2CPORT         ;I2C.SCKStatus (Z = 1 if SCK is low)
E7AF 27F4             (                  StretchSCLHigh):00005                                 BEQ       I?SSH         ; if Z set, SCL is still low -> try again
E7B1 8D85             (                  monitor1v4.ASM):01398                 BSR             I2C_BitDelay    ; half-bit delay
                      (                  monitor1v4.ASM):01399                 SDAStatus                               ; reflect SDA status in Z
E7B3 7B04E020         (                       SDAStatus):00001                 TIM   #I2C.MSDA,I2CPORT         ;I2C.SDAStatus (Z = 1 if SDA is low)
                      (                  monitor1v4.ASM):01400                 SetSCLLow                               ; finish the NAK bit
E7B7 727FE020         (                       SetSCLLow):00001                 AIM   #~I2C.DSCL,I2CPORT        ;I2C.SetSCLLow
E7BB 7EE738           (                  monitor1v4.ASM):01401                 JMP             I2C_BitDelay    ; return through half-bit delay
                      (                  monitor1v4.ASM):01402 
                      (                  monitor1v4.ASM):01403 ;; I2C_GoMaster - sends an I2C start and slave address and check for acknowledge
                      (                  monitor1v4.ASM):01404 ;; inputs: A = slave address A[7:1] + R/W A[0]
                      (                  monitor1v4.ASM):01405 ;; return: A = I2C.Success or I2C_NoSlaveAck or I2C.BusError (if SDA stuck low)
                      (                  monitor1v4.ASM):01406 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01407 I2C_GoMaster
                      (                  monitor1v4.ASM):01408                 SetBothHigh                             ; release SDA and SCL
E7BE 71C0E020         (                     SetBothHigh):00001                 OIM       #(I2C.DSCL+I2C.DSDA),I2CPORT          ;set both SDA and SCL high
E7C2 BDE738           (                  monitor1v4.ASM):01409                 JSR             I2C_BitDelay    ; allow SDA to float high
                      (                  monitor1v4.ASM):01410                 SDAStatus                               ; check SDA state
E7C5 7B04E020         (                       SDAStatus):00001                 TIM   #I2C.MSDA,I2CPORT         ;I2C.SDAStatus (Z = 1 if SDA is low)
E7C9 2619             (                  monitor1v4.ASM):01411                 BNE             GMBERR?                 ; if SDA is still low, return with fBusError
                      (                  monitor1v4.ASM):01412                 SetSDALow                               ; begin I2C START by bringing SDA low first
E7CB 72BFE020         (                       SetSDALow):00001                 AIM   #~I2C.DSDA,I2CPORT        ;I2C.SetSDALow
E7CF BDE738           (                  monitor1v4.ASM):01413                 JSR             I2C_BitDelay    ; half-bit delay                
                      (                  monitor1v4.ASM):01414                 SetSCLLow                               ; complete I2C START by bringing SCL low
E7D2 727FE020         (                       SetSCLLow):00001                 AIM   #~I2C.DSCL,I2CPORT        ;I2C.SetSCLLow
E7D6 BDE738           (                  monitor1v4.ASM):01415                 JSR             I2C_BitDelay    ; half-bit delay
E7D9 BDE73F           (                  monitor1v4.ASM):01416                 JSR             I2C_SendByte    ; now send the byte in A, Z = 1 means sent OK
E7DC 2603             (                  monitor1v4.ASM):01417                 BNE             GMSNAK?                 ; if no slave ACK, then return with fNoSlaveAck
E7DE 8600             (                  monitor1v4.ASM):01418                 LDA             #I2C_Success    ; send a fSuccess code (0) and set Z = 1
E7E0 39               (                  monitor1v4.ASM):01419                 RTS
E7E1 8601             (                  monitor1v4.ASM):01420 GMSNAK? LDA             #I2C_NoSlaveAck ; send a fNoSlaveAck code (1) and set Z = 0
E7E3 39               (                  monitor1v4.ASM):01421                 RTS
E7E4 8602             (                  monitor1v4.ASM):01422 GMBERR? LDA             #I2C_BusError   ; return a fBusError code (2) and set Z = 0
E7E6 39               (                  monitor1v4.ASM):01423                 RTS
                      (                  monitor1v4.ASM):01424 
                      (                  monitor1v4.ASM):01425 ;; RTC_WriteRegs - write registers 0-32 of the RTC 
                      (                  monitor1v4.ASM):01426 ;; inputs: RTCBUFPTR must contain the addr of write data buffer
                      (                  monitor1v4.ASM):01427 ;; return: A = I2C.Success or I2C.NoSlaveAck or I2C.BusError
                      (                  monitor1v4.ASM):01428 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01429 ;;                 Y is destroyed
                      (                  monitor1v4.ASM):01430 RTC_WriteRegs
E7E7 86D0             (                  monitor1v4.ASM):01431                 LDA             #RTC_I2C_ADDR   ; use DS3231M I2C address
E7E9 5F               (                  monitor1v4.ASM):01432                 CLRB                                    ; start at register 0
E7EA BEDFC1           (                  monitor1v4.ASM):01433                 LDX             RTCBUFPTR               ; use addr in RTCBUFPTR
E7ED 108E0020         (                  monitor1v4.ASM):01434                 LDY         #32                         ; 32 bytes
                      (                  monitor1v4.ASM):01435                                                                 ; fall into I2C_ReadMany...
                      (                  monitor1v4.ASM):01436 
                      (                  monitor1v4.ASM):01437 ;; I2C_WriteMany - writes one or more bytes of data to a specific address
                      (                  monitor1v4.ASM):01438 ;; inputs: A = slave address
                      (                  monitor1v4.ASM):01439 ;;         B = register address
                      (                  monitor1v4.ASM):01440 ;;         X = addr of write data buffer
                      (                  monitor1v4.ASM):01441 ;;         Y = number of bytes to write
                      (                  monitor1v4.ASM):01442 ;; return: A = I2C.Success or I2C.NoSlaveAck or I2C.BusError
                      (                  monitor1v4.ASM):01443 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01444 ;;                 Y is destroyed
                      (                  monitor1v4.ASM):01445 I2C_WriteMany
E7F1 3410             (                  monitor1v4.ASM):01446                 PSHS    X                               ; preserve write buffer address
E7F3 84FE             (                  monitor1v4.ASM):01447                 ANDA    #$FE                    ; send START and slave address (WRITE)
E7F5 8DC7             (                  monitor1v4.ASM):01448                 BSR     I2C_GoMaster    ; try to send slave address
E7F7 2617             (                  monitor1v4.ASM):01449                 BNE             WMERR?                  ; error, return with status!
E7F9 1F98             (                  monitor1v4.ASM):01450                 TFR     B,A                             ; copy register address into A
E7FB BDE73F           (                  monitor1v4.ASM):01451                 JSR             I2C_SendByte    ; try to send register address
E7FE 2610             (                  monitor1v4.ASM):01452                 BNE             WMERR?                  ; error, return with status!
E800 31A4             (                  monitor1v4.ASM):01453 WM0?    LEAY    0,Y                             ; test the byte counter
E802 270B             (                  monitor1v4.ASM):01454                 BEQ             WMEND?                  ; all done, send a STOP
E804 A680             (                  monitor1v4.ASM):01455 WM1?    LDA             ,X+                             ; copy byte from write buffer to A
E806 BDE73F           (                  monitor1v4.ASM):01456                 JSR             I2C_SendByte    ; try to send data byte
E809 2605             (                  monitor1v4.ASM):01457                 BNE             WMERR?                  ; error, return with status!
E80B 313F             (                  monitor1v4.ASM):01458                 LEAY    -1,Y                    ; decrement the byte counter
E80D 26F5             (                  monitor1v4.ASM):01459                 BNE             WM1?                    ; repeat until finished
E80F 4F               (                  monitor1v4.ASM):01460 WMEND?  CLRA                                    ; return code is fSuccess (0)
E810 BDE722           (                  monitor1v4.ASM):01461 WMERR?  JSR             I2C_SendStop    ; send a STOP condition         
E813 4D               (                  monitor1v4.ASM):01462                 TSTA                                    ; make sure Z is set according to return code!
E814 3510             (                  monitor1v4.ASM):01463                 PULS    X                               ; restore buffer start address
E816 39               (                  monitor1v4.ASM):01464                 RTS
                      (                  monitor1v4.ASM):01465 
                      (                  monitor1v4.ASM):01466 ;; I2C_WriteByte - write one byte of data to a specific address
                      (                  monitor1v4.ASM):01467 ;; inputs: A = slave address
                      (                  monitor1v4.ASM):01468 ;;         B = register address
                      (                  monitor1v4.ASM):01469 ;;                 E = data to write
                      (                  monitor1v4.ASM):01470 ;; return: A = I2C.Success or I2C.NoSlaveAck or I2C.BusError
                      (                  monitor1v4.ASM):01471 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01472 I2C_WriteByte
E817 84FE             (                  monitor1v4.ASM):01473                 ANDA    #$FE                    ; send START and slave address (WRITE)
E819 8DA3             (                  monitor1v4.ASM):01474                 BSR     I2C_GoMaster    ; try to send slave address
E81B 260F             (                  monitor1v4.ASM):01475                 BNE             WBERR?                  ; error, return with status!
E81D 1F98             (                  monitor1v4.ASM):01476                 TFR     B,A                             ; copy register address into A
E81F BDE73F           (                  monitor1v4.ASM):01477                 JSR             I2C_SendByte    ; try to send register address
E822 2608             (                  monitor1v4.ASM):01478                 BNE             WBERR?                  ; error, return with status!
E824 1FE8             (                  monitor1v4.ASM):01479                 TFR             E,A                             ; copy data byte to be written into A
E826 BDE73F           (                  monitor1v4.ASM):01480                 JSR             I2C_SendByte    ; try to send data byte
E829 2601             (                  monitor1v4.ASM):01481                 BNE             WBERR?                  ; error, return with status!
E82B 4F               (                  monitor1v4.ASM):01482                 CLRA                                    ; return code is fSuccess (0)
E82C BDE722           (                  monitor1v4.ASM):01483 WBERR?  JSR             I2C_SendStop    ; send a STOP condition         
E82F 4D               (                  monitor1v4.ASM):01484                 TSTA                                    ; make sure Z is set according to return code!
E830 39               (                  monitor1v4.ASM):01485                 RTS
                      (                  monitor1v4.ASM):01486 
                      (                  monitor1v4.ASM):01487 ;; RTC_ReadRegs - read registers 0-32 of the RTC 
                      (                  monitor1v4.ASM):01488 ;; inputs: RTCBUFPTR must contain the addr of read data buffer
                      (                  monitor1v4.ASM):01489 ;; return: B = value of last read data byte
                      (                  monitor1v4.ASM):01490 ;;         X = addr of read data buffer
                      (                  monitor1v4.ASM):01491 ;;                 A = I2C.Success or I2C.NoSlaveAck or I2C.BusError
                      (                  monitor1v4.ASM):01492 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01493 ;;                 Y is destroyed
                      (                  monitor1v4.ASM):01494 RTC_ReadRegs
E831 86D0             (                  monitor1v4.ASM):01495                 LDA             #RTC_I2C_ADDR   ; use DS3231M I2C address
E833 5F               (                  monitor1v4.ASM):01496                 CLRB                                    ; start at register 0
E834 BEDFC1           (                  monitor1v4.ASM):01497                 LDX             RTCBUFPTR               ; use addr in RTCBUFPTR
E837 108E0020         (                  monitor1v4.ASM):01498                 LDY         #32                         ; 32 bytes
                      (                  monitor1v4.ASM):01499                                                                 ; fall into I2C_ReadMany...
                      (                  monitor1v4.ASM):01500 
                      (                  monitor1v4.ASM):01501 ;; I2C_ReadMany - read one or more bytes of data from a specific address
                      (                  monitor1v4.ASM):01502 ;; inputs: A = slave address
                      (                  monitor1v4.ASM):01503 ;;         B = register address
                      (                  monitor1v4.ASM):01504 ;;         X = addr of read data buffer
                      (                  monitor1v4.ASM):01505 ;;         Y = number of bytes to read
                      (                  monitor1v4.ASM):01506 ;; return: B = value of last read data byte
                      (                  monitor1v4.ASM):01507 ;;         X = addr of read data buffer
                      (                  monitor1v4.ASM):01508 ;;                 A = I2C.Success or I2C.NoSlaveAck or I2C.BusError
                      (                  monitor1v4.ASM):01509 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01510 ;;                 Y is destroyed
                      (                  monitor1v4.ASM):01511 I2C_ReadMany
E83B 3410             (                  monitor1v4.ASM):01512                 PSHS    X                               ; preserve buffer start address
E83D 84FE             (                  monitor1v4.ASM):01513                 ANDA    #$FE                    ; send START and slave address (WRITE)
E83F BDE7BE           (                  monitor1v4.ASM):01514                 JSR     I2C_GoMaster    ; try to send slave address
E842 2626             (                  monitor1v4.ASM):01515                 BNE             RMERR?                  ; error, return with status!
E844 1E98             (                  monitor1v4.ASM):01516                 EXG     B,A                             ; register address into A, slave address into B
E846 BDE73F           (                  monitor1v4.ASM):01517                 JSR             I2C_SendByte    ; try to send register address
E849 261F             (                  monitor1v4.ASM):01518                 BNE             RMERR?                  ; error, return with status!
E84B 1F98             (                  monitor1v4.ASM):01519                 TFR             B,A                             ; slave address back into A             
E84D 8A01             (                  monitor1v4.ASM):01520                 ORA             #$01                    ; send START and slave address (READ)           
E84F BDE7BE           (                  monitor1v4.ASM):01521                 JSR     I2C_GoMaster    ; try to send slave address
E852 2616             (                  monitor1v4.ASM):01522                 BNE             RMERR?                  ; error, return with status!
E854 31A4             (                  monitor1v4.ASM):01523 RM0?    LEAY    0,Y                             ; test the byte counter
E856 2711             (                  monitor1v4.ASM):01524                 BEQ             RMEND?                  ; all done, send a STOP
E858 8601             (                  monitor1v4.ASM):01525 RM1?    LDA             #I2C_ACKNOWLEDGE        ; assume ACK
E85A 313F             (                  monitor1v4.ASM):01526                 LEAY    -1,Y                    ; decrement the byte counter
E85C 2602             (                  monitor1v4.ASM):01527                 BNE             RM2?                    ; not the last byte to read
E85E 8600             (                  monitor1v4.ASM):01528                 LDA             #I2C_NOTACKNOWLEDGE     ; yes, last byte, responsd with NAK
E860 BDE76D           (                  monitor1v4.ASM):01529 RM2?    JSR             I2C_RcvByte             ; read the data byte
E863 A780             (                  monitor1v4.ASM):01530                 STA             ,X+                             ; store in buffer
E865 1F89             (                  monitor1v4.ASM):01531                 TFR             A,B                             ; copy read byte to B
E867 20EB             (                  monitor1v4.ASM):01532                 BRA             RM0?                    ; repeat until finished
E869 4F               (                  monitor1v4.ASM):01533 RMEND?  CLRA                                    ; return code is fSuccess (0)
E86A BDE722           (                  monitor1v4.ASM):01534 RMERR?  JSR             I2C_SendStop    ; send a STOP condition         
E86D 4D               (                  monitor1v4.ASM):01535                 TSTA                                    ; make sure Z is set according to return code!
E86E 3510             (                  monitor1v4.ASM):01536                 PULS    X                               ; restore buffer start address
E870 39               (                  monitor1v4.ASM):01537                 RTS
                      (                  monitor1v4.ASM):01538                 
                      (                  monitor1v4.ASM):01539 ;; I2C_ReadByte - read a single byte from a specific address
                      (                  monitor1v4.ASM):01540 ;; inputs: A = slave address
                      (                  monitor1v4.ASM):01541 ;;         B = register address, 
                      (                  monitor1v4.ASM):01542 ;; return: B = value of read data byte
                      (                  monitor1v4.ASM):01543 ;;                 A = I2C.Success or I2C.NoSlaveAck or I2C.BusError
                      (                  monitor1v4.ASM):01544 ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (                  monitor1v4.ASM):01545 I2C_ReadByte
E871 84FE             (                  monitor1v4.ASM):01546                 ANDA    #$FE                    ; send START and slave address (WRITE)
E873 BDE7BE           (                  monitor1v4.ASM):01547                 JSR     I2C_GoMaster    ; try to send slave address
E876 2618             (                  monitor1v4.ASM):01548                 BNE             RBERR?                  ; error, return with status!
E878 1E98             (                  monitor1v4.ASM):01549                 EXG     B,A                             ; register address into A, slave address into B
E87A BDE73F           (                  monitor1v4.ASM):01550                 JSR             I2C_SendByte    ; try to send register address
E87D 2611             (                  monitor1v4.ASM):01551                 BNE             RBERR?                  ; error, return with status!
E87F 1F98             (                  monitor1v4.ASM):01552                 TFR             B,A                             ; slave address back into A             
E881 8A01             (                  monitor1v4.ASM):01553                 ORA             #$01                    ; send START and slave address (READ)           
E883 BDE7BE           (                  monitor1v4.ASM):01554                 JSR     I2C_GoMaster    ; try to send slave address
E886 2608             (                  monitor1v4.ASM):01555                 BNE             RBERR?                  ; error, return with status!
E888 8600             (                  monitor1v4.ASM):01556                 LDA             #I2C_NOTACKNOWLEDGE     ; only one byte, so NAK it
E88A BDE76D           (                  monitor1v4.ASM):01557                 JSR             I2C_RcvByte             ; read the data byte
E88D 1F89             (                  monitor1v4.ASM):01558                 TFR             A,B                             ; copy byte value to B
E88F 4F               (                  monitor1v4.ASM):01559 RBEND?  CLRA                                    ; return code is fSuccess (0)
E890 BDE722           (                  monitor1v4.ASM):01560 RBERR?  JSR             I2C_SendStop    ; send a STOP condition         
E893 4D               (                  monitor1v4.ASM):01561                 TSTA                                    ; make sure Z is set according to return code!
E894 39               (                  monitor1v4.ASM):01562                 RTS
                      (                  monitor1v4.ASM):01563                 
                      (                  monitor1v4.ASM):01564 ;;
                      (                  monitor1v4.ASM):01565 ;; S-RECORD & I-HEX DOWNLOAD via UART A
                      (                  monitor1v4.ASM):01566 ;;
E895 BDE6F2           (                  monitor1v4.ASM):01567 DLOAD   JSR             PUTCR                   ; NEW LINE
E898 8D0A             (                  monitor1v4.ASM):01568 DLO1?   BSR             DLREC                   ; DOWNLOAD RECORD
E89A 2407             (                  monitor1v4.ASM):01569                 BCC             DLO2?                   ; END
E89C 862E             (                  monitor1v4.ASM):01570                 LDA             #'.'                    ; OUTPUT ONE DOT PER RECORD
E89E BDE2CA           (                  monitor1v4.ASM):01571                 JSR             PUTA                    ; OUTPUT
E8A1 20F5             (                  monitor1v4.ASM):01572                 BRA             DLO1?                   ; CONTINUE
E8A3 39               (                  monitor1v4.ASM):01573 DLO2?   RTS
                      (                  monitor1v4.ASM):01574 
                      (                  monitor1v4.ASM):01575 ; Download a record in either MOTOROLA or INTEL hex format
E8A4 BDE2A9           (                  monitor1v4.ASM):01576 DLREC   JSR             GETA                    ; Get a character
E8A7 813A             (                  monitor1v4.ASM):01577                 CMPA    #':'                    ; Start of INTEL record?
E8A9 1027007C         (                  monitor1v4.ASM):01578                 LBEQ    DLINT                   ; Yes, download INTEL
E8AD 8153             (                  monitor1v4.ASM):01579                 CMPA    #'S'                    ; Start of MOTOROLA record?
E8AF 26F3             (                  monitor1v4.ASM):01580                 BNE             DLREC                   ; No, keep looking
                      (                  monitor1v4.ASM):01581                 
                      (                  monitor1v4.ASM):01582 ; Download a record in MOTOROLA hex format
E8B1 BDE2A9           (                  monitor1v4.ASM):01583 DLMOT   JSR             GETA                    ; get next char  
E8B4 8130             (                  monitor1v4.ASM):01584                 CMPA    #'0'                    ; header record? 
E8B6 27DD             (                  monitor1v4.ASM):01585                 BEQ             DLOAD                   ;    skip it        
E8B8 8135             (                  monitor1v4.ASM):01586                 CMPA    #'5'                    ; count record?  
E8BA 27D9             (                  monitor1v4.ASM):01587                 BEQ             DLOAD                   ;    skip it        
E8BC 8139             (                  monitor1v4.ASM):01588                 CMPA    #'9'                    ; end of file?   
E8BE 274F             (                  monitor1v4.ASM):01589                 BEQ             DLMOT9                  ;    end of file    
E8C0 8131             (                  monitor1v4.ASM):01590                 CMPA    #'1'                    ; should be a data record (S1) then!
E8C2 2646             (                  monitor1v4.ASM):01591                 BNE             LODERR                  ;       none of these = load error     
E8C4 BDE6A7           (                  monitor1v4.ASM):01592                 JSR             GETBYTE                 ; get length     
E8C7 2441             (                  monitor1v4.ASM):01593                 BCC             LODERR                  ; report error   
E8C9 B7DEF7           (                  monitor1v4.ASM):01594                 STA             TEMP                    ; start checksum 
E8CC 8003             (                  monitor1v4.ASM):01595                 SUBA    #3                              ; adjust length (omit address and checksum)
E8CE B7DEF8           (                  monitor1v4.ASM):01596                 STA             TEMP+1                  ; set length     
E8D1 BDE6A7           (                  monitor1v4.ASM):01597                 JSR             GETBYTE                 ; get first byte of address
E8D4 2434             (                  monitor1v4.ASM):01598                 BCC             LODERR                  ; report error   
E8D6 1F89             (                  monitor1v4.ASM):01599                 TFR             A,B                             ; save for later 
E8D8 BBDEF7           (                  monitor1v4.ASM):01600                 ADDA    TEMP                    ; include in checksum
E8DB B7DEF7           (                  monitor1v4.ASM):01601                 STA             TEMP                    ; resave         
E8DE BDE6A7           (                  monitor1v4.ASM):01602                 JSR             GETBYTE                 ; get next byte of address
E8E1 2427             (                  monitor1v4.ASM):01603                 BCC             LODERR                  ; report error   
E8E3 1E89             (                  monitor1v4.ASM):01604                 EXG             A,B                             ; swap address halves (endian stuff)
E8E5 1F01             (                  monitor1v4.ASM):01605                 TFR             D,X                             ; set pointer    
E8E7 FBDEF7           (                  monitor1v4.ASM):01606                 ADDB    TEMP                    ; include in checksum
E8EA F7DEF7           (                  monitor1v4.ASM):01607                 STB             TEMP                    ; resave checksum
E8ED BDE6A7           (                  monitor1v4.ASM):01608 DLMOT1  JSR             GETBYTE                 ; get a data byte
E8F0 2418             (                  monitor1v4.ASM):01609                 BCC             LODERR                  ; report error   
E8F2 A780             (                  monitor1v4.ASM):01610                 STA             ,X+                             ; Save in RAM
E8F4 BBDEF7           (                  monitor1v4.ASM):01611                 ADDA    TEMP                    ; Include checksum
E8F7 B7DEF7           (                  monitor1v4.ASM):01612                 STA             TEMP                    ; Resave
E8FA 7ADEF8           (                  monitor1v4.ASM):01613                 DEC     TEMP+1          ; Reduce length                          
E8FD 26EE             (                  monitor1v4.ASM):01614                 BNE     DLMOT1          ; do them all                            
E8FF BDE6A7           (                  monitor1v4.ASM):01615                 JSR             GETBYTE                 ; get checksum byte
E902 2406             (                  monitor1v4.ASM):01616                 BCC             LODERR                  ; report error   
E904 BBDEF7           (                  monitor1v4.ASM):01617                 ADDA    TEMP                    ; add computed checksum                  
E907 4C               (                  monitor1v4.ASM):01618                 INCA                                    ; test for success                       
E908 271A             (                  monitor1v4.ASM):01619                 BEQ             DLRTS                   ; download ok                            
                      (                  monitor1v4.ASM):01620                 
                      (                  monitor1v4.ASM):01621 ; Error occured on loading                                             
E90A 1A04             (                  monitor1v4.ASM):01622 LODERR  ORCC    #Z                              ; set the Z flag to indicate an error occurred
E90C 1CFE             (                  monitor1v4.ASM):01623                 ANDCC   #~C                             ; clear the 'c' flag to indicate end of file
E90E 39               (                  monitor1v4.ASM):01624                 RTS
                      (                  monitor1v4.ASM):01625                 
                      (                  monitor1v4.ASM):01626 ; properly handle S9 end record (just eat it)   
E90F BDE6A7           (                  monitor1v4.ASM):01627 DLMOT9  JSR             GETBYTE                 ; get length byte
E912 24F6             (                  monitor1v4.ASM):01628                 BCC             LODERR                  ; report error   
E914 B7DEF8           (                  monitor1v4.ASM):01629                 STA     TEMP+1                  ; save length
E917 BDE6A7           (                  monitor1v4.ASM):01630 DLM91?  JSR             GETBYTE                 ; get next byte
E91A 7ADEF8           (                  monitor1v4.ASM):01631                 DEC     TEMP+1                  ; Reduce length                                         
E91D 26F8             (                  monitor1v4.ASM):01632                 BNE     DLM91?                  ; get all the bytes
                      (                  monitor1v4.ASM):01633                                                                 ; fall into DLEOF
                      (                  monitor1v4.ASM):01634 
                      (                  monitor1v4.ASM):01635 ; set C flag to signal another record needed / clear if end of file
E91F 1CFB             (                  monitor1v4.ASM):01636 DLEOF   ANDCC   #~Z                             ; clear the 'z' flag to indicate no errors occurred
E921 1CFE             (                  monitor1v4.ASM):01637                 ANDCC   #~C                             ; clear the 'c' flag to indicate end of file
E923 39               (                  monitor1v4.ASM):01638                 RTS
E924 1CFB             (                  monitor1v4.ASM):01639 DLRTS   ANDCC   #~Z             ; clear the 'z' flag to indicate no errors occurred
E926 1A01             (                  monitor1v4.ASM):01640                 ORCC    #C              ; set 'c' flag to indicate another record                       
E928 39               (                  monitor1v4.ASM):01641                 RTS
                      (                  monitor1v4.ASM):01642 
                      (                  monitor1v4.ASM):01643 ; Download record in INTEL format                                                       
E929 BDE6A7           (                  monitor1v4.ASM):01644 DLINT   JSR     GETBYTE         ; get count
E92C 24DC             (                  monitor1v4.ASM):01645                 BCC     LODERR          ; report error   
E92E B7DEF7           (                  monitor1v4.ASM):01646                 STA     TEMP                    ; Start checksum                                                        
E931 B7DEF8           (                  monitor1v4.ASM):01647                 STA     TEMP+1          ; Record length                                                         
E934 8100             (                  monitor1v4.ASM):01648                 CMPA    #0                      ; Test & clear C                                                        
E936 27E7             (                  monitor1v4.ASM):01649                 BEQ             DLEOF                   ; End of file
                      (                  monitor1v4.ASM):01650 ; Get address
E938 BDE6A7           (                  monitor1v4.ASM):01651                 JSR     GETBYTE         ; get first byte of address
E93B 24CD             (                  monitor1v4.ASM):01652                 BCC     LODERR          ; report error   
E93D 1F89             (                  monitor1v4.ASM):01653                 TFR             A,B                             ; Save for later
E93F BBDEF7           (                  monitor1v4.ASM):01654                 ADDA    TEMP                    ; Include in checksum
E942 B7DEF7           (                  monitor1v4.ASM):01655                 STA             TEMP                    ; Resave
E945 BDE6A7           (                  monitor1v4.ASM):01656                 JSR     GETBYTE         ; get next byte of address
E948 24C0             (                  monitor1v4.ASM):01657                 BCC     LODERR          ; report error   
E94A 1E89             (                  monitor1v4.ASM):01658                 EXG             A,B                             ; Swap
E94C 1F01             (                  monitor1v4.ASM):01659                 TFR             D,X                             ; Set pointer
E94E FBDEF7           (                  monitor1v4.ASM):01660                 ADDB    TEMP                    ; Include in checksum
E951 F7DEF7           (                  monitor1v4.ASM):01661                 STB             TEMP                    ; Resave checksum
                      (                  monitor1v4.ASM):01662 ; Get record type
E954 BDE6A7           (                  monitor1v4.ASM):01663                 JSR     GETBYTE         ; get type value
E957 24B1             (                  monitor1v4.ASM):01664                 BCC     LODERR          ; report error   
E959 BBDEF7           (                  monitor1v4.ASM):01665                 ADDA    TEMP                    ; Include checksum
E95C B7DEF7           (                  monitor1v4.ASM):01666                 STA             TEMP                    ; Resave checksum
                      (                  monitor1v4.ASM):01667 ; Get data bytes
E95F BDE6A7           (                  monitor1v4.ASM):01668 DLINT1  JSR     GETBYTE         ; get data byte
E962 24A6             (                  monitor1v4.ASM):01669                 BCC     LODERR          ; report error   
E964 A780             (                  monitor1v4.ASM):01670                 STA             ,X+                             ; Write to memory
E966 BBDEF7           (                  monitor1v4.ASM):01671                 ADDA    TEMP                    ; Include checksum
E969 B7DEF7           (                  monitor1v4.ASM):01672                 STA             TEMP                    ; Resave checksum
E96C 7ADEF8           (                  monitor1v4.ASM):01673                 DEC             TEMP+1                  ; Reduce length
E96F 26EE             (                  monitor1v4.ASM):01674                 BNE             DLINT1                  ; Do them all
                      (                  monitor1v4.ASM):01675 ; Get checksum
E971 BDE6A7           (                  monitor1v4.ASM):01676                 JSR             GETBYTE                 ; Read checksum byte
E974 2494             (                  monitor1v4.ASM):01677                 BCC             LODERR                  ; Report error
E976 BBDEF7           (                  monitor1v4.ASM):01678                 ADDA    TEMP                    ; add into checksum
E979 27A9             (                  monitor1v4.ASM):01679                 BEQ             DLRTS                   ; Report success
E97B 7EE90A           (                  monitor1v4.ASM):01680                 JMP             LODERR                  ; Report failure                 
                      (                  monitor1v4.ASM):01681                 
                      (                  monitor1v4.ASM):01682 ; This is adapted from Jeff Tranter's port of Woz Mon to my HD6309 SBC
                      (                  monitor1v4.ASM):01683 ; Jeff's work can be found here:
                      (                  monitor1v4.ASM):01684 ; https://github.com/jefftranter/6809/blob/master/sbc/wozmon/wozmon.asm
                      (                  monitor1v4.ASM):01685 ;
                      (                  monitor1v4.ASM):01686 ; It now fits easily < 256 bytes, thanks to the SCC UART functions that
                      (                  monitor1v4.ASM):01687 ; are already present within this ROM
                      (                  monitor1v4.ASM):01688 ;
                      (                  monitor1v4.ASM):01689 ; This is a port of the 6800 version of Woz Mon to my 6809-based Single
                      (                  monitor1v4.ASM):01690 ; Board Computer. It was converted to 6809 instructions as well as
                      (                  monitor1v4.ASM):01691 ; ported to use the 6850 ACIA for input/output.
                      (                  monitor1v4.ASM):01692 
                      (                  monitor1v4.ASM):01693 ; The original 6800 port came from here: https://pastebin.com/TSM2DdRL
                      (                  monitor1v4.ASM):01694 
                      (                  monitor1v4.ASM):01695 ; Note: The code internally converts all characters to high ASCII (bit
                      (                  monitor1v4.ASM):01696 ; 7 = 1) because the Apple 1 used this format and the program logic is
                      (                  monitor1v4.ASM):01697 ; dependent on it in several places.
                      (                  monitor1v4.ASM):01698 
                      (                  monitor1v4.ASM):01699 ; The code is not quite small enough to fit in 256 bytes as the
                      (                  monitor1v4.ASM):01700 ; original 6502 and 6800 versions did.
                      (                  monitor1v4.ASM):01701 
                      (                  monitor1v4.ASM):01702 ;***********************************************************************
                      (                  monitor1v4.ASM):01703 
                      (                  monitor1v4.ASM):01704 ; This is a rewrite of the Apple 1 monitor to run on an MC6800
                      (                  monitor1v4.ASM):01705 ; microprocessor, rather than the MCS6502 microprocessor that
                      (                  monitor1v4.ASM):01706 ; was standard.  This source code will assemble with the
                      (                  monitor1v4.ASM):01707 ; AS Macro Assembler; with minor changes it should assemble
                      (                  monitor1v4.ASM):01708 ; with any MC6800 assembler.
                      (                  monitor1v4.ASM):01709 
                      (                  monitor1v4.ASM):01710 ; Copyright 2011 Eric Smith <eric@brouhaha.com>
                      (                  monitor1v4.ASM):01711 ;
                      (                  monitor1v4.ASM):01712 ; This program is free software; you can redistribute and/or modify it
                      (                  monitor1v4.ASM):01713 ; under the terms of the GNU General Public License version 3 as
                      (                  monitor1v4.ASM):01714 ; published by the Free Software Foundation.
                      (                  monitor1v4.ASM):01715 ;
                      (                  monitor1v4.ASM):01716 ; This program is distributed in the hope that it will be useful, but
                      (                  monitor1v4.ASM):01717 ; WITHOUT ANY WARRANTY; without even the implied warranty of
                      (                  monitor1v4.ASM):01718 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                      (                  monitor1v4.ASM):01719 ; General Public License for more details.
                      (                  monitor1v4.ASM):01720 ;
                      (                  monitor1v4.ASM):01721 ; The text of the license may be found online at:
                      (                  monitor1v4.ASM):01722 ;     http://www.brouhaha.com/~eric/software/GPLv3
                      (                  monitor1v4.ASM):01723 ; or:
                      (                  monitor1v4.ASM):01724 ;     http://www.gnu.org/licenses/gpl-3.0.txt
                      (                  monitor1v4.ASM):01725 
     008D             (                  monitor1v4.ASM):01726 CR          EQU         $8D     ; Carriage return
     008A             (                  monitor1v4.ASM):01727 LF          EQU         $8A     ; Line feed
     009B             (                  monitor1v4.ASM):01728 ESC         EQU         $9B             ; Escape
                      (                  monitor1v4.ASM):01729 
     DE00             (                  monitor1v4.ASM):01730 INBUF           EQU             RAM_WOZMON      ; input buffer (128 chars long)
                      (                  monitor1v4.ASM):01731 
     DE80             (                  monitor1v4.ASM):01732 XAM                     EQU     RAM_WOZMON+128          ; two bytes
     DE82             (                  monitor1v4.ASM):01733 ST                      EQU     RAM_WOZMON+128+2        ; two bytes
     DE84             (                  monitor1v4.ASM):01734 H                       EQU             RAM_WOZMON+128+4        ; word access with just "H"
     DE85             (                  monitor1v4.ASM):01735 L                       EQU             RAM_WOZMON+128+5
     DE86             (                  monitor1v4.ASM):01736 MODE            EQU             RAM_WOZMON+128+6
                      (                  monitor1v4.ASM):01737 ;YSAV           EQU     RAM_WOZMON+128+7        ; use Yreg instead
                      (                  monitor1v4.ASM):01738 ;INPTR          EQU             RAM_WOZMON+128+9    ; INPTR+1 is LSB - use Wreg instead (E is MSB, F is LSB)
                      (                  monitor1v4.ASM):01739 
E97E BDE254           (                  monitor1v4.ASM):01740 WOZMON:     JSR  STARTUP                ; initialize the SCC and system regs
E981 10CEDED7         (                  monitor1v4.ASM):01741                         LDS      #INITSTACK             ; use "user stack" already reserved by noICE
E985 200D             (                  monitor1v4.ASM):01742             BRA  ESCAPE  
                      (                  monitor1v4.ASM):01743 
                      (                  monitor1v4.ASM):01744 ; Get a line of input from the keyboard, echoing to display.
                      (                  monitor1v4.ASM):01745 ; Normally enter at escape or getline.
                      (                  monitor1v4.ASM):01746 
E987 81DF             (                  monitor1v4.ASM):01747 NOTCR:      CMPA #$DF           ; "_"?  [NB back arrow]
E989 2716             (                  monitor1v4.ASM):01748             BEQ  BACKSPACE      ; Yes.
E98B 819B             (                  monitor1v4.ASM):01749             CMPA #ESC           ; ESC?
E98D 2705             (                  monitor1v4.ASM):01750             BEQ  ESCAPE         ; Yes.
E98F 3001             (                  monitor1v4.ASM):01751             LEAX 1,X            ; Advance text index.
E991 5C               (                  monitor1v4.ASM):01752             INCB          
E992 2A12             (                  monitor1v4.ASM):01753             BPL  NEXTCHAR       ; Auto ESC if > 127.
                      (                  monitor1v4.ASM):01754                                 
E994 86DC             (                  monitor1v4.ASM):01755 ESCAPE:     LDA  #$DC           ; "\".
E996 BDEA19           (                  monitor1v4.ASM):01756             JSR  ECHO           ; Output it.
                      (                  monitor1v4.ASM):01757                           
E999 BDE6F2           (                  monitor1v4.ASM):01758 GETLINE:    JSR  PUTCR
E99C 8EDE01           (                  monitor1v4.ASM):01759             LDX  #INBUF+1      ; Initialize text index.
E99F C601             (                  monitor1v4.ASM):01760             LDB  #1       
E9A1 301F             (                  monitor1v4.ASM):01761 BACKSPACE:  LEAX -1,X       ; Back up text index.
E9A3 5A               (                  monitor1v4.ASM):01762             DECB          
E9A4 2BF3             (                  monitor1v4.ASM):01763             BMI  GETLINE    ; Beyond start of line, reinitialize.
                      (                  monitor1v4.ASM):01764                           
E9A6 BDE2A9           (                  monitor1v4.ASM):01765 NEXTCHAR:   JSR  GETA           ; get a character from UART Ch A
E9A9 8A80             (                  monitor1v4.ASM):01766             ORA  #$80       ; Convert to high ASCII.
E9AB A784             (                  monitor1v4.ASM):01767             STA  ,X         ; Add to text buffer.
E9AD 8D6A             (                  monitor1v4.ASM):01768             BSR  ECHO       ; Display character.
E9AF 818D             (                  monitor1v4.ASM):01769             CMPA #CR        ; CR?
E9B1 26D4             (                  monitor1v4.ASM):01770             BNE  NOTCR      ; No.
                      (                  monitor1v4.ASM):01771                           
                      (                  monitor1v4.ASM):01772 ; Process an input line.
                      (                  monitor1v4.ASM):01773 
                      (                  monitor1v4.ASM):01774 RETURN:        
                      (                  monitor1v4.ASM):01775 ;                       LDX  #INBUF+256-1  ; Reset text index to in-1, +256 so that
                      (                  monitor1v4.ASM):01776                             ;  'inc inptr+1' will result in $0200.
                      (                  monitor1v4.ASM):01777 ;            STX  INPTR     
E9B3 1086DEFF         (                  monitor1v4.ASM):01778                         LDW      #INBUF+256-1   ; reset text index to in-1+256 so that
                      (                  monitor1v4.ASM):01779                             ;  'inc inptr+1' will result in $0200.                      
E9B7 4F               (                  monitor1v4.ASM):01780             CLRA            ; For XAM mode. 0->B.
                      (                  monitor1v4.ASM):01781                            
E9B8 48               (                  monitor1v4.ASM):01782 SETBLOK:    ASLA            ; Leaves $56 if setting BLOCK XAM mode.
E9B9 B7DE86           (                  monitor1v4.ASM):01783 SETMODE:    STA  MODE       ; $00 = XAM, $BA = STOR, $56 = BLOK XAM.
                      (                  monitor1v4.ASM):01784 BLSKIP:     
                      (                  monitor1v4.ASM):01785 ;                       INC  INPTR+1    ; Advance text index.
E9BC 115C             (                  monitor1v4.ASM):01786                         INCF                    ; advance text index (LSB only, so modulo 256)
                      (                  monitor1v4.ASM):01787 NEXTITEM:   
                      (                  monitor1v4.ASM):01788 ;                       LDX  INPTR     
E9BE 1F61             (                  monitor1v4.ASM):01789                         TFR  W,X                ; copy text index to X
E9C0 A684             (                  monitor1v4.ASM):01790             LDA  ,X         ; Get character.
E9C2 818D             (                  monitor1v4.ASM):01791             CMPA #CR        ; CR?
E9C4 27D3             (                  monitor1v4.ASM):01792             BEQ  GETLINE    ; Yes, done this line.
E9C6 81AE             (                  monitor1v4.ASM):01793             CMPA #$AE       ; "."?
E9C8 27EE             (                  monitor1v4.ASM):01794             BEQ  SETBLOK    ; Set BLOCK XAM mode.
E9CA 23F0             (                  monitor1v4.ASM):01795             BLS  BLSKIP     ; Skip delimiter.
E9CC 81BA             (                  monitor1v4.ASM):01796             CMPA #$BA       ; ":"?
E9CE 27E9             (                  monitor1v4.ASM):01797             BEQ  SETMODE    ; Yes, set STOR mode.
E9D0 81D2             (                  monitor1v4.ASM):01798             CMPA #$D2       ; "R"?
E9D2 274D             (                  monitor1v4.ASM):01799             BEQ  RUN        ; Yes, run user program.
E9D4 7FDE85           (                  monitor1v4.ASM):01800             CLR  L          ; $00->L.
E9D7 7FDE84           (                  monitor1v4.ASM):01801             CLR  H          ;  and H.
                      (                  monitor1v4.ASM):01802 ;            STX  YSAV       ; Save Y for comparison.
E9DA 1F12             (                  monitor1v4.ASM):01803                         TFR  X,Y                ; copy text index (X) to Y (Y is used for 'YSAV' instead of RAM)
                      (                  monitor1v4.ASM):01804                            
                      (                  monitor1v4.ASM):01805 NEXTHEX:    
                      (                  monitor1v4.ASM):01806 ;                       LDX  INPTR     
E9DC 1F61             (                  monitor1v4.ASM):01807                         TFR  W,X                ; copy text index to X
E9DE A684             (                  monitor1v4.ASM):01808             LDA  ,X         ; Get character for hex test.
E9E0 88B0             (                  monitor1v4.ASM):01809             EORA #$B0       ; Map digits to $0-9.
E9E2 8109             (                  monitor1v4.ASM):01810             CMPA #$09       ; Digit?
E9E4 2306             (                  monitor1v4.ASM):01811             BLS  DIG        ; Yes.
E9E6 8B89             (                  monitor1v4.ASM):01812             ADDA #$89       ; Map letter "A"-"F" to $FA-FF.
E9E8 81F9             (                  monitor1v4.ASM):01813             CMPA #$F9       ; Hex letter?
E9EA 2314             (                  monitor1v4.ASM):01814             BLS  NOTHEX     ; No, character not hex.
                      (                  monitor1v4.ASM):01815                            
E9EC 48               (                  monitor1v4.ASM):01816 DIG:        ASLA            ; Hex digit to MSD of A.
E9ED 48               (                  monitor1v4.ASM):01817             ASLA           
E9EE 48               (                  monitor1v4.ASM):01818             ASLA           
E9EF 48               (                  monitor1v4.ASM):01819             ASLA           
                      (                  monitor1v4.ASM):01820                            
E9F0 C604             (                  monitor1v4.ASM):01821             LDB  #$04       ; Shift count.
E9F2 48               (                  monitor1v4.ASM):01822 HEXSHIFT:   ASLA            ; Hex digit left, MSB to carry.
E9F3 79DE85           (                  monitor1v4.ASM):01823             ROL  L          ; Rotate into LSD.
E9F6 79DE84           (                  monitor1v4.ASM):01824             ROL  H          ; Rotate into MSD's.
E9F9 5A               (                  monitor1v4.ASM):01825             DECB            ; Done 4 shifts?
E9FA 26F6             (                  monitor1v4.ASM):01826             BNE  HEXSHIFT   ; No, loop.
                      (                  monitor1v4.ASM):01827                            
                      (                  monitor1v4.ASM):01828 ;            INC  INPTR+1    ; Advance text index.
E9FC 115C             (                  monitor1v4.ASM):01829                         INCF                    ; advance text index (LSB only, so modulo 256)
E9FE 20DC             (                  monitor1v4.ASM):01830             BRA  NEXTHEX    ; Always taken. Check next character for hex.
                      (                  monitor1v4.ASM):01831                            
                      (                  monitor1v4.ASM):01832 NOTHEX:     
                      (                  monitor1v4.ASM):01833 ;                       CMPX YSAV       ; Check if L, H empty (no hex digits).    CMPX ( X - YSAV )    
EA00 103721           (                  monitor1v4.ASM):01834                         CMPR Y,X                ; check if L, H empty (no hex digits)     CMPR ( X - Y)
EA03 278F             (                  monitor1v4.ASM):01835             BEQ  ESCAPE     ; Yes, generate ESC sequence.
EA05 7DDE86           (                  monitor1v4.ASM):01836             TST  MODE       ; Test MODE byte.
EA08 2A1B             (                  monitor1v4.ASM):01837             BPL  NOTSTOR    ; B7=0 for STOR, 1 for XAM and BLOCK XAM
                      (                  monitor1v4.ASM):01838 
                      (                  monitor1v4.ASM):01839 ; STOR mode
EA0A BEDE82           (                  monitor1v4.ASM):01840             LDX  ST         
EA0D B6DE85           (                  monitor1v4.ASM):01841             LDA  L          ; LSD's of hex data.
EA10 A784             (                  monitor1v4.ASM):01842             STA  ,X         ; Store at current 'store index'.
EA12 3001             (                  monitor1v4.ASM):01843             LEAX 1,X        
EA14 BFDE82           (                  monitor1v4.ASM):01844             STX  ST         
EA17 20A5             (                  monitor1v4.ASM):01845 TONEXTITEM: BRA  NEXTITEM   ; Get next command item.
                      (                  monitor1v4.ASM):01846                             
                      (                  monitor1v4.ASM):01847                          
EA19 847F             (                  monitor1v4.ASM):01848 ECHO:       ANDA #$7F       ; Convert to low ASCII.
EA1B BDE2CA           (                  monitor1v4.ASM):01849                         JSR      PUTA
EA1E 8A80             (                  monitor1v4.ASM):01850             ORA  #$80        ; Convert back to high ASCII.
EA20 39               (                  monitor1v4.ASM):01851             RTS             ; Return.
                      (                  monitor1v4.ASM):01852                             
EA21 6E9FDE80         (                  monitor1v4.ASM):01853 RUN:        JMP  [XAM]      ; Run at current XAM index.  
                      (                  monitor1v4.ASM):01854                             
EA25 262B             (                  monitor1v4.ASM):01855 NOTSTOR:    BNE  XAMNEXT    ; mode = $00 for XAM, $56 for BLOCK XAM.
                      (                  monitor1v4.ASM):01856                             
EA27 BEDE84           (                  monitor1v4.ASM):01857             LDX  H          ; Copy hex data to
EA2A BFDE82           (                  monitor1v4.ASM):01858             STX  ST         ;  'store index'.
EA2D BFDE80           (                  monitor1v4.ASM):01859             STX  XAM        ; And to 'XAM index'.
EA30 4F               (                  monitor1v4.ASM):01860             CLRA            ; set Z flag to force following branch.
                      (                  monitor1v4.ASM):01861                             
EA31 2613             (                  monitor1v4.ASM):01862 NXTPRNT:    BNE  PRDATA     ; NE means no address to print.
EA33 BDE6F2           (                  monitor1v4.ASM):01863                         JSR  PUTCR
EA36 B6DE80           (                  monitor1v4.ASM):01864             LDA  XAM        ; 'Examine index' high-order byte.
EA39 BDE6DB           (                  monitor1v4.ASM):01865                         JSR  PUTBYTE
EA3C B6DE81           (                  monitor1v4.ASM):01866             LDA  XAM+1      ; Low-order 'Examine index' byte.
EA3F BDE6DB           (                  monitor1v4.ASM):01867             JSR  PUTBYTE                        
EA42 86BA             (                  monitor1v4.ASM):01868             LDA  #$BA       ; ":".
EA44 8DD3             (                  monitor1v4.ASM):01869             BSR  ECHO       ; Output it.
                      (                  monitor1v4.ASM):01870                             
EA46 86A0             (                  monitor1v4.ASM):01871 PRDATA:     LDA  #$A0       ; Blank.
EA48 8DCF             (                  monitor1v4.ASM):01872             BSR  ECHO       ; Output it.
                      (                  monitor1v4.ASM):01873                             
EA4A BEDE80           (                  monitor1v4.ASM):01874             LDX  XAM        
EA4D A684             (                  monitor1v4.ASM):01875             LDA  ,X         ; Get data byte at 'examine index'.
EA4F BDE6DB           (                  monitor1v4.ASM):01876                         JSR      PUTBYTE
                      (                  monitor1v4.ASM):01877                             
EA52 7FDE86           (                  monitor1v4.ASM):01878 XAMNEXT:    CLR  MODE       ; 0->MODE (XAM mode).
EA55 BEDE80           (                  monitor1v4.ASM):01879             LDX  XAM        ; Compare 'examine index' to hex data.
EA58 BCDE84           (                  monitor1v4.ASM):01880             CMPX  H          
EA5B 27BA             (                  monitor1v4.ASM):01881             BEQ  TONEXTITEM ; Not less, so more data to output.
EA5D 3001             (                  monitor1v4.ASM):01882             LEAX 1,X        
EA5F BFDE80           (                  monitor1v4.ASM):01883             STX  XAM        
EA62 B6DE81           (                  monitor1v4.ASM):01884             LDA  XAM+1      ; Check low-order 'examine index' byte
EA65 8407             (                  monitor1v4.ASM):01885             ANDA #$07       ; For MOD 8 = 0
EA67 20C8             (                  monitor1v4.ASM):01886             BRA  NXTPRNT    ; always taken
                      (                  monitor1v4.ASM):01887                         
                      (                  monitor1v4.ASM):01888                         
                      (                  monitor1v4.ASM):01889 
                      (                  monitor1v4.ASM):01890                                                                         
                      (                  monitor1v4.ASM):01891 ; JUMP POINTS                                                                  
                      (                  monitor1v4.ASM):01892                 ORG             JUMP_TABLE                                              
FFC0 E97E             (                  monitor1v4.ASM):01893                 FDB             WOZMON
FFC2 E666             (                  monitor1v4.ASM):01894                 FDB             CIO_INIT                                 
FFC4 E68B             (                  monitor1v4.ASM):01895                 FDB             CIO_READ                                 
FFC6 E697             (                  monitor1v4.ASM):01896                 FDB             CIO_WRITE                                
FFC8 E2EC             (                  monitor1v4.ASM):01897                 FDB             SCC_INITA
FFCA E2CA             (                  monitor1v4.ASM):01898                 FDB             PUTA     
FFCC E2A9             (                  monitor1v4.ASM):01899                 FDB             GETA     
FFCE E29E             (                  monitor1v4.ASM):01900                 FDB             GETA1    
FFD0 E297             (                  monitor1v4.ASM):01901                 FDB             GETA2
FFD2 E6BC             (                  monitor1v4.ASM):01902                 FDB             GETNIB          
FFD4 E6A7             (                  monitor1v4.ASM):01903                 FDB             GETBYTE  
FFD6 E6D7             (                  monitor1v4.ASM):01904                 FDB             PUTWORD  
FFD8 E6DB             (                  monitor1v4.ASM):01905                 FDB             PUTBYTE 
FFDA E6E5             (                  monitor1v4.ASM):01906                 FDB             PUTHEX   
FFDC E6F2             (                  monitor1v4.ASM):01907                 FDB             PUTCR    
FFDE E6FB             (                  monitor1v4.ASM):01908                 FDB             PUTMSG   
FFE0 E705             (                  monitor1v4.ASM):01909                 FDB             PUTSTR   
FFE2 E713             (                  monitor1v4.ASM):01910                 FDB             I2C_Initialize                                  
FFE4 E871             (                  monitor1v4.ASM):01911                 FDB             I2C_ReadByte                                            
FFE6 E817             (                  monitor1v4.ASM):01912                 FDB             I2C_WriteByte                                           
FFE8 E83B             (                  monitor1v4.ASM):01913                 FDB             I2C_ReadMany           
FFEA E7F1             (                  monitor1v4.ASM):01914                 FDB             I2C_WriteMany          
FFEC E831             (                  monitor1v4.ASM):01915                 FDB             RTC_ReadRegs
FFEE E7E7             (                  monitor1v4.ASM):01916                 FDB             RTC_WriteRegs
                      (                  monitor1v4.ASM):01917                                                                                    
                      (                  monitor1v4.ASM):01918 ;======================================================================
                      (                  monitor1v4.ASM):01919 ; BEGINNING OF PLATFORM DEPENDENT UTILITY FUNCTIONS             
                      (                  monitor1v4.ASM):01920 ;======================================================================
                      (                  monitor1v4.ASM):01921                                                                         
                      (                  monitor1v4.ASM):01922 ; VECTORS THROUGH RAM                                           
                      (                  monitor1v4.ASM):01923         ORG     HARD_VECT                                       
FFF0 E5C9             (                  monitor1v4.ASM):01924         FDB     RES_ENT         ; fff0 (reserved/trap)              
FFF2 E5D0             (                  monitor1v4.ASM):01925         FDB     SWI3_ENT    ; fff2 (SWI3)                       
FFF4 E5D7             (                  monitor1v4.ASM):01926         FDB     SWI2_ENT    ; fff4 (SWI2)                       
FFF6 E5DE             (                  monitor1v4.ASM):01927         FDB     FIRQ_ENT    ; fff6 (FIRQ)                       
FFF8 E626             (                  monitor1v4.ASM):01928         FDB     IRQ_ENT     ; fff8 (IRQ)                        
FFFA E634             (                  monitor1v4.ASM):01929         FDB     SWI_ENT     ; fffa (SWI/breakpoint)
FFFC E62D             (                  monitor1v4.ASM):01930         FDB     NMI_ENT     ; fffc (NMI)
FFFE E200             (                  monitor1v4.ASM):01931         FDB     RESET       ; fffe reset
                      (                  monitor1v4.ASM):01932 ;
                      (                  monitor1v4.ASM):01933         END     RESET
