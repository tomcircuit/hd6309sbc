                      (   monitor1v4.asm):00001         ;======================================================================
                      (   monitor1v4.asm):00002         ;  
                      (   monitor1v4.asm):00003         ; HD6309 SBC Singleboard Computer MONITOR ROM 
                      (   monitor1v4.asm):00004         ; Version 1.41
                      (   monitor1v4.asm):00005         ; April 26, 2020
                      (   monitor1v4.asm):00006         ; Tom LeMense
                      (   monitor1v4.asm):00007         ; tomcircuit AT gee male PERIOD com
                      (   monitor1v4.asm):00008         ;
                      (   monitor1v4.asm):00009         ; Intended to be used with the HD6309 SBC board, described here:
                      (   monitor1v4.asm):00010         ; https://hackaday.io/project/345-hd6309-singleboard-computer
                      (   monitor1v4.asm):00011         ;
                      (   monitor1v4.asm):00012         ; Specifically, this source file is for a "monitor ROM" for the SBC,
                      (   monitor1v4.asm):00013         ; and is targeted to reside in 15.5K of ROM at the top of the
                      (   monitor1v4.asm):00014         ; memory map ($C000-$FFFF), with 512 bytes of memory-mapped IO
                      (   monitor1v4.asm):00015         ; ($E000-$E1FF) and 48K of RAM from $0000-$BFFF.
                      (   monitor1v4.asm):00016         ;
                      (   monitor1v4.asm):00017         ; This file is intended to be assembled by William Astle's LWASM
                      (   monitor1v4.asm):00018         ; http://www.lwtools.ca/
                      (   monitor1v4.asm):00019         ;
                      (   monitor1v4.asm):00020         ; This monitor ROM includes the following main portions:
                      (   monitor1v4.asm):00021         ;
                      (   monitor1v4.asm):00022         ;   0) MC6839 IEEE Floating Point functions (see note)
                      (   monitor1v4.asm):00023         ;   1) HD6309 SBC platform support functions
                      (   monitor1v4.asm):00024         ;       . Zilog CIO access functions
                      (   monitor1v4.asm):00025         ;       . Zilog SCC Ch A character I/O functions
                      (   monitor1v4.asm):00026         ;       . Other misc functions
                      (   monitor1v4.asm):00027         ;       . Soft I2C and RTC functions
                      (   monitor1v4.asm):00028         ;       . SPI master functions
                      (   monitor1v4.asm):00029         ;       . SD card functions (through SPI master)
                      (   monitor1v4.asm):00030         ;   2) NoICE 6309 serial debug monitor
                      (   monitor1v4.asm):00031         ;      https://www.noicedebugger.com/
                      (   monitor1v4.asm):00032         ;   3) WOZMON port to 6809 of classic Apple 1 monitor
                      (   monitor1v4.asm):00033         ;   4) a S-Record/Intel Hex download function (also via WOZMON)
                      (   monitor1v4.asm):00034         ;
                      (   monitor1v4.asm):00035         ; 384 bytes of RAM from $BE80-$BFFF are reserved for all of this, and
                      (   monitor1v4.asm):00036         ; the system stack pointer is initialized to point to the
                      (   monitor1v4.asm):00037         ; beginning of this area, allowing the user stack to grow downward
                      (   monitor1v4.asm):00038         ; into user RAM.
                      (   monitor1v4.asm):00039         ;
                      (   monitor1v4.asm):00040         ; note: the 8K of ROM $C000-$DFFF should contain the Motorola "MC6839"
                      (   monitor1v4.asm):00041         ; IEEE Floating Point functions, which are (sadly) only availible as
                      (   monitor1v4.asm):00042         ; a binary image. As such, the source for this is not included in this
                      (   monitor1v4.asm):00043         ; file. See the MC6839 User Manual and Datasheet for more information.
                      (   monitor1v4.asm):00044         ;
                      (   monitor1v4.asm):00045         ; LICENSE:
                      (   monitor1v4.asm):00046         ;
                      (   monitor1v4.asm):00047         ; This source file is an amalgam of several components. All portions
                      (   monitor1v4.asm):00048         ; that are not otherwise covered under some license terms (e.g. the
                      (   monitor1v4.asm):00049         ; NoICE Monitor is (c) John Hartman; the WozMon port is GPL) are 
                      (   monitor1v4.asm):00050         ; free and unencumberd software and released into the public domain.
                      (   monitor1v4.asm):00051         ;
                      (   monitor1v4.asm):00052         ; Aanyone is free to copy, modify, publish, use, compile, sell, or
                      (   monitor1v4.asm):00053         ; distribute this software, either in source code form or as a compiled
                      (   monitor1v4.asm):00054         ; binary, for any purpose, commercial or non-commercial, and by any
                      (   monitor1v4.asm):00055         ; means.
                      (   monitor1v4.asm):00056         
                      (   monitor1v4.asm):00057         ; In jurisdictions that recognize copyright laws, the author or authors
                      (   monitor1v4.asm):00058         ; of this software dedicate any and all copyright interest in the
                      (   monitor1v4.asm):00059         ; software to the public domain. We make this dedication for the benefit
                      (   monitor1v4.asm):00060         ; of the public at large and to the detriment of our heirs and
                      (   monitor1v4.asm):00061         ; successors. We intend this dedication to be an overt act of
                      (   monitor1v4.asm):00062         ; relinquishment in perpetuity of all present and future rights to this
                      (   monitor1v4.asm):00063         ; software under copyright law.
                      (   monitor1v4.asm):00064         ;
                      (   monitor1v4.asm):00065         ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                      (   monitor1v4.asm):00066         ; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                      (   monitor1v4.asm):00067         ; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                      (   monitor1v4.asm):00068         ; IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
                      (   monitor1v4.asm):00069         ; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
                      (   monitor1v4.asm):00070         ; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
                      (   monitor1v4.asm):00071         ; OTHER DEALINGS IN THE SOFTWARE.
                      (   monitor1v4.asm):00072         ;
                      (   monitor1v4.asm):00073         ; For more information, please refer to <https://unlicense.org>
                      (   monitor1v4.asm):00074         ;
                      (   monitor1v4.asm):00075         ;======================================================================
                      (   monitor1v4.asm):00076         
     0141             (   monitor1v4.asm):00077         _MONITOR_REV      EQU  $0141
0000                  (   monitor1v4.asm):00078         _MON_REV_TEXT     MACRO
                      (   monitor1v4.asm):00079                           FCC "1.41"
                      (   monitor1v4.asm):00080                           ENDM
0000                  (   monitor1v4.asm):00081         _MON_REV_DATE     MACRO
                      (   monitor1v4.asm):00082                           FCC "04/29/2020"
                      (   monitor1v4.asm):00083                           ENDM
                      (   monitor1v4.asm):00084         
                      (   monitor1v4.asm):00085                  INCLUDE  "hd6309_hardware.inc"
                      (hd6309_hardware.i):00001         ;
                      (hd6309_hardware.i):00002         ; 512B from $E000-$E1FF is reserved for I/O devices:
                      (hd6309_hardware.i):00003         ; Z8536 CIO at $E000, Z85C30 SCC at $E010
                      (hd6309_hardware.i):00004         
     E000             (hd6309_hardware.i):00005         IOPAGE   EQU      $E000                             ; Base address of I/O page
     E000             (hd6309_hardware.i):00006         ZCIO     EQU      IOPAGE+$00                        ; CIO base address
     E000             (hd6309_hardware.i):00007         CIOC     EQU      ZCIO                              ; CIO port C access
     E001             (hd6309_hardware.i):00008         CIOB     EQU      ZCIO+1                            ; CIO port B access
     E002             (hd6309_hardware.i):00009         CIOA     EQU      ZCIO+2                            ; CIO port A access
     E003             (hd6309_hardware.i):00010         CIOCTL   EQU      ZCIO+3                            ; CIO control register
                      (hd6309_hardware.i):00011         
     E010             (hd6309_hardware.i):00012         ZSCC     EQU      IOPAGE+$10                        ; SCC base address
     E010             (hd6309_hardware.i):00013         ZSCCBC   EQU      ZSCC                              ;   SCC channel B command reg
     E011             (hd6309_hardware.i):00014         ZSCCBD   EQU      ZSCC+1                            ;   SCC channel B data reg
     E012             (hd6309_hardware.i):00015         ZSCCAC   EQU      ZSCC+2                            ;   SCC channel A command reg
     E013             (hd6309_hardware.i):00016         ZSCCAD   EQU      ZSCC+3                            ;   SCC channel A data reg
     0001             (hd6309_hardware.i):00017         ZSCC.RXBF EQU     $01                               ; BIT MASK FOR RX BUFFER FULL
     0004             (hd6309_hardware.i):00018         ZSCC.TXBE EQU     $04                               ; BIT MASK FOR TX BUFFER EMPTY
                      (hd6309_hardware.i):00019         
                      (hd6309_hardware.i):00020         ; I2CPORT at $E020
                      (hd6309_hardware.i):00021         ;
                      (hd6309_hardware.i):00022         ;       7     6    5    4     3     2    1    0
                      (hd6309_hardware.i):00023         ;        [DSCL][DSDA][---][---][MSCL][MSDA][---][---]
                      (hd6309_hardware.i):00024         ;      rw    rw    r    r    r     r     r    r
                      (hd6309_hardware.i):00025         ;      1     1     0    0    x     x     0    0
                      (hd6309_hardware.i):00026         ;
                      (hd6309_hardware.i):00027         ; DSCL == drive SCL 1 --> float SCL ; 0 --> drive SCL low
                      (hd6309_hardware.i):00028         ; DSDA == drive SDA 1 --> float SDA ; 0 --> drive SDA low
                      (hd6309_hardware.i):00029         ; MSCK == monitor SCL --> state of SCL
                      (hd6309_hardware.i):00030         ; MSDA == monitor SDA --> state of SDA
                      (hd6309_hardware.i):00031         
     E020             (hd6309_hardware.i):00032         I2CPORT  EQU      IOPAGE+$20                        ;soft I2C port
     0080             (hd6309_hardware.i):00033         I2C.DSCL EQU      $80
     0040             (hd6309_hardware.i):00034         I2C.DSDA EQU      $40
     0008             (hd6309_hardware.i):00035         I2C.MSCL EQU      $08
     0004             (hd6309_hardware.i):00036         I2C.MSDA EQU      $04
                      (hd6309_hardware.i):00037         
                      (hd6309_hardware.i):00038         ; SDCARD port at $E030
                      (hd6309_hardware.i):00039         ;    8 bits of data to transfer via SPI
                      (hd6309_hardware.i):00040         
     E030             (hd6309_hardware.i):00041         SDPORT   EQU      IOPAGE+$30                        ; SDPORT register address
                      (hd6309_hardware.i):00042         
                      (hd6309_hardware.i):00043         ; SYSTEM CONFIG port at $E040
                      (hd6309_hardware.i):00044         ;       7    6    5    4    3     2     1      0
                      (hd6309_hardware.i):00045         ;        [---][---][---][CONF][RA14][ROMH][ROML][ROMWS]
                      (hd6309_hardware.i):00046         ;      r    r    r    r     rw    rw    rw    rw
                      (hd6309_hardware.i):00047         ;      0    0    0    x     1     1     1     1
                      (hd6309_hardware.i):00048         ;
                      (hd6309_hardware.i):00049         ;  CONF == status of CONFIG jumper
                      (hd6309_hardware.i):00050         ;  RA14 == control ROM pin 27 (default to CONFIG jumper at reset)
                      (hd6309_hardware.i):00051         ;  ROMH == 1 --> bank ROM over $E200-$FFFF during reads (writes always go to RAM)
                      (hd6309_hardware.i):00052         ;  ROML == 1 --> bank ROM over $C000-$DFFF during reads (writes always go to RAM)
                      (hd6309_hardware.i):00053         ;  ROMWS == 1 --> insert wait state for ROM access; 0 --> no wait states for ROM
                      (hd6309_hardware.i):00054         
     E040             (hd6309_hardware.i):00055         SYSCFG   EQU      IOPAGE+$40                        ; SYSCFG register address
     0001             (hd6309_hardware.i):00056         SYS.ROMWS EQU     $01
     0002             (hd6309_hardware.i):00057         SYS.ROMSEL EQU    $02
     0004             (hd6309_hardware.i):00058         SYS.ROMSEH EQU    $04
     0008             (hd6309_hardware.i):00059         SYS.RA14 EQU      $08
                      (hd6309_hardware.i):00060         
                      (hd6309_hardware.i):00061         ; INPUT-OUTPUT port at $E050
                      (hd6309_hardware.i):00062         ;       7     6      5      4    3  2    1     0
                      (hd6309_hardware.i):00063         ;    [SDSW][SDBSY][SDCLK][SDCS][PB][0][LED2][LED1]
                      (hd6309_hardware.i):00064         ;       I     I      O      O    x       O     O
                      (hd6309_hardware.i):00065         ;  all bits readable, output bits readback
                      (hd6309_hardware.i):00066         ;
                      (hd6309_hardware.i):00067         ;  SDSW == 1 when SD card is inserted
                      (hd6309_hardware.i):00068         ;  SDBSY == 1 while SPI transaction is taking place
                      (hd6309_hardware.i):00069         ;  SDCLK = 1 --> slow SPI clock; 0 --> fast SPI clock
                      (hd6309_hardware.i):00070         ;  SDCS = 1 --> CS signal to SDcard negated; 0 --> asserted
                      (hd6309_hardware.i):00071         ;  PB == 1 when pushbutton is pressed
                      (hd6309_hardware.i):00072         ;  LEDn = 1 --> illuminate corresponding LED
                      (hd6309_hardware.i):00073         
     E050             (hd6309_hardware.i):00074         IOPORT   EQU      IOPAGE+$50                        ; INOUT register address
     0001             (hd6309_hardware.i):00075         IO.LED1  EQU      $01
     0002             (hd6309_hardware.i):00076         IO.LED2  EQU      $02
     0008             (hd6309_hardware.i):00077         IO.PB    EQU      $08
     0010             (hd6309_hardware.i):00078         IO.SDCS  EQU      $10
     0020             (hd6309_hardware.i):00079         IO.SDCLK EQU      $20
     0040             (hd6309_hardware.i):00080         IO.SDBSY EQU      $40
     0080             (hd6309_hardware.i):00081         IO.SDSW  EQU      $80
                      (hd6309_hardware.i):00082         
     E060             (hd6309_hardware.i):00083         CPLDVER  EQU      IOPAGE+$60                        ; CPLD VERSION register address
                      (hd6309_hardware.i):00084         
                      (hd6309_hardware.i):00085         ;; IOPORT LED and PB interface primitives
0000                  (hd6309_hardware.i):00086         OnLED1   MACRO
                      (hd6309_hardware.i):00087                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
                      (hd6309_hardware.i):00088                  ENDM
                      (hd6309_hardware.i):00089         
0000                  (hd6309_hardware.i):00090         OffLED1  MACRO
                      (hd6309_hardware.i):00091                  AIM      #~IO.LED1,IOPORT                  ; turn off LED1
                      (hd6309_hardware.i):00092                  ENDM
                      (hd6309_hardware.i):00093         
0000                  (hd6309_hardware.i):00094         ToggleLED1 MACRO
                      (hd6309_hardware.i):00095                  EIM      #IO.LED1,IOPORT                   ; toggle LED1
                      (hd6309_hardware.i):00096                  ENDM
                      (hd6309_hardware.i):00097         
0000                  (hd6309_hardware.i):00098         OnLED2   MACRO
                      (hd6309_hardware.i):00099                  OIM      #IO.LED2,IOPORT                   ; turn on LED2
                      (hd6309_hardware.i):00100                  ENDM
                      (hd6309_hardware.i):00101         
0000                  (hd6309_hardware.i):00102         OffLED2  MACRO
                      (hd6309_hardware.i):00103                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
                      (hd6309_hardware.i):00104                  ENDM
                      (hd6309_hardware.i):00105         
0000                  (hd6309_hardware.i):00106         ToggleLED2 MACRO
                      (hd6309_hardware.i):00107                  EIM      #IO.LED2,IOPORT                   ; toggle LED2
                      (hd6309_hardware.i):00108                  ENDM
                      (hd6309_hardware.i):00109                  
0000                  (hd6309_hardware.i):00110         OnLEDS   MACRO
                      (hd6309_hardware.i):00111                  OIM      #(IO.LED1+IO.LED2),IOPORT        ; turn on LED1 + LED2
                      (hd6309_hardware.i):00112                  ENDM
                      (hd6309_hardware.i):00113         
0000                  (hd6309_hardware.i):00114         OffLEDS  MACRO
                      (hd6309_hardware.i):00115                  AIM      #~(IO.LED1+IO.LED2),IOPORT       ; turn off LED1 + LED2
                      (hd6309_hardware.i):00116                  ENDM
                      (hd6309_hardware.i):00117         
0000                  (hd6309_hardware.i):00118         StatusPB MACRO
                      (hd6309_hardware.i):00119                  TIM      #IO.PB,IOPORT                     ; check the pushbutton
                      (hd6309_hardware.i):00120                  ENDM
                      (hd6309_hardware.i):00121         
                      (hd6309_hardware.i):00122         ;; I2C interface primitives
0000                  (hd6309_hardware.i):00123         I2C_StatSDA MACRO
                      (hd6309_hardware.i):00124                  TIM      #I2C.MSDA,I2CPORT                 ;(Z = 1 if SDA is low)
                      (hd6309_hardware.i):00125                  ENDM
                      (hd6309_hardware.i):00126         
0000                  (hd6309_hardware.i):00127         I2C_SinkSDA MACRO
                      (hd6309_hardware.i):00128                  AIM      #~I2C.DSDA,I2CPORT                ;Drive SDA line low
                      (hd6309_hardware.i):00129                  ENDM
                      (hd6309_hardware.i):00130         
0000                  (hd6309_hardware.i):00131         I2C_ReleaseSDA MACRO
                      (hd6309_hardware.i):00132                  OIM      #I2C.DSDA,I2CPORT                 ;Release SDA line
                      (hd6309_hardware.i):00133                  ENDM
                      (hd6309_hardware.i):00134         
0000                  (hd6309_hardware.i):00135         I2C_StatSCL MACRO
                      (hd6309_hardware.i):00136                  TIM      #I2C.MSCL,I2CPORT                 ;(Z = 1 if SCL is low)
                      (hd6309_hardware.i):00137                  ENDM
                      (hd6309_hardware.i):00138         
0000                  (hd6309_hardware.i):00139         I2C_SinkSCL MACRO
                      (hd6309_hardware.i):00140                  AIM      #~I2C.DSCL,I2CPORT                ;Drive SCL line low
                      (hd6309_hardware.i):00141                  ENDM
                      (hd6309_hardware.i):00142         
0000                  (hd6309_hardware.i):00143         I2C_ReleaseSCL MACRO
                      (hd6309_hardware.i):00144                  OIM      #I2C.DSCL,I2CPORT                 ;Release SCL line
                      (hd6309_hardware.i):00145                  ENDM
                      (hd6309_hardware.i):00146         
0000                  (hd6309_hardware.i):00147         I2C_ReleaseBoth MACRO
                      (hd6309_hardware.i):00148                  OIM      #(I2C.DSCL+I2C.DSDA),I2CPORT      ;Release both SDA and SCL lines
                      (hd6309_hardware.i):00149                  ENDM
                      (hd6309_hardware.i):00150                  
0000                  (hd6309_hardware.i):00151         I2C_BitDelay MACRO
                      (hd6309_hardware.i):00152                  NOP
                      (hd6309_hardware.i):00153                  ENDM         
                      (hd6309_hardware.i):00154         
0000                  (hd6309_hardware.i):00155         I2C_StretchSCL MACRO
0000                  (hd6309_hardware.i):00156         I?SSH    NOP
                      (hd6309_hardware.i):00157                  I2C_ReleaseSCL                             ; try to release SCL
                      (hd6309_hardware.i):00158                  NOP
                      (hd6309_hardware.i):00159                  I2C_StatSCL                                ; check is SCL is really high yet
                      (hd6309_hardware.i):00160                  BEQ      I?SSH                             ; if SCL is still low -> try again
                      (hd6309_hardware.i):00161                  ENDM
                      (hd6309_hardware.i):00162         
                      (hd6309_hardware.i):00163         ;; SPI interface primitives
0000                  (hd6309_hardware.i):00164         SPI_FastMode MACRO
                      (hd6309_hardware.i):00165                  AIM      #~IO.SDCLK,IOPORT                 ; set SPI to fast mode
                      (hd6309_hardware.i):00166                  ENDM
                      (hd6309_hardware.i):00167         
0000                  (hd6309_hardware.i):00168         SPI_SlowMode MACRO
                      (hd6309_hardware.i):00169                  OIM      #IO.SDCLK,IOPORT                  ; set SPI to slow mode
                      (hd6309_hardware.i):00170                  ENDM
                      (hd6309_hardware.i):00171         
0000                  (hd6309_hardware.i):00172         SPI_Status MACRO
                      (hd6309_hardware.i):00173                  TIM      #IO.SDBSY,IOPORT                  ; check the SPI busy bit (Z=0 means busy)
                      (hd6309_hardware.i):00174                  ENDM
                      (hd6309_hardware.i):00175         
                      (hd6309_hardware.i):00176         ;; SD card interface primitives
0000                  (hd6309_hardware.i):00177         SD_AssertCS MACRO
                      (hd6309_hardware.i):00178                  AIM      #~IO.SDCS,IOPORT                  ; assert SD card select
                      (hd6309_hardware.i):00179                  ENDM
                      (hd6309_hardware.i):00180         
0000                  (hd6309_hardware.i):00181         SD_NegateCS MACRO
                      (hd6309_hardware.i):00182                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
                      (hd6309_hardware.i):00183                  ENDM
                      (hd6309_hardware.i):00184         
0000                  (hd6309_hardware.i):00185         SD_CardPresent MACRO
                      (hd6309_hardware.i):00186                  TIM      #IO.SDSW,IOPORT                   ; examine SD card switch
                      (hd6309_hardware.i):00187                  ENDM
                      (   monitor1v4.asm):00086                  
     0001             (   monitor1v4.asm):00087         TRUE              EQU  1
     0000             (   monitor1v4.asm):00088         FALSE             EQU  0
                      (   monitor1v4.asm):00089                  
     0003             (   monitor1v4.asm):00090         CPU_FREQ_MHZ      EQU  3
     0001             (   monitor1v4.asm):00091         COPY_MON_TO_RAM   EQU  TRUE
     0001             (   monitor1v4.asm):00092         COMMON_TEXT_BUFFER EQU TRUE
                      (   monitor1v4.asm):00093         
                      (   monitor1v4.asm):00094         ; Map SCC channels to "CONSOLE" and "DEBUG"
                      (   monitor1v4.asm):00095         ; Default is CONSOLE is SCC channel A, DEBUG is SCC channel B
     0001             (   monitor1v4.asm):00096         SCC_CHA           EQU  1
     0002             (   monitor1v4.asm):00097         SCC_CHB           EQU  2
     0001             (   monitor1v4.asm):00098         CONSOLE_CH        EQU  SCC_CHA
     0002             (   monitor1v4.asm):00099         DEBUG_CH          EQU  SCC_CHB
                      (   monitor1v4.asm):00100         
                      (   monitor1v4.asm):00101         ;  Condition Code Register bits
     0001             (   monitor1v4.asm):00102         CC_C              EQU  $01
     0002             (   monitor1v4.asm):00103         CC_V              EQU  $02
     0004             (   monitor1v4.asm):00104         CC_Z              EQU  $04
     0008             (   monitor1v4.asm):00105         CC_N              EQU  $08
     0010             (   monitor1v4.asm):00106         CC_I              EQU  $10
     0020             (   monitor1v4.asm):00107         CC_H              EQU  $20
     0040             (   monitor1v4.asm):00108         CC_F              EQU  $40
     0080             (   monitor1v4.asm):00109         CC_E              EQU  $80
                      (   monitor1v4.asm):00110         
                      (   monitor1v4.asm):00111         ;  Other defines
     000D             (   monitor1v4.asm):00112         CR                EQU  $0D                          ;CARRIAGE RETURN
     000A             (   monitor1v4.asm):00113         LF                EQU  $0A                          ;LINE FEED
     0020             (   monitor1v4.asm):00114         SPACE             EQU  $20
                      (   monitor1v4.asm):00115         
                      (   monitor1v4.asm):00116         ;  Platform dependent memory information
     BF00             (   monitor1v4.asm):00117         RAM_START         EQU  $BF00                        ; START OF RESERVED RAM
     C000             (   monitor1v4.asm):00118         ROML_START        EQU  $C000                        ; START OF LOW ROM (ROM IMAGE)
     E200             (   monitor1v4.asm):00119         ROMH_START        EQU  $E200                        ; START OF HIGH ROM
     FF40             (   monitor1v4.asm):00120         JUMP_TABLE        EQU  $FF40                        ; START OF UTILITY JUMP TABLE
     FFF0             (   monitor1v4.asm):00121         HARD_VECT         EQU  $FFF0                        ; START OF HARDWARE VECTORS
                      (   monitor1v4.asm):00122         
                      (   monitor1v4.asm):00123         
                      (   monitor1v4.asm):00124         ;======================================================================
                      (   monitor1v4.asm):00125         ;         RAM STORAGE USED BY *ALL* PORTIONS STARTS HERE
                      (   monitor1v4.asm):00126         ;======================================================================
                      (   monitor1v4.asm):00127                           ORG  RAM_START
                      (   monitor1v4.asm):00128                           
                      (   monitor1v4.asm):00129         ;  Initial user stack
     BF00             (   monitor1v4.asm):00130         INITSTACK         EQU  *                            ; user stack starts below monitor stack
                      (   monitor1v4.asm):00131                           ALIGN 128,$00         
                      (   monitor1v4.asm):00132         
                      (   monitor1v4.asm):00133               IFEQ (COMMON_TEXT_BUFFER)                     ; 128B RAM for WOZMON below NoICE RAM         
BF00                  (   monitor1v4.asm):00134         WOZ_RAM           RMB  128                          ; storage for WOZMON input buffer, vars (on $80 boundary)
                      (   monitor1v4.asm):00135               ENDC
                      (   monitor1v4.asm):00136         
                      (   monitor1v4.asm):00137         ;  NoICE Communications buffer
                      (   monitor1v4.asm):00138         ;  (Must be at least as long as TASK_REG_SZ.  At least 19 bytes recommended.
                      (   monitor1v4.asm):00139         ;  Larger values may improve speed of NoICE memory move commands.)
     0080             (   monitor1v4.asm):00140         COMBUF_SIZE       EQU  128                          ; DATA SIZE FOR COMM BUFFER
BF00                  (   monitor1v4.asm):00141         COMBUF            RMB  2+COMBUF_SIZE+1              ; BUFFER ALSO HAS FN, LEN, AND CHECK
                      (   monitor1v4.asm):00142         
                      (   monitor1v4.asm):00143               IF (COMMON_TEXT_BUFFER)                       ; use NoICE Communications buffer as WOZMON RAM
     BF00             (   monitor1v4.asm):00144         WOZ_RAM  EQU      COMBUF
                      (   monitor1v4.asm):00145               ENDC
                      (   monitor1v4.asm):00146         
                      (   monitor1v4.asm):00147         ;  RAM interrupt vectors (first in SEG for easy addressing, else move to their own SEG)
     0008             (   monitor1v4.asm):00148         NVEC              EQU  8                            ; number of vectors
BF83                  (   monitor1v4.asm):00149         RAMVEC            RMB  2*NVEC
     BF83             (   monitor1v4.asm):00150         RV_TRAP           EQU  RAMVEC
     BF85             (   monitor1v4.asm):00151         RV_SWI3           EQU  RAMVEC+2
     BF87             (   monitor1v4.asm):00152         RV_SWI2           EQU  RAMVEC+4
     BF89             (   monitor1v4.asm):00153         RV_FIRQ           EQU  RAMVEC+6
     BF8B             (   monitor1v4.asm):00154         RV_IRQ            EQU  RAMVEC+8
     BF8D             (   monitor1v4.asm):00155         RV_SWI            EQU  RAMVEC+10
     BF8F             (   monitor1v4.asm):00156         RV_NMI            EQU  RAMVEC+12
                      (   monitor1v4.asm):00157         ;
                      (   monitor1v4.asm):00158         ;  NoICE DEbug Monitor stack
                      (   monitor1v4.asm):00159         ;  (Calculated use is at most 7 bytes.  Leave plenty of spare)
BF93                  (   monitor1v4.asm):00160                           RMB  24
BFAB                  (   monitor1v4.asm):00161         MONSTACK
                      (   monitor1v4.asm):00162         ;
                      (   monitor1v4.asm):00163         ;  NoICE Test Stack is for fake RTI instruction (14 bytes in 6309 Native Mode)
BFAB                  (   monitor1v4.asm):00164         TEST_STACK        RMB  14
                      (   monitor1v4.asm):00165         ; It is not possible to read bits 0 and 1 of regMD so the next three
                      (   monitor1v4.asm):00166         ; lines enable testing of these bits.
BFB9                  (   monitor1v4.asm):00167         E_FLAG            RMB  1                            ; 0=not set $80=set
BFBA                  (   monitor1v4.asm):00168         S_IMAGE           RMB  2                            ; temporary store for regS
                      (   monitor1v4.asm):00169         ;  NoICE Target registers:  order must match that in TRGHC11.C
BFBC                  (   monitor1v4.asm):00170         TASK_REGS
BFBC                  (   monitor1v4.asm):00171         REG_STATE         RMB  1
BFBD                  (   monitor1v4.asm):00172         REG_PAGE          RMB  1
BFBE                  (   monitor1v4.asm):00173         REG_SP            RMB  2
BFC0                  (   monitor1v4.asm):00174         REG_U             RMB  2
BFC2                  (   monitor1v4.asm):00175         REG_Y             RMB  2
BFC4                  (   monitor1v4.asm):00176         REG_X             RMB  2
BFC6                  (   monitor1v4.asm):00177         REG_F             RMB  1                            ; F BEFORE E, SO W IS LEAST SIG. FIRST
BFC7                  (   monitor1v4.asm):00178         REG_E             RMB  1
BFC8                  (   monitor1v4.asm):00179         REG_B             RMB  1                            ; B BEFORE A, SO D IS LEAST SIG. FIRST
BFC9                  (   monitor1v4.asm):00180         REG_A             RMB  1
BFCA                  (   monitor1v4.asm):00181         REG_DP            RMB  1
BFCB                  (   monitor1v4.asm):00182         REG_CC            RMB  1
BFCC                  (   monitor1v4.asm):00183         REG_MD            RMB  1
BFCD                  (   monitor1v4.asm):00184         REG_V             RMB  2
BFCF                  (   monitor1v4.asm):00185         REG_PC            RMB  2
     0015             (   monitor1v4.asm):00186         TASK_REG_SZ       EQU  *-TASK_REGS
                      (   monitor1v4.asm):00187         
     BFD1             (   monitor1v4.asm):00188         RAM_END           EQU  *                            ; ADDRESS OF TOP+1 OF RAM
                      (   monitor1v4.asm):00189         
                      (   monitor1v4.asm):00190               IFGT     (RAM_END-ROML_START)
                      (   monitor1v4.asm):00191                  ERROR    "RESERVED RAM OVERLAPS WITH ROM IMAGE"
                      (   monitor1v4.asm):00192               ENDC
                      (   monitor1v4.asm):00193         
                      (   monitor1v4.asm):00194         ;======================================================================
                      (   monitor1v4.asm):00195         ;                    ROM IMAGE BEGINS HERE
                      (   monitor1v4.asm):00196         ;======================================================================
                      (   monitor1v4.asm):00197         
                      (   monitor1v4.asm):00198         ;======================================================================
                      (   monitor1v4.asm):00199         ; Part 0 - Motorola 6839 Floating Point ROM (8KB binary image)
                      (   monitor1v4.asm):00200         ;======================================================================
                      (   monitor1v4.asm):00201                  ORG      ROML_START
C000 87CD2000001EB182 (   monitor1v4.asm):00202                  INCLUDEBIN float09.bin
     B8025245C7003D00
     00009B535441CB00
     3F000000B9004650
     4FB9434F50595249
     4748542028432920
     4D4F544F524F4C41
     2031393832200220
     083477308D002220
     063477308D004410
     AE69E6A4C43FC126
     2F02C628EC85308B
     A6A010AF69316D6E
     8400800080008000
     80008000C800C800
     CB00CB007B007B01
     040100015501A900
     7B007B0193013F01
     2800AF019A019A01
     9A019A019A01F901
     F901F901F901D901
     D902780287034903
     D701D901D903B002
     EE02BB0085316933
     A5ECA4EDC4EFA435
     7710EEE4395032E5
     3432306550CB0531
     E5C60DA6A0A7805A
     26F935B217065720
     1017065210AEC83B
     30C8255F1703B224
     1CC60110AEC83930
     C8181703A4240E17
     12011705F42406AE
     C83717050C170666
     35F710AEC83B30C8
     255F2009C60110AE
     C83930C818170379
     395F2002C601AE63
     17060334048DDB24
     268DE124221711C3
     1705B6241A6DE427
     166D4E260AA6C834
     8A04A7C8342008A6
     C8348404A7C83420
     ACC60120015F1705
     CD34048DAF241817
     11911705842410AE
     C837EC4EED846DE4
     2705ECC810ED0220
     841705AA10AEC839
     ECA4EDC81BEC22ED
     C81D2602ECA4200C
     17059310AEC839EC
     A4EDC81B26058602
     A7C82416FF49EC67
     1702742629AE6310
     AE6581022D08E628
     E708E629E7098101
     2D08EC26ED06EC24
     ED04EC22ED02ECA4
     ED8435F7200E869A
     AE671705495F17FF
     2D16FF0917053FAE
     C83BE68819E74910
     AEC83B10AFC81B16
     FEF5170529ECC83B
     ED48AEC837AF4E17
     FF0224061710E417
     04D716FEE8170544
     30C818170273241D
     8D25340231A630C8
     25170265240F3420
     1710C01704B33510
     24031703CCE6E4CB
     0217052216FE5E34
     20A64544318D05D9
     A6A635A017050530
     C818170234240D17
     10911704842405AE
     4117039D1704F7C6
     0216FE31C60517FE
     3CAE69A61FAEE812
     1704D96FC83F818E
     26056CC83F200781
     D026036CC83F8DAF
     8B4830C6AFC8425F
     170579C00330856D
     C83F2702301FAFC8
     4031C84830C818C6
     011701D5242110AE
     C84230C8255F1701
     C824141710251704
     18240CAEC8406DC8
     3F2704A64EA703A6
     C834A784ECC83DED
     0117047A357710EE
     6335811704668D28
     240610AE4E10AF1E
     20161704578D1924
     0D10AE4E10AF1C10
     AEC81010AF1E8002
     1F8917044916FD85
     30C81817016B240D
     170FC817FF19AE41
     30861703B4398D2B
     8100271081202607
     C60217FD702005C6
     0417FD6986261704
     0BC604AEA4AFC81B
     AE22AFC81D2602AE
     A42028A6F80D84E0
     398DF88100271081
     202607C60417FD3D
     2005C60617FD3686
     241703D8C602AEA4
     AFC81B340427056F
     C82420058602A7C8
     24170F5717034A24
     0FAE41E6E4308517
     FE9D403086170259
     3504A6451703AF10
     8300042605C60216
     FCE335F7ECA48D57
     2605C60416FCD6EC
     A486103D4D2609C1
     202D05C60217FCD5
     869AAEA417037531
     2230C8185F1700A1
     241D170EFEAE4130
     025F17041F308517
     FE454030861F1017
     02DF24031701FA17
     035431C83F3420A3
     E11026FC8835F71F
     98840F340286103D
     A1E03917032EA6A8
     19A74910AFC81B17
     0EB917FE0A1F8950
     1DE341C3001A1F01
     17029E24031701B9
     20BD17FF0E810026
     07C61317FC572010
     81202607C60F17FC
     4C2005C60D17FC45
     861C1702E7A6A0A7
     4930C83FAF4E30C8
     1817000D2406170E
     6A17025D1702D735
     F73406A6A48480A7
     8417035B26048D12
     200CC10226051700
     8420031700F01A01
     3586EC22ED04E6A4
     A6214959448A80A7
     034F83007FED0110
     83FF81271F108300
     8027033920148D45
     CC7FFFED0117028F
     27048D2320048604
     A70C201A8D2F1702
     7E270A6C028608A7
     0C8D272009CC8000
     ED018602A70C3986
     06A70CA603492B01
     398605170B791701
     D032643586680364
     0339A6D803850827
     0317025639860634
     6231213303ECA058
     4958495849A7C06A
     E426F2E7C43562A6
     038A80A703ECA444
     5644564456445684
     078303FFED011083
     FC01271F10830400
     27033920148DAECC
     7FFFED011701F827
     048D8C20048604A7
     0C201A8D981701E7
     270A6C028608A70C
     8D902009CC8000ED
     018602A70C39EC22
     ED03EC24ED05EC26
     ED07EC28ED09ECA4
     847F108340002622
     1701B4260BCC8000
     ED018602A70C2010
     CCC000ED016D032B
     378608A70C17FF4A
     202E10833FFF2619
     68036403CC7FFFED
     0117018326068604
     A70C200317FF1020
     0F4847ED016D032C
     033920048608A70C
     393427314BE64526
     048D0F200BC10226
     048D3A20031700A4
     35A7EC2348ED01A6
     25A703EC21108380
     0026034F20171083
     7FFF26034F200EC3
     007F108300012605
     6D232D015F546601
     EAA4E784398D5CEC
     01847F4456660366
     0466056606660744
     5666036604660566
     0666074456660366
     04660566066607ED
     01EC211083800026
     034F201810837FFF
     26048607200EC303
     FF1083000126056D
     232D015F58495849
     58495849EA01AAA4
     ED8439EC23ED01EC
     25ED03EC27ED05A6
     29A7073930018DEB
     A62AA708301FEC21
     1083800026034420
     0B10837FFF260344
     2002847FAAA4ED84
     396D4626031A0139
     3416AE43EC468501
     2702E703AA02A702
     E601A6C485402702
     CA10E446270F86FF
     4C5424FC3476AD98
     04357620021A01CC
     0000ED46359632E8
     CEEEE835EF63A7E4
     AF6833E8323436CC
     00008E0000318436
     3636363636363636
     36363636163366AF
     465C1700A2E74535
     366ED83232E8CE10
     AF61EE3E20C6AEE4
     32C432E8346E84EC
     03260EEC05260AEC
     072606EC092602A6
     0B3934266F0C6FE2
     8DE5260DCC8000ED
     018602A70C1A0420
     5210AE01A6036DE4
     26054D2B46200710
     AC632E02203D313F
     108C8000260DA703
     10AF018608A70C1A
     022028680B690A69
     0969086907690669
     056904496DE42605
     4D2AD3200710AC63
     2F0220CAA70310AF
     011CF9326135A634
     26C601E7E220916D
     C42D0CE6D8035454
     5454C40E39201534
     02A6495D26078470
     4444442003840748
     1F8935823410308D
     00078DD354E68535
     9004080A0A0A1708
     94A6C825A8C8182C
     11A6D80384068106
     2D068680A74B2002
     6F4B39A6D8038401
     2F14A6C825A8C818
     2D05170868200586
     0217082920058608
     17082239A6468A08
     A7461708B139EC4C
     10837FFF27231083
     8000271DA6458102
     2E171708722609EC
     4C830001ED4C2009
     A64E2D0586101707
     EC39008004003FFF
     3FFF3FFFFF81FC01
     C000C000C0000019
     0036004100190036
     318CF3308D078DE6
     453A31A5EC84A34C
     304B10A3A42F0517
     16B120031716CB17
     00AA17FE8A260CCC
     8000ED4C8602A7C8
     172009308CB6E645
     EC85ED4CA6D80384
     068100270A810227
     06A64684FBA74639
     A6468A40A746A6D8
     0384068106261C8D
     46A64B2D0EA64E2C
     06308D071A8D4D8D
     3D2006308D06E98D
     49202B8104261C8D
     26A64B2C0EA64E2C
     06308D06FA8D338D
     1D2006308D06C98D
     23200B308D06C231
     4CC60C1707DE39A6
     4684FDA74639E645
     308DFF2EEC858300
     01ED4C39314B1715
     B439314B1715AE86
     80A74B39E6455431
     8D007FA6A5340258
     58318D006131A5E6
     A4A685A4E4AA4AA7
     4A3261A685A421AA
     4A274AA6468A40A7
     46A6D80384068106
     260AA6842C04EC22
     8D4D202C8104260A
     A6842D04EC228D3F
     201E8100261AE6A4
     A685A4212712A64A
     260AE622A685A423
     26022004ECA48D1F
     E64517069B390680
     0501090409080B80
     0A01068005010904
     09087F037F7F03EB
     86E786C400594A81
     032D115D270AEB86
     E786C400594A2002
     860220EB5D271586
     03A1A42C07566686
     594C20F5EC015C26
     014CED01393416E6
     45308D001A3AEC4C
     E384ED4C35963416
     E645308D00093AEC
     4CA384ED4C359600
     C00600600000C006
     00EC4C10837FFF27
     1CE645308DFE1B3A
     EC4C10A3842D0AA6
     468A02A7461A0420
     021CFB20021CFB39
     E645308D05AE3AEC
     4C10838000271310
     A3842C0AA6468A04
     A7461A0420021CFB
     20021CFB3934065A
     4FC1012D0946A685
     498D1F5A20F34635
     8634065A86018101
     2D0DC1002E022007
     AB858D065A20EF46
     3586810A2D08800A
     A78586012003A785
     4F393278E7E4A6A4
     2C02860FA7848600
     E6E45AC1012D05A7
     855A20F7EC211083
     FFFF2D4AAF6630A4
     6F4A83003F4353C3
     00011714753103AE
     668600E6A6C10026
     0981072E054CE6A6
     20F3C680E7648107
     2E1AE6E417FF6EE6
     A6E4645D2705E6E4
     17FF766664240366
     644C20E2313D3268
     393276AE4EAFE430
     C818A603E684ED62
     6F8417FBEA260B86
     02A7C82417025416
     0120327331E41713
     9CE645C1042D0517
     1140201DA66F2C05
     1711372014C10026
     06308D0214200430
     8D021B31C8181713
     74A6D803E6C4EDE8
     11E645E7E8138419
     8A42A7D8038604A7
     458616A7C417026D
     6F48EC4810830011
     2F0A86071704A0CC
     0011ED48EC4EC300
     01A348EDE8156FE8
     14A6E81184198A40
     A7D803ECE8152C05
     4353C30001170FC7
     304B31C818171315
     30E431C82517130D
     304BC60C170469A6
     E8152D0517098F20
     031708CEA6E811A7
     D803304B31C81817
     12EBA6E810A7A417
     02EB6F4BA66FA7C8
     17ECE8158D5DEDE8
     1524146CE814A66F
     2C0BA6E81481012E
     02208E2002208A32
     6DA663A74B314BAE
     E43005C61417FE7A
     314B5FC10D2C056F
     A55C20F76FA4EC68
     2C074353C3000163
     A4ED23CC000FED21
     AEE4C60517FE536F
     8819A64684BFA746
     326A393416327330
     4B31E417126F327B
     6F6486FFA763A6C4
     A762868EA7C48604
     A745EC48EDE4170E
     FE304B31C8181712
     4C306531C8251712
     44AE8D00CEAF4817
     0532A64E261BECE4
     5D26014A5A170ED7
     ECE8125C26014CED
     E81286FFA7641600
     8E308D0F5631C825
     171212171022304B
     31C8181712073065
     31C8251711FFAE8D
     008BAF481704EDA6
     4E2612ECE8125C26
     014CEDE8126F6386
     FFA7642052ECE45D
     26014A5A170E8030
     4B31C8251711CE30
     8D0F0831C8181711
     C41710CE304B31C8
     181711B9306531C8
     251711B1AE8D003F
     AF4817049FA64E26
     16A6E8112C11ECE8
     125D26014A5AEDE8
     126F6386FFA764A6
     62A7C4ECE4ED48A6
     6426073065314B17
     117BA663434632E8
     12359604220C2206
     2280000598EC594F
     F1D857AA00008000
     0899FA125E5A9103
     9B0000AE4E861A81
     002F054A6F8620F7
     A6C8248104260FA6
     C8182D04860A2002
     860BA78420468106
     2631860CA78431C8
     1BC602C1002F0969
     22692169A45A20F3
     5FC1042C145CA6A4
     44444444A7855CA6
     A4840FA785312120
     E820118102260DA6
     C8182D0486002002
     860FA705391700ED
     A6C481162606308D
     00692004308D0065
     EC4C108300002C17
     CC0000ED4ECC0000
     EDC810A6C8348A04
     84F4A7C834204310
     A3842D048D41203A
     314E10A3842C101C
     FE66A46621662266
     235C26014C20EBA6
     C83484F0E6C8182C
     1663A46321632260
     23250A6C2226066C
     2126026CA48A08A7
     C83439000F001FE6
     C834C4F2CA02E7C8
     34A6C8182D0FEC8D
     0027ED4EEC8D0023
     EDC8102015E6C834
     CA08E7C834EC8D00
     14ED4EEC8D0010ED
     C810A6468A20A746
     397FFFFFFF800000
     00CC0103ED4630C8
     18314B17101F1CFE
     6925692469236925
     69246923A6C83484
     F18A01A7C83439A6
     C83484F48A04A7C8
     341701E33930C818
     314B170FF017F827
     2602205BE6453404
     308D00543AEC4C10
     A3842C491083FFFE
     2E196F4A304B1710
     22E6E4308D0039EC
     85ED4CCC0000EDC8
     192014308D0029E6
     E4EC85ED4CA3C819
     6F4A304B17101B30
     4B17F9F8A6C81B2C
     0517F7E6200710AE
     C81917F84A326139
     00170034003F0017
     0034030608030630
     4BC60CC1002D056F
     855A20F7A6C48124
     2606318DFEF52004
     318DFEF1ECA4ED4C
     ECC81BED4EECC81D
     EDC810A64E2C1A86
     80A74B304E638463
     0163026003250A6C
     0226066C0126026C
     84304B17F77CA6C4
     81262613A6458100
     2604200620098106
     2605A74A17F96D39
     007FFF0000000000
     0000000004008000
     0000000000000000
     0004007FFF000000
     0000000000000600
     0000FFFFFFFFFFFF
     FFFFFF00FF82FC02
     C000C000C0003436
     308CD7314B170ECD
     ECC83D304E445666
     0244566602ED8435
     B686018D10398604
     8D0B3986098D0639
     860A8D01398DCFA7
     47A6468A01A74639
     3416318D002054A6
     A558C10226022004
     C1082607E686C4F8
     E7864C810C2C056F
     864C20F735960609
     0B0609030030C825
     314B170E688D0C39
     30C818314B170E5D
     8D013917F9C2260B
     17F7DDA64684FBA7
     462013304BA6458D
     0E260B81022E07EC
     4C830001ED4C3934
     36E6032D11318DFF
     4BECA610A3012604
     1A0420021CFB35B6
     8DB68680A74B3930
     8DFF0A8D1139308D
     FEF68D0A398DA1A6
     4B8880A74B39314B
     170DFAA6C825A8C8
     18A74B39A680A7A0
     5A2EF939A6C825A8
     C8182C0EA6C8252C
     04C6022002C60816
     0067ECC82610A3C8
     19271F3401A6C825
     2D0C35012F04C608
     2002C602200A3501
     2F04C6022002C608
     203F30C82831C81B
     5FA685A1A5260BC1
     092D0220055CA685
     20F13401C1092D06
     C6043261201BA6C8
     252D0C35012504C6
     082002C602200A35
     012504C6022002C6
     0817008D39A6D803
     44240DA6C8182D04
     C6022002C6082002
     C60117007439A6D8
     0344240DA6C8252D
     04C6082002C60220
     02C6018D5C39A6D8
     03442504C6042017
     A6C825A8C8182D04
     C604200BA6C8252C
     04C6022002C6088D
     3839C6018D3339C6
     048D2E3930C8258D
     133930C8188D0D39
     30C82517F54430C8
     188D013917F53BA6
     C831ABC824810426
     048DD4200317FEF4
     39A6C4818E260420
     2E200681D0260220
     26A6C83484F0C104
     26048A042014C102
     26048A08200CC101
     26088A01C610EA46
     E746A7C834203B34
     04C4042606E6E4CA
     10E7E4E44827046F
     4E200486FFA74E35
     028401271DA6468A
     10A746A648811026
     046F4E200D810427
     0981012705860617
     FDC5391375137513
     4313A713D9141F14
     1F141F141F140B14
     1514511451146514
     5B146F147918880F
     CF0FCFE6C4C43FC1
     02260FA6C8248106
     2708A6C8188880A7
     C818318CBEC1222C
     11ECA5318DECD131
     ABA6C831C6053DEB
     C824ECA5318DECC0
     ADAB391522113711
     3E10E81522113711
     37109B10E8113711
     3E109B113E10E811
     3E10DD10DD10DD11
     3010DD1522113711
     3E10E815221D601D
     6010E810E81D601D
     60084610E810E810
     E810DD10DD086310
     E810DD10DD10DD10
     DD113010DD1D6010
     DD10E810E81D6015
     DE0884113710E810
     9611371096113710
     E81137113E113E10
     9610E8113E10DD10
     DD10DD113010DD15
     DE0884113710E810
     9616B110A010DD10
     E810A010DD10A010
     DD10E810A010A010
     A010A010E810A010
     DD10DD10DD113010
     DD16B110A010DD10
     E810A0177F10E818
     5010E810910F5510
     E810E810E80F5511
     64116411E5123A12
     4A1164123F11E512
     3A124A11FE11FE12
     16123A11FE123A12
     3A123A123A123A12
     44124411E5123A12
     500E650F470EDF0F
     210E650B890DFB0D
     FB0DFB0B8914B410
     E810E810E8148315
     0D150D150D10E815
     0D15131513151310
     E81513E64986103D
     E649C40710830001
     2607860F17FC0E20
     1A81022D14C1022C
     1030C8184817FC6F
     2707861017FBF620
     028D013930C81831
     4B170A91A6498407
     318DFC12E6A65C4F
     C10C2C05AA855C20
     F7A74A17F5E22617
     AE43A6018404270A
     304B17F58017F4BC
     200317F3EB200530
     4B17F4B017F39717
     F5972610AE43A601
     8402270517F56F20
     0317F41C3917FBD8
     6F4B3917FBD2A64B
     8880A74B39020607
     020632E8E8A64544
     308CF2E686E762A6
     C825A8C818A763EC
     C826E3C819C30001
     ED644F5FED66ED68
     ED6AED6CED6EEDE8
     10EDE812EDE81430
     C82831C81BE66258
     E7E4C1002D383366
     33C5A662A7618100
     2D25E6E4E061E162
     2E17C1002D0DA686
     E6A53DE3C4EDC424
     026C5F6A61A66120
     0486FFA76120D7E6
     E45AE7E420C43388
     D83063A6032D0317
     0912EC0110838000
     26031709223003E6
     45318DFA0D5431A5
     E662585C4FE1A42F
     05AA855A20F7A74A
     301D314B17097617
     093B32E81839327A
     A64544308D0880E6
     865AE7E4308D087C
     E686E761A6C825A8
     C818A74BECC826A3
     C819ED4C30C82831
     C81B334E8680A764
     4FA762A765A763A1
     612C686D6226124F
     E686E1A62609A1E4
     2C074CE68620F325
     2CA663E664EAC6E7
     C6EC07A327ED07EC
     05E226A225ED05EC
     03E224A223ED03EC
     01E222A221ED01E6
     84E2A4E7844F6908
     6907690669056904
     6903690269016984
     C60059E762666424
     0466646C636C65A6
     65209433524FA1E4
     2E0D6D862706860A
     A74A20014C20EF30
     4BA6032D0317081C
     EC01108380002603
     17082C1708673266
     39327BA64544308D
     07ADE6865AE7E4EC
     C826A3C819C30001
     ED6330C82831C81B
     6F616F6210830000
     2F4B6D6126164FE6
     86E1A62609A1E42C
     0B4CE68620F32204
     6F6220078601A762
     1707764F69086907
     6906690569046903
     690269016984C600
     59E761ECC8268300
     01EDC826EC638300
     01ED6320AFE66127
     0856301D1707A830
     03EC3E83000110A3
     1E2D1A2E2F4FE686
     E1A6260FA1E42D06
     6D622609201E4CE6
     8620ED2517A61D88
     80A73DA645340286
     04A7451705FA3502
     A7452008314B30C8
     251707D9304B17F0
     211707993265396D
     C8182708860117F9
     1C1600C33278308D
     06D5A64544E6865A
     E7E4308D06CEE686
     E76130C81B314EEC
     C81947562408C300
     011CFE1707B7ED4C
     8680A76444A7664F
     A765A767A7634F17
     07A34FA762A1612E
     64A667E666EAA6E7
     A66D6326144FE6A6
     E1862609A1E42C09
     4CE6A620F3250220
     0B17067DE665A664
     AAA5A7A5A666E667
     43A4A5A7A54F6908
     6907690669056904
     6903690269016984
     C60056E7634F6664
     240466646C654F66
     66240466666C676C
     62A6622098E6E45C
     301D17EF4A27026C
     4A3268304BA6032D
     0317067017F15539
     A6D8038401260786
     0117F849200FA6C8
     182D0517F8822005
     860117F838393003
     170119301DA63F81
     0F26048680A784CC
     003FED0117EF1339
     10AEC81B31264FE6
     A6C40FC100260D4C
     E6A6C40F81132D02
     C6FF20EF81132D06
     17F88C1600DD327C
     10AEC81B312130E4
     C60486021700CD10
     AEC81BA6A4810F26
     0863E4606125026C
     E43126304BC61386
     088D936F48EC482C
     022006108300132F
     0A860717F7B9CC00
     13ED48ECE4A348ED
     E4A6D803A7628419
     8A40A7D803A645A7
     638604A745327330
     4B31E4170637EC6D
     2C054353C3000117
     02D531C818170625
     30E431C82517061D
     326D304BC60C17F7
     77ECE42D0517FBE2
     200317FC99EC62A7
     D803E745A64884BF
     A748304B6F4A5F17
     066817F04717F158
     261110AE43A62184
     04270517F7082003
     17EF6517F11B2611
     10AE43A641840227
     0517F6F2200317EF
     9F32643934368100
     2F054A6F8620F74F
     E6A6C100260B4CE6
     A6A1612602C6FF20
     F1A161102C00C034
     02E661C102263B32
     7E1CFE69016984C6
     02C1002F075AA685
     A7E520F5C602C100
     2F091CFE69016984
     5A20F3C6025A4FC1
     002D0B46A685A9E5
     A785495A20F13262
     205132781CFE6907
     6906690569046903
     690269016984C608
     C1002F075AA685A7
     E520F5C602C1002F
     151CFE6907690669
     0569046903690269
     0169845A20E7C608
     5A4FC1002D0B46A6
     85A9E5A785495A20
     F13268A6E4A6A684
     0FE6615AAB85A785
     8400495AC1002D11
     4D270AAB85A78584
     00495A2002C6FF20
     EB35024C16FF3A35
     B60002CDB9A74A06
     37CE2EE100000001
     66DA01EE641A708D
     EA00000000B3A70C
     3C40A64E6C520000
     000003A000000000
     0000000000000006
     C800000000000000
     0000000009FA0000
     0000000000000000
     000D9C4000000000
     00000000000010C3
     5000000000000000
     00000013F4240000
     0000000000000000
     1798968000000000
     00000000001ABEBC
     2000000000000000
     00001DEE6B280000
     0000000000000021
     9502F90000000000
     0000000024BA43B7
     4000000000000000
     0027E8D4A5100000
     0000000000002B91
     84E72A0000000000
     0000002EB5E620F4
     8000000000000000
     31E35FA931A00000
     0000000000358E1B
     C9BF040000000000
     000038B1A2BC2EC5
     000000000000003B
     DE0B6B3A76400000
     000000003F8AC723
     0489E80000000000
     0042AD78EBC5AC62
     00000000000045D8
     D726B7177A800000
     0000004987867832
     6EAC900000000000
     4CA968163F0A57B4
     00000000004FD3C2
     1BCECCEDA1000000
     0000538459516140
     1484A00000000056
     A56FA5B99019A5C8
     0000000059CECB8F
     27F4200F3A000034
     77327F6FE4108300
     00260B308D008431
     4B170341204F1083
     00D82D0B308DFE59
     8300D88D4420EF10
     83006C2D09308DFE
     5583006C8D331083
     00362D09308DFE53
     8300368D24108300
     1B2D08308CA48300
     1B8D16108300002F
     0C5A860D3D308DFE
     3F308B8D04326135
     F76D622609314B17
     02E36362201C31C8
     251702D9304B31C8
     181702D13406C60A
     17F42D6F4A17F89A
     3506390000008000
     0000000000000000
     3436E6451CFE6909
     6908690769066905
     69046903A6018480
     A7842C1B63016302
     17EACC2609EC01C3
     0001ED0120093003
     C6081702B3301DE6
     45C1002604310520
     063107A609A70B34
     1010ACE12D0AECA4
     ED22313E341020F1
     CC000FED0117EAA2
     35B634368D9A17EA
     86260ECC8000ED01
     6F848602A70C1600
     40A64534028604A7
     4531C8253420ACE1
     260331C818308D00
     2A170221A6D80334
     0284F98A00A7D803
     304BC60C17F37117
     F7E03506A7D803E7
     45304B10AE621701
     FC35B600FFFE9A20
     9A84FBCFF7990000
     3277A64544308D00
     FEE6865AE7E4308D
     00FAE6861DED616F
     68AEC826ACC8192F
     0830C82531C81820
     0630C81831C825EC
     01A321ED63300331
     2310A3612F19A684
     8480A765A6E45F81
     002D05EAA64A20F7
     E74A301D16006634
     10303D1702043510
     A684AAA48480A765
     A6C825A1C818273F
     8601A768AF664FE6
     86E1A62609A1E42C
     0D4CE68620F32206
     A63DA71D200230A4
     E6E4AC6626051701
     8720126D4A260517
     017E2009C1002D05
     63855A20F7AE6617
     00DE301D24076D68
     26031700BA314B17
     012B304B17E96026
     1F6D652C05CC8000
     ED4C10AE43A6A484
     06810626068680A7
     4B20034FA74B200C
     6D652C03170047C6
     0017016E1700BE32
     6939A6C818438480
     A7C81817FEFA3904
     070904071A37421A
     37EC07A327ED07EC
     05E226A225ED05EC
     03E224A223ED03EC
     01E222A221ED01E6
     84E2A4E7843917E8
     EE27206D032D1C4F
     690B690A69096908
     6907690669056904
     6903EC01830001ED
     0120E0394F690B69
     0A69096908690769
     06690569046903EC
     01830001ED013966
     0366046605660666
     0766086609660A66
     0B6C0226026C0139
     EC07E327ED07EC05
     E926A925ED05EC03
     E924A923ED03EC01
     E922A921ED01E684
     E9A4E7843917EBA0
     2615AE43A6018404
     270817EB4017EA7C
     200317E9AB201D30
     4B17EA7017E95717
     EB572610AE43A601
     8402270517EB2F20
     0317E9DC393407EC
     84EDA4EC02ED22EC
     04ED24EC06ED26EC
     08ED28EC0AED2AA6
     0CA72C3587668466
     0166026603660466
     0566066607660839
     1F9881002D056386
     4A20F78601C1002D
     114D2709AB85A785
     8600492002C6FF5A
     20EB393437318DF0
     21E64554A6A58B03
     5F81032D07EA866F
     864A20F5EA4AE74A
     35B734374FC1002F
     1A1CFE6603660466
     0566066607660866
     09660A660B240149
     5A20E2318DEFE3E6
     4554E6A5CB04C10C
     2C05AA855C20F7AA
     4AA74A35B720A510
                      (   monitor1v4.asm):00203                  
                      (   monitor1v4.asm):00204               IFNE     (*-IOPAGE)
                      (   monitor1v4.asm):00205                  ERROR    "FP ROM IMAGE INCORRECT SIZE"
                      (   monitor1v4.asm):00206               ENDC
                      (   monitor1v4.asm):00207         
                      (   monitor1v4.asm):00208         ;======================================================================
                      (   monitor1v4.asm):00209         ;
                      (   monitor1v4.asm):00210         ;======================================================================
                      (   monitor1v4.asm):00211         
E000 4844363330392053 (   monitor1v4.asm):00212         BANNER   FCC      "HD6309 SBC Monitor ROM build "
     4243204D6F6E6974
     6F7220524F4D2062
     75696C6420
                      (   monitor1v4.asm):00213                  _MON_REV_TEXT
E01D 312E3431         (    _MON_REV_TEXT):00001                           FCC "1.41"
E021 20               (   monitor1v4.asm):00214                  FCC      " "
                      (   monitor1v4.asm):00215                  _MON_REV_DATE
E022 30342F32392F3230 (    _MON_REV_DATE):00001                           FCC "04/29/2020"
     3230
E02C 20546F6D204C654D (   monitor1v4.asm):00216                  FCC      " Tom LeMense "         
     656E736520
E039 5468697320524F4D (   monitor1v4.asm):00217                  FCC      "This ROM is for the HD6309 SBC "
     20697320666F7220
     7468652048443633
     30392053424320
E058 6465736372696265 (   monitor1v4.asm):00218                  FCC      "described at https://hackaday.io/project/345"
     6420617420687474
     70733A2F2F686163
     6B616461792E696F
     2F70726F6A656374
     2F333435
E084 2D6864363330392D (   monitor1v4.asm):00219                  FCC      "-hd6309-singleboard-computer. "
     73696E676C65626F
     6172642D636F6D70
     757465722E20
E0A2 5468697320524F4D (   monitor1v4.asm):00220                  FCC      "This ROM occupies $C000-$FFFF, and "
     206F636375706965
     732024433030302D
     24464646462C2061
     6E6420
E0C5 696E636C75646573 (   monitor1v4.asm):00221                  FCC      "includes the following portions: "
     2074686520666F6C
     6C6F77696E672070
     6F7274696F6E733A
     20
E0E6 4D43363833392049 (   monitor1v4.asm):00222                  FCC      "MC6839 IEEE Floating Point functions, "
     45454520466C6F61
     74696E6720506F69
     6E742066756E6374
     696F6E732C20
E10C 526573657420616E (   monitor1v4.asm):00223                  FCC      "Reset and RTC utilities, "
     6420525443207574
     696C69746965732C
     20
E125 4E6F494345206465 (   monitor1v4.asm):00224                  FCC      "NoICE debug monitor, "
     627567206D6F6E69
     746F722C20
E13A 412073696D706C65 (   monitor1v4.asm):00225                  FCC      "A simple monitor (inspired by "
     206D6F6E69746F72
     2028696E73706972
     656420627920
E158 4170706C65203120 (   monitor1v4.asm):00226                  FCC      "Apple 1 WOZMON), and "
     574F5A4D4F4E292C
     20616E6420
E16D 5342432048572073 (   monitor1v4.asm):00227                  FCC      "SBC HW support functions. "
     7570706F72742066
     756E6374696F6E73
     2E20
                      (   monitor1v4.asm):00228               IF       (COPY_MON_TO_RAM)
E187 524F4D2069732063 (   monitor1v4.asm):00229                  FCC      "ROM is copied to RAM at reset. "
     6F7069656420746F
     2052414D20617420
     72657365742E20
                      (   monitor1v4.asm):00230               ENDC
                      (   monitor1v4.asm):00231               IF       (COMMON_TEXT_BUFFER)
E1A6 4E6F49434520616E (   monitor1v4.asm):00232                  FCC      "NoICE and WOZMON share input buffer. "
     6420574F5A4D4F4E
     2073686172652069
     6E70757420627566
     6665722E20
                      (   monitor1v4.asm):00233               ENDC
                      (   monitor1v4.asm):00234               IFEQ (CONSOLE_CH-SCC_CHA)
E1CB 5343432043682041 (   monitor1v4.asm):00235                  FCC      "SCC Ch A is Console I/O. "      
     20697320436F6E73
     6F6C6520492F4F2E
     20
                      (   monitor1v4.asm):00236               ELSE
                      (   monitor1v4.asm):00237                  FCC      "SCC Ch B is Console I/O. "      
                      (   monitor1v4.asm):00238               ENDC                  
                      (   monitor1v4.asm):00239               IFEQ (DEBUG_CH-SCC_CHA)
                      (   monitor1v4.asm):00240                  FCC      "SCC Ch A is NoICE port. "      
                      (   monitor1v4.asm):00241               ELSE
E1E4 5343432043682042 (   monitor1v4.asm):00242                  FCC      "SCC Ch B is NoICE port. "      
     206973204E6F4943
     4520706F72742E20
                      (   monitor1v4.asm):00243               ENDC                  
                      (   monitor1v4.asm):00244         
     E1FB             (   monitor1v4.asm):00245         BANNER_END  EQU *-1
                      (   monitor1v4.asm):00246                  
                      (   monitor1v4.asm):00247               IFGE     (BANNER_END-BANNER-512)
                      (   monitor1v4.asm):00248                  WARNING  "ROM BANNER EXCEEDS 512B"
                      (   monitor1v4.asm):00249               ELSE
E1FC FFFFFFFFFF       (   monitor1v4.asm):00250                  FILL     $FF,(ROMH_START-BANNER_END)
                      (   monitor1v4.asm):00251               ENDC
                      (   monitor1v4.asm):00252         
                      (   monitor1v4.asm):00253                  PRAGMA   6309
                      (   monitor1v4.asm):00254                  ORG      ROMH_START
                      (   monitor1v4.asm):00255         ;======================================================================
                      (   monitor1v4.asm):00256         ; Jump table to useful entry points
                      (   monitor1v4.asm):00257         ;======================================================================
E200 7EE20C           (   monitor1v4.asm):00258                  JMP      RESET                             ; COLDSTART
E203 7EE331           (   monitor1v4.asm):00259                  JMP      GOWOZ                             ; WOZMON
E206 7EE263           (   monitor1v4.asm):00260                  JMP      GONOICE                           ; NOICE
E209 7EE608           (   monitor1v4.asm):00261                  JMP      GOBASIC                           ; MS BASIC
                      (   monitor1v4.asm):00262                  
                      (   monitor1v4.asm):00263         ;======================================================================
                      (   monitor1v4.asm):00264         ;  SYSTEM RESET
                      (   monitor1v4.asm):00265         ;======================================================================
E20C                  (   monitor1v4.asm):00266         RESET:
E20C 1A50             (   monitor1v4.asm):00267                  ORCC     #CC_I+CC_F                        ; disable interrupts
E20E 10CEBFAB         (   monitor1v4.asm):00268                  LDS      #MONSTACK                         ; set default stack pointer
                      (   monitor1v4.asm):00269               IF       (COPY_MON_TO_RAM)
E212 BDE64E           (   monitor1v4.asm):00270                  JSR      MOVEMON                           ; Move MONITOR image into RAM
                      (   monitor1v4.asm):00271               ENDC
E215 8633             (   monitor1v4.asm):00272                  LDA      #(IO.SDCLK|IO.SDCS|IO.LED2|IO.LED1)  ; slow SPI clock freq, negate SD CS
E217 B7E050           (   monitor1v4.asm):00273                  STA      IOPORT                               ; LED1 and LED2 both ON
E21A 72FEE040         (   monitor1v4.asm):00274                  AIM      #~(SYS.ROMWS),SYSCFG              ; make ROM access 0WS (fast flash)
E21E 86C0             (   monitor1v4.asm):00275                  LDA      #(I2C.DSCL|I2C.DSDA)              ; release SDA and SCL
                      (   monitor1v4.asm):00276         
                      (   monitor1v4.asm):00277         ; populate exception handler redirection table
E220 108EE607         (   monitor1v4.asm):00278                  LDY      #EXC_STUB                         ; ADDRESS OF DEFAULT HANDLER
E224 8EBF83           (   monitor1v4.asm):00279                  LDX      #RAMVEC                           ; POINTER TO RAM VECTORS
E227 C608             (   monitor1v4.asm):00280                  LDB      #NVEC                             ; NUMBER OF VECTORS
E229 10AF81           (   monitor1v4.asm):00281         R?VEC    STY      ,X++                              ; SET VECTOR
E22C 5A               (   monitor1v4.asm):00282                  DECB
E22D 26FA             (   monitor1v4.asm):00283                  BNE      R?VEC                             ; repeat until all vectors set
                      (   monitor1v4.asm):00284         
                      (   monitor1v4.asm):00285         ; initialize the two SCC channels         
E22F BDE69C           (   monitor1v4.asm):00286                  JSR      CONSOLE_INIT                      ; init console SCC channel for 115.2kbps
E232 BDE6A7           (   monitor1v4.asm):00287                  JSR      DEBUG_INIT                        ; init debug SCC channel for 115.2kbps
                      (   monitor1v4.asm):00288         
                      (   monitor1v4.asm):00289         ; HD6309 SBC can be USB powered, which means that CPU execution might begin before the
                      (   monitor1v4.asm):00290         ; USB bridge finishes enumeration. So wait a bit - also allows for the PB output to settle
                      (   monitor1v4.asm):00291         ; after poweron
E235 8E01F4           (   monitor1v4.asm):00292                  LDX      #500                              ; delay 0.5s to allow PB output to fall, USB to enumerate
E238 BDE804           (   monitor1v4.asm):00293                  JSR      DELAYMS
                      (   monitor1v4.asm):00294                  OffLED2                                    ; turn off LED2 
E23B 72FDE050         (          OffLED2):00001                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
                      (   monitor1v4.asm):00295                  StatusPB                                   ; check the pushbutton
E23F 7B08E050         (         StatusPB):00001                  TIM      #IO.PB,IOPORT                     ; check the pushbutton
E243 2629             (   monitor1v4.asm):00296                  BNE      RESET1                            ; PB depressed, go to CONSOLE mode
                      (   monitor1v4.asm):00297                 
                      (   monitor1v4.asm):00298         ; Check CONSOLE and DEBUG ports, alternately, for activity. Whichever one is active first
                      (   monitor1v4.asm):00299         ; determines if the SBC is in "CONSOLE MODE" (human operator via USB term) or in "DEBUG
                      (   monitor1v4.asm):00300         ; MODE" (control via NoICE debug port). Illuminate LED1 while trying CONSOLE and LED2
                      (   monitor1v4.asm):00301         ; while trying DEBUG ports, respsectively.
E245                  (   monitor1v4.asm):00302         RESET0   OnLED1                                     ; turn on LED1 while trying console channel
E245 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
                      (   monitor1v4.asm):00303                  OffLED2                                    ; turn off LED2 while trying console channel
E249 72FDE050         (          OffLED2):00001                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
E24D BDE702           (   monitor1v4.asm):00304                  JSR      GETCH2                            ; attempt to get a character from console channel
E250 281C             (   monitor1v4.asm):00305                  BVC      RESET1                            ;  got a character, console is active!
                      (   monitor1v4.asm):00306                  OffLED1                                    ; turn off LED1 while trying debug channel
E252 72FEE050         (          OffLED1):00001                  AIM      #~IO.LED1,IOPORT                  ; turn off LED1
                      (   monitor1v4.asm):00307                  OnLED2                                     ; turn on LED2 while trying debug channel
E256 7102E050         (           OnLED2):00001                  OIM      #IO.LED2,IOPORT                   ; turn on LED2
E25A BDED05           (   monitor1v4.asm):00308                  JSR      DBGETCH                           ; attempt to get a character from debug channel 
E25D 29E6             (   monitor1v4.asm):00309                  BVS      RESET0                            ;  no character on SCC B, so keep trying
E25F 81F0             (   monitor1v4.asm):00310                  CMPA     #$F0                              ; is the byte received $Fx (NoICE commands look like this)
E261 25E2             (   monitor1v4.asm):00311                  BLO      RESET0                            ;   no, so keep trying!
E263                  (   monitor1v4.asm):00312         GONOICE:
                      (   monitor1v4.asm):00313                  OffLED1
E263 72FEE050         (          OffLED1):00001                  AIM      #~IO.LED1,IOPORT                  ; turn off LED1
                      (   monitor1v4.asm):00314                  OnLED2
E267 7102E050         (           OnLED2):00001                  OIM      #IO.LED2,IOPORT                   ; turn on LED2
E26B 7EED4E           (   monitor1v4.asm):00315                  JMP      NOICE                             ; enter the NoICE resident debugger (LED2 ON)
                      (   monitor1v4.asm):00316         
                      (   monitor1v4.asm):00317         ; We received a character from console before a NoICE command arrived, or the pushbutton 
                      (   monitor1v4.asm):00318         ; was depressed during boot (skip NoICE check). Attempt to get a second character from console 
                      (   monitor1v4.asm):00319         ; while flashing LED1, then display system info.
E26E                  (   monitor1v4.asm):00320         RESET1   OffLED2                                    ; turn off LED2 when in console-only operation
E26E 72FDE050         (          OffLED2):00001                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
E272 BDE6E7           (   monitor1v4.asm):00321                  JSR      GETCHT                            ; get a second character, flash LED1 while waiting
E275 B7BF00           (   monitor1v4.asm):00322                  STA      RAM_START                         ; save that second character for later...
E278 BDE774           (   monitor1v4.asm):00323                  JSR      PUTMSG
E27B 0D0A             (   monitor1v4.asm):00324                  FCB      CR,LF                             ; newline
E27D 4844363330392053 (   monitor1v4.asm):00325                  FCC      "HD6309 Singleboard Computer"
     696E676C65626F61
     726420436F6D7075
     746572
E298 0D0A             (   monitor1v4.asm):00326                  FCB      CR,LF                             ; newline
E29A 4D6F6E69746F7220 (   monitor1v4.asm):00327                  FCC      "Monitor ROM v"
     524F4D2076
                      (   monitor1v4.asm):00328                  _MON_REV_TEXT         
E2A7 312E3431         (    _MON_REV_TEXT):00001                           FCC "1.41"
E2AB 0D0A             (   monitor1v4.asm):00329                  FCB      CR,LF                             ; newline
                      (   monitor1v4.asm):00330                  _MON_REV_DATE
E2AD 30342F32392F3230 (    _MON_REV_DATE):00001                           FCC "04/29/2020"
     3230
E2B7 206275696C64     (   monitor1v4.asm):00331                  FCC      " build"
E2BD 0D0A             (   monitor1v4.asm):00332                  FCB      CR,LF                             ; newline
E2BF 4D61696E626F6172 (   monitor1v4.asm):00333                  FCN      "Mainboard CPLD v"
     642043504C442076
     00
E2D0 B6E060           (   monitor1v4.asm):00334                  LDA      CPLDVER                           ; display CPLD version from CPLDVER register
E2D3 44               (   monitor1v4.asm):00335                  LSRA                                       ; display MAJOR revision 0-F
E2D4 44               (   monitor1v4.asm):00336                  LSRA
E2D5 44               (   monitor1v4.asm):00337                  LSRA
E2D6 44               (   monitor1v4.asm):00338                  LSRA
E2D7 BDE758           (   monitor1v4.asm):00339                  JSR      PUTHEX
E2DA 862E             (   monitor1v4.asm):00340                  LDA      #'.'
E2DC BDE71F           (   monitor1v4.asm):00341                  JSR      PUTCH
E2DF B6E060           (   monitor1v4.asm):00342                  LDA      CPLDVER                           ; display MINOR revision 0-F
E2E2 BDE758           (   monitor1v4.asm):00343                  JSR      PUTHEX
E2E5 BDE731           (   monitor1v4.asm):00344                  JSR      PUTCR                             ; newline
                      (   monitor1v4.asm):00345         
                      (   monitor1v4.asm):00346         ; Examine the character received in RESET1 to see what the operator wants to do:
                      (   monitor1v4.asm):00347         ;        B = Enter MS BASIC
                      (   monitor1v4.asm):00348         ;        N = Enter NoICE debugger
                      (   monitor1v4.asm):00349         ;        R = Realtime Clock Utility
                      (   monitor1v4.asm):00350         ;        S = Boot from SDcard
                      (   monitor1v4.asm):00351         ;        <anything else> = enter WOZMON
                      (   monitor1v4.asm):00352         ;
E2E8 B6BF00           (   monitor1v4.asm):00353                  LDA      RAM_START                         ; get that second character back
E2EB 813F             (   monitor1v4.asm):00354         RESET2   CMPA     #'?'                              ; request for help?
E2ED 2750             (   monitor1v4.asm):00355                  BEQ      GOHELP
E2EF 845F             (   monitor1v4.asm):00356                  ANDA     #$5F                              ; convert to UPPERCASE
E2F1 8142             (   monitor1v4.asm):00357                  CMPA     #'B'                              ; request to enter BASIC?
E2F3 10270311         (   monitor1v4.asm):00358                  LBEQ     GOBASIC                           
E2F7 814E             (   monitor1v4.asm):00359                  CMPA     #'N'                              ; request to enter NoICE?
E2F9 1027FF66         (   monitor1v4.asm):00360                  LBEQ     GONOICE
E2FD 8152             (   monitor1v4.asm):00361                  CMPA     #'R'                              ; request to run RTC UTILITY?
E2FF 2774             (   monitor1v4.asm):00362                  BEQ      GORTC
E301 8153             (   monitor1v4.asm):00363                  CMPA     #'S'                              ; request to BOOT FROM SD?
E303 10270209         (   monitor1v4.asm):00364                  LBEQ     GOBOOT
E307 813F             (   monitor1v4.asm):00365                  CMPA     #'?'                              ; request for help?
E309 2734             (   monitor1v4.asm):00366                  BEQ      GOHELP
                      (   monitor1v4.asm):00367                  ; fall into "normal startup"
                      (   monitor1v4.asm):00368         
                      (   monitor1v4.asm):00369         ; No special action required, so try to output time and date before entering WOZMON
E30B B6E060           (   monitor1v4.asm):00370                  LDA      CPLDVER                           ; check for I2C RTC support
E30E 8114             (   monitor1v4.asm):00371                  CMPA     #$14                              ; which began at CPLD V1.4
E310 251F             (   monitor1v4.asm):00372                  BLO      GOWOZ                             ;  too old, jump to monitor
E312 108EBF00         (   monitor1v4.asm):00373                  LDY      #RAM_START                        ; use reserved RAM for buffer
E316 BDE9C5           (   monitor1v4.asm):00374                  JSR      RTC_FmtTime                       ; read RTC and create formatted time string at X
E319 290D             (   monitor1v4.asm):00375                  BVS      W?RTCX                            ;   RTC read failed
E31B 1F21             (   monitor1v4.asm):00376                  TFR      Y,X                               ; copy string address to X
E31D BDE77E           (   monitor1v4.asm):00377                  JSR      PUTSTR                            ; display formatted string at X         
E320 BDE731           (   monitor1v4.asm):00378                  JSR      PUTCR                             ; newline
E323 BDE97A           (   monitor1v4.asm):00379                  JSR      RTC_FmtDate                       ; read RTC and create formatted date string at X
E326 2804             (   monitor1v4.asm):00380                  BVC      W?RTC                             ; RTC read successful?
E328 108EE495         (   monitor1v4.asm):00381         W?RTCX   LDY      #RTCERR                           ;   no, failed, point Y to error string
E32C 1F21             (   monitor1v4.asm):00382         W?RTC    TFR      Y,X                               ; copy string address to X
E32E BDE77E           (   monitor1v4.asm):00383                  JSR      PUTSTR                            ; display the formatted string at X
                      (   monitor1v4.asm):00384         
                      (   monitor1v4.asm):00385         ;;
                      (   monitor1v4.asm):00386         ;; GOWOZ - Start WOZMON
                      (   monitor1v4.asm):00387         ;;
E331                  (   monitor1v4.asm):00388         GOWOZ:   
                      (   monitor1v4.asm):00389                  OnLED1
E331 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
                      (   monitor1v4.asm):00390                  OffLED2
E335 72FDE050         (          OffLED2):00001                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
E339 BDE731           (   monitor1v4.asm):00391                  JSR      PUTCR                             ; newline
E33C 7EF0B0           (   monitor1v4.asm):00392                  JMP      WOZMON                            ; jump to WOZMON
                      (   monitor1v4.asm):00393                  
                      (   monitor1v4.asm):00394         ;;
                      (   monitor1v4.asm):00395         ;; GOHELP - Display boot help
                      (   monitor1v4.asm):00396         ;;
E33F                  (   monitor1v4.asm):00397         GOHELP:
E33F BDE774           (   monitor1v4.asm):00398                  JSR      PUTMSG                            ; display help message
E342 0A0D             (   monitor1v4.asm):00399                  FCB      LF,CR         
E344 423D4D5320424153 (   monitor1v4.asm):00400                  FCC      "B=MS BASIC, N=NoICE, R=RTC Util, S=SD Boot"
     49432C204E3D4E6F
     4943452C20523D52
     5443205574696C2C
     20533D534420426F
     6F74
E36E FF               (   monitor1v4.asm):00401                  FCB      $FF
E36F BDE6E7           (   monitor1v4.asm):00402                  JSR      GETCHT                             ; give operator another chance
E372 7EE2EB           (   monitor1v4.asm):00403                  JMP      RESET2                            ; try again
                      (   monitor1v4.asm):00404         
                      (   monitor1v4.asm):00405         ;;
                      (   monitor1v4.asm):00406         ;; GORTC - Start Realtime Clock and NVRAM Utility
                      (   monitor1v4.asm):00407         ;;
     000F             (   monitor1v4.asm):00408         RTC.STATUS        EQU   15
                      (   monitor1v4.asm):00409         
E375                  (   monitor1v4.asm):00410         GORTC:   
                      (   monitor1v4.asm):00411                  OnLED1
E375 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
                      (   monitor1v4.asm):00412                  OnLED2
E379 7102E050         (           OnLED2):00001                  OIM      #IO.LED2,IOPORT                   ; turn on LED2
E37D BDE774           (   monitor1v4.asm):00413                  JSR      PUTMSG
E380 5265616C74696D65 (   monitor1v4.asm):00414                  FCN      "Realtime Clock Utility"
     20436C6F636B2055
     74696C69747900
E397                  (   monitor1v4.asm):00415         GORTC1:
E397 BDE774           (   monitor1v4.asm):00416                  JSR      PUTMSG
E39A 0A0D             (   monitor1v4.asm):00417                  FCB      LF,CR
E39C 303D455849542020 (   monitor1v4.asm):00418                  FCC      "0=EXIT   1=SET TIME   2=SET DATE   3=ENABLE 1HZ NMI   4=DISABLE 1HZ NMI"
     20313D5345542054
     494D45202020323D
     5345542044415445
     202020333D454E41
     424C452031485A20
     4E4D49202020343D
     44495341424C4520
     31485A204E4D49
E3E3 0A0D233F00       (   monitor1v4.asm):00419                  FCB      LF,CR,'#','?',0
E3E8 C604             (   monitor1v4.asm):00420                  LDB      #4
E3EA BDE7BD           (   monitor1v4.asm):00421                  JSR      GETBDIG                           ; get digit 0-4
E3ED 29A8             (   monitor1v4.asm):00422                  BVS      GORTC1
E3EF 4D               (   monitor1v4.asm):00423                  TSTA                                       ; is it 0?
E3F0 1027FE18         (   monitor1v4.asm):00424                  LBEQ     RESET
E3F4 8101             (   monitor1v4.asm):00425                  CMPA     #1                                ; is it 1?
E3F6 2712             (   monitor1v4.asm):00426                  BEQ      RTC_SETT
E3F8 8102             (   monitor1v4.asm):00427                  CMPA     #2                                ; is it 2?
E3FA 272A             (   monitor1v4.asm):00428                  BEQ      RTC_SETD
E3FC 8103             (   monitor1v4.asm):00429                  CMPA     #3                                ; is it 3?
E3FE 102700A8         (   monitor1v4.asm):00430                  LBEQ     RTC_ENNMI
E402 8104             (   monitor1v4.asm):00431                  CMPA     #4                                ; is it 4?
E404 102700C0         (   monitor1v4.asm):00432                  LBEQ     RTC_DISNMI
E408 208D             (   monitor1v4.asm):00433                  BRA      GORTC1                            ; re-prompt
                      (   monitor1v4.asm):00434         
                      (   monitor1v4.asm):00435         ; Interactive Time Set         
E40A                  (   monitor1v4.asm):00436         RTC_SETT:
E40A BDE774           (   monitor1v4.asm):00437                  JSR      PUTMSG                            ; output format prompt
E40D 0A0D             (   monitor1v4.asm):00438                  FCB      LF,CR         
E40F 54696D652048483A (   monitor1v4.asm):00439                  FCN      "Time HH:MM:SS = "
     4D4D3A5353203D20
     00
E420 108EE4E6         (   monitor1v4.asm):00440                  LDY      #R_TIMEPAT                        ; address of TIME PATTERN table
E424 201C             (   monitor1v4.asm):00441                  BRA      RTCS0
                      (   monitor1v4.asm):00442                  
                      (   monitor1v4.asm):00443         ; Interactive Date Set         
E426                  (   monitor1v4.asm):00444         RTC_SETD:
E426 BDE774           (   monitor1v4.asm):00445                  JSR      PUTMSG                            ; output format prompt
E429 0A0D             (   monitor1v4.asm):00446                  FCB      LF,CR         
E42B 44617465204D4D2F (   monitor1v4.asm):00447                  FCN      "Date MM/DD/YYYY = "
     44442F5959595920
     3D2000
E43E 108EE4F8         (   monitor1v4.asm):00448                  LDY      #R_DATEPAT                        ; address of DATE PATTERN table
                      (   monitor1v4.asm):00449                  
                      (   monitor1v4.asm):00450         ; common, table-driven, time/date set stuff         
E442 3420             (   monitor1v4.asm):00451         RTCS0    PSHS     Y                                 ; preserve Y pointer to pattern
E444 108EBF00         (   monitor1v4.asm):00452                  LDY      #RAM_START                        ; point Y to start of monitor RAM
E448 BDE944           (   monitor1v4.asm):00453                  JSR      RTC_ReadRegs                      ; read RTC registers 0-15 to Y[0...15]
E44B 2643             (   monitor1v4.asm):00454                  BNE      RTCIF                             ;   report I2C error
E44D 3520             (   monitor1v4.asm):00455                  PULS     Y                                 ; restore Y pointer to pattern
E44F 8EBF00           (   monitor1v4.asm):00456                  LDX      #RAM_START                        ; point to RAM array
E452 BDE7CC           (   monitor1v4.asm):00457                  JSR      GETPATT                           ; process input per pattern
E455 2924             (   monitor1v4.asm):00458                  BVS      RTCIE                             ;   report entry error
E457 108EBF00         (   monitor1v4.asm):00459                  LDY      #RAM_START                        ; use reserved RAM for buffer
E45B A62F             (   monitor1v4.asm):00460                  LDA      RTC.STATUS,Y                      ; get STATUS register
E45D 8407             (   monitor1v4.asm):00461                  ANDA     #$07                              ; clear the OSF and 32KHz bits
E45F A72F             (   monitor1v4.asm):00462                  STA      RTC.STATUS,Y                      ; write updated STATUS register
E461 BDE90D           (   monitor1v4.asm):00463                  JSR      RTC_WriteRegs                     ; write Y[0...15] to RTC registers 0-15
E464 262A             (   monitor1v4.asm):00464                  BNE      RTCIF                             ;   report I2C error
E466 BDE774           (   monitor1v4.asm):00465                  JSR      PUTMSG
E469 0A0D             (   monitor1v4.asm):00466                  FCB      LF,CR         
E46B 5254432055706461 (   monitor1v4.asm):00467                  FCN      "RTC Updated."
     7465642E00
E478 7EE397           (   monitor1v4.asm):00468                  JMP      GORTC1         
E47B BDE774           (   monitor1v4.asm):00469         RTCIE    JSR      PUTMSG
E47E 0A0D             (   monitor1v4.asm):00470                  FCB      LF,CR         
E480 456E747279204572 (   monitor1v4.asm):00471                  FCN      "Entry Error!"
     726F722100
E48D 7EE397           (   monitor1v4.asm):00472                  JMP      GORTC1
E490 BDE774           (   monitor1v4.asm):00473         RTCIF    JSR      PUTMSG
E493 0A0D             (   monitor1v4.asm):00474                  FCB      LF,CR         
E495 5254432041636365 (   monitor1v4.asm):00475         RTCERR   FCN      "RTC Access Error!"
     7373204572726F72
     2100
E4A7 7EE397           (   monitor1v4.asm):00476                  JMP      GORTC1         
                      (   monitor1v4.asm):00477                  
                      (   monitor1v4.asm):00478         ; Enable 1Hz NMI         
E4AA                  (   monitor1v4.asm):00479         RTC_ENNMI:         
E4AA BDEA07           (   monitor1v4.asm):00480                  JSR      RTC_NMIEnable
E4AD 29E1             (   monitor1v4.asm):00481                  BVS      RTCIF
E4AF BDE774           (   monitor1v4.asm):00482                  JSR      PUTMSG
E4B2 0A0D             (   monitor1v4.asm):00483                  FCB      LF,CR         
E4B4 31487A204E4D4920 (   monitor1v4.asm):00484                  FCN      "1Hz NMI Disabled"
     44697361626C6564
     00
E4C5 7EE397           (   monitor1v4.asm):00485                  JMP      GORTC1
                      (   monitor1v4.asm):00486                  
                      (   monitor1v4.asm):00487         ; Disable 1Hz NMI         
E4C8                  (   monitor1v4.asm):00488         RTC_DISNMI:         
E4C8 BDEA21           (   monitor1v4.asm):00489                  JSR      RTC_NMIDisable
E4CB 29C3             (   monitor1v4.asm):00490                  BVS      RTCIF
E4CD BDE774           (   monitor1v4.asm):00491                  JSR      PUTMSG
E4D0 0A0D             (   monitor1v4.asm):00492                  FCB      LF,CR         
E4D2 31487A204E4D4920 (   monitor1v4.asm):00493                  FCN      "1Hz NMI Disabled"
     44697361626C6564
     00
E4E3 7EE397           (   monitor1v4.asm):00494                  JMP      GORTC1
                      (   monitor1v4.asm):00495                  
E4E6                  (   monitor1v4.asm):00496         R_TIMEPAT:
E4E6 428200           (   monitor1v4.asm):00497                  FCB      $42,$82,$00                       ; HOURS 10's - bound is 2, shift left 4, STORE at +2
E4E9 09423A           (   monitor1v4.asm):00498                  FCB      $09,$42,':'                       ; HOURS 1's - bound is 9, no shift, OR at +2, ":"
E4EC 458100           (   monitor1v4.asm):00499                  FCB      $45,$81,$00                       ; MINS 10's - bound is 5, shift left 4, STORE at +1
E4EF 09413A           (   monitor1v4.asm):00500                  FCB      $09,$41,':'                       ; MINS 1's - bound is 9, no shift, OR at +1, ":"                
E4F2 458000           (   monitor1v4.asm):00501                  FCB      $45,$80,$00                       ; SECS 10's - bound is 5, shift left 4, STORE at +0
E4F5 0940FF           (   monitor1v4.asm):00502                  FCB      $09,$40,$FF                       ; SECS 1's - bound is 9, no shift, OR at +0, TERM
                      (   monitor1v4.asm):00503                  
E4F8                  (   monitor1v4.asm):00504         R_DATEPAT:
E4F8 418500           (   monitor1v4.asm):00505                  FCB      $41,$85,$00                       ; MONTHS 10's - bound is 1, shift left 4, STORE at +5
E4FB 09452F           (   monitor1v4.asm):00506                  FCB      $09,$45,'/'                       ; MONTHS 1's - bound is 9, no shift, OR at +5, "/"
E4FE 438400           (   monitor1v4.asm):00507                  FCB      $43,$84,$00                       ; DAYS 10's - bound is 3, shift left 4, STORE at +4
E501 09442F           (   monitor1v4.asm):00508                  FCB      $09,$44,'/'                       ; DAYS 1's - bound is 9, no shift, OR at +4
E504 420000           (   monitor1v4.asm):00509                  FCB      $42,$00,$00                       ; YEARS 1000's - bound is 2, shift left 4, DISCARD
E507 814500           (   monitor1v4.asm):00510                  FCB      $81,$45,$00                       ; YEARS 100's - bound is 1, rotate lsb into msb, OR at +5
E50A 498600           (   monitor1v4.asm):00511                  FCB      $49,$86,$00                       ; YEARS 10's - bound is 9, shift left 4, STORE at +6
E50D 0946FF           (   monitor1v4.asm):00512                  FCB      $09,$46,$FF                       ; YEARS 1's - boudn is 9, no shift, OR at +6, TERM
                      (   monitor1v4.asm):00513         
                      (   monitor1v4.asm):00514         ;;
                      (   monitor1v4.asm):00515         ;; GOBOOT - Read SDcard LBA block 0 into RAM ($0-$1FF)
                      (   monitor1v4.asm):00516         ;;          If read success, either WOZMON or jump to $0
                      (   monitor1v4.asm):00517         ;;          If read fails, jump to WOZMON
                      (   monitor1v4.asm):00518         ;;
E510                  (   monitor1v4.asm):00519         GOBOOT:  
                      (   monitor1v4.asm):00520                  OffLED1
E510 72FEE050         (          OffLED1):00001                  AIM      #~IO.LED1,IOPORT                  ; turn off LED1
                      (   monitor1v4.asm):00521                  OffLED2
E514 72FDE050         (          OffLED2):00001                  AIM      #~IO.LED2,IOPORT                  ; turn off LED1
E518 BDE774           (   monitor1v4.asm):00522                  JSR      PUTMSG
E51B 426F6F74696E6720 (   monitor1v4.asm):00523                  FCN      "Booting from SD Card..."
     66726F6D20534420
     436172642E2E2E00
E533 C604             (   monitor1v4.asm):00524                  LDB      #4                                ; initialize attempts counter
E535 5A               (   monitor1v4.asm):00525         B?IL     DECB                                       ; decrement attempt counter
E536 277E             (   monitor1v4.asm):00526                  BEQ      B?ERR0                            ;   done ; terminate with error
E538 8E0064           (   monitor1v4.asm):00527                  LDX      #100                              ; 100ms delay
E53B BDE804           (   monitor1v4.asm):00528                  JSR      DELAYMS                           
E53E 8E0400           (   monitor1v4.asm):00529                  LDX      #$0400                            ; pointer to scratch area
E541 11C601           (   monitor1v4.asm):00530                  LDF      #$01                              ; minimal debug info
E544 BDEAAF           (   monitor1v4.asm):00531                  JSR      SD_Initialize                     ; initialize the card
E547 29EC             (   monitor1v4.asm):00532                  BVS      B?IL                              ;   error during init; try again
E549 BDE774           (   monitor1v4.asm):00533                  JSR      PUTMSG
E54C 4C6F6164696E6720 (   monitor1v4.asm):00534                  FCC      "Loading LBA Block 0"
     4C424120426C6F63
     6B2030
E55F FF               (   monitor1v4.asm):00535                  FCB      $FF         
E560 8E0400           (   monitor1v4.asm):00536                  LDX      #$0400                            ; pointer to scratch area
E563 108E0000         (   monitor1v4.asm):00537                  LDY      #$0000                            ; pointer to start of RAM
E567 10AF00           (   monitor1v4.asm):00538                  STY      0,X                               ; fill block field in structure with
E56A 10AF02           (   monitor1v4.asm):00539                  STY      2,X                               ; 00:00:00:00
E56D BDEC5B           (   monitor1v4.asm):00540                  JSR      SD_ReadBlock
E570 2970             (   monitor1v4.asm):00541                  BVS      B?ERR1                            ;   error during read; terminate
E572 BDE774           (   monitor1v4.asm):00542                  JSR      PUTMSG
E575 4C6F616465642E   (   monitor1v4.asm):00543                  FCC      "Loaded."
E57C 0A0D             (   monitor1v4.asm):00544                  FCB      LF,CR
E57E 4D3D4D6F6E69746F (   monitor1v4.asm):00545                  FCN      "M=Monitor or X=Execute ?"
     72206F7220583D45
     786563757465203F
     00
E597 BDE6E2           (   monitor1v4.asm):00546         B?DO     JSR      GETCH                             ; get a keystroke
E59A BDE71F           (   monitor1v4.asm):00547                  JSR      PUTCH
E59D 814D             (   monitor1v4.asm):00548                  CMPA     #'M'                              ; is it M?
E59F 1027FD8E         (   monitor1v4.asm):00549                  LBEQ     GOWOZ                             ;   yes, go to WOZMON
E5A3 8158             (   monitor1v4.asm):00550                  CMPA     #'X'                              ; is it X?
E5A5 26F0             (   monitor1v4.asm):00551                  BNE      B?DO                              ;   no, get option again
E5A7 BDE774           (   monitor1v4.asm):00552                  JSR      PUTMSG                            ; yes, execute the boot code
E5AA 457865637574696E (   monitor1v4.asm):00553                  FCN      "Executing"
     6700
E5B4 0E00             (   monitor1v4.asm):00554                  JMP      $0                                
                      (   monitor1v4.asm):00555         ; error during SD initalize
E5B6 BDE774           (   monitor1v4.asm):00556         B?ERR0   JSR      PUTMSG
E5B9 4572726F72206475 (   monitor1v4.asm):00557                  FCN      "Error during SD Initialization :"
     72696E6720534420
     496E697469616C69
     7A6174696F6E203A
     00
E5DA 1FE8             (   monitor1v4.asm):00558                  TFR      E,A
E5DC BDE74E           (   monitor1v4.asm):00559                  JSR      PUTBYTE
E5DF 7EE20C           (   monitor1v4.asm):00560                  JMP      RESET
                      (   monitor1v4.asm):00561         ; error during SD initalize
E5E2 BDE774           (   monitor1v4.asm):00562         B?ERR1   JSR      PUTMSG
E5E5 4572726F72206475 (   monitor1v4.asm):00563                  FCN      "Error during LBA Block 0 read!"
     72696E67204C4241
     20426C6F636B2030
     20726561642100
E604 7EE20C           (   monitor1v4.asm):00564                  JMP      RESET
                      (   monitor1v4.asm):00565         
                      (   monitor1v4.asm):00566         ;;
                      (   monitor1v4.asm):00567         ;; Default Exception Handler - RTI stub
                      (   monitor1v4.asm):00568         ;;
E607                  (   monitor1v4.asm):00569         EXC_STUB:
E607 3B               (   monitor1v4.asm):00570                  RTI
                      (   monitor1v4.asm):00571         
                      (   monitor1v4.asm):00572         ;;
                      (   monitor1v4.asm):00573         ;; GOBASIC - switch to MS Basic interpreter
                      (   monitor1v4.asm):00574         ;;           located in the alternate ROM bank
                      (   monitor1v4.asm):00575         ;;
E608                  (   monitor1v4.asm):00576         GOBASIC:
E608 CCBF00           (   monitor1v4.asm):00577                  LDD      #RAM_START                        ; point to RAM
E60B 8EE618           (   monitor1v4.asm):00578                  LDX      #BSWAP                            ; address of bankswap snippet         
E60E 10860011         (   monitor1v4.asm):00579                  LDW      #B?SWP_SZ                         ; length of snippet
E612 113810           (   monitor1v4.asm):00580                  TFM      X+,D+                             ; copy the snippet (W=0)
E615 7EBF00           (   monitor1v4.asm):00581                  JMP      RAM_START                         ; execute it!
E618 4F               (   monitor1v4.asm):00582         BSWAP    CLRA
E619 1F8B             (   monitor1v4.asm):00583                  TFR      A,DP                              ; DP should be 0 on a "reset"
E61B 976E             (   monitor1v4.asm):00584                  STA      <$6E                              ; clear MS BASIC's "reset flag"
E61D 7508E040         (   monitor1v4.asm):00585                  EIM      #SYS.RA14,SYSCFG                  ; flip the RA14 control bit ("other bank")
E621 7106E040         (   monitor1v4.asm):00586                  OIM      #(SYS.ROMSEL|SYS.ROMSEH),SYSCFG   ; make sure ROM is enabled
E625 6E9FFFFE         (   monitor1v4.asm):00587                  JMP      [V_RESET]                         ; jump to "other bank" RESET vector
     0011             (   monitor1v4.asm):00588         B?SWP_SZ EQU      *-BSWAP                           ; size of bankswap function
                      (   monitor1v4.asm):00589         
                      (   monitor1v4.asm):00590         ;;
                      (   monitor1v4.asm):00591         ;; MOVEUP - move bytes from $0000-$3FFF to upper RAM/ROM area, disable the 
                      (   monitor1v4.asm):00592         ;;          ROM decoding, and start execution from RAM reset vector.
                      (   monitor1v4.asm):00593         ;;
E629                  (   monitor1v4.asm):00594         MOVEUP:
E629 104F             (   monitor1v4.asm):00595                  CLRD                                       ; address of RAM block start is $0
E62B 8EC000           (   monitor1v4.asm):00596                  LDX      #$C000                            ; address of HIGH RAM start
E62E 10864000         (   monitor1v4.asm):00597                  LDW      #$4000                            ; length of RAM block
E632 113801           (   monitor1v4.asm):00598                  TFM      D+,X+                             ; copy the block to RAM (W=0)
E635 1F61             (   monitor1v4.asm):00599                  TFR      W,X                               ; clear X (W is always 0)
E637 11C60C           (   monitor1v4.asm):00600                  LDF      #R?SEL_SZ                         ; length of block (MSB E is already 0)
E63A CCE642           (   monitor1v4.asm):00601                  LDD      #RAMSEL                           ; address of ROM disable+JMP snippet
E63D 113801           (   monitor1v4.asm):00602                  TFM      D+,X+                             ; copy the snippet (W=0)
E640 6E8F             (   monitor1v4.asm):00603                  JMP      ,W                                ; jump to 0
E642 72F9E040         (   monitor1v4.asm):00604         RAMSEL   AIM      #~(SYS.ROMSEL|SYS.ROMSEH),SYSCFG  ; disable all ROM
E646 104F             (   monitor1v4.asm):00605                  CLRD
E648 1F8B             (   monitor1v4.asm):00606                  TFR      A,DP                              ; DP should be 0 on a "reset"
E64A 6E9FFFFE         (   monitor1v4.asm):00607                  JMP      [V_RESET]                         ; jump to the RESET vector in RAM
     000C             (   monitor1v4.asm):00608         R?SEL_SZ EQU      *-RAMSEL                          ; size of bankswap function
                      (   monitor1v4.asm):00609         
                      (   monitor1v4.asm):00610         ;;
                      (   monitor1v4.asm):00611         ;; MOVEMON - copy ROM Monitor into upper RAM area,
                      (   monitor1v4.asm):00612         ;;           then disable ROM decoding ("move Monitor to RAM").
                      (   monitor1v4.asm):00613         ;;           Allows for debugging of WOZMON and Utils via NoICE
E64E                  (   monitor1v4.asm):00614         MOVEMON:
E64E 8EC000           (   monitor1v4.asm):00615                  LDX      #$C000                            ; address of ROM start
E651 1F12             (   monitor1v4.asm):00616                  TFR      X,Y                               ; address of HIGH RAM start
E653 10863FFF         (   monitor1v4.asm):00617                  LDW      #$3FFF                            ; length of RAM block
E657 113812           (   monitor1v4.asm):00618                  TFM      X+,Y+                             ; copy the ROM to RAM
E65A 72F9E040         (   monitor1v4.asm):00619                  AIM      #~(SYS.ROMSEL|SYS.ROMSEH),SYSCFG  ; disable ROM (safe to do - we're "in place")
E65E 39               (   monitor1v4.asm):00620                  RTS
                      (   monitor1v4.asm):00621                  
                      (   monitor1v4.asm):00622         ;;======================================================================
                      (   monitor1v4.asm):00623         ;; PLATFORM DEPENDENT Z8536 CIO UTILITY FUNCTIONS
                      (   monitor1v4.asm):00624         ;;======================================================================
                      (   monitor1v4.asm):00625         
                      (   monitor1v4.asm):00626         ;;
                      (   monitor1v4.asm):00627         ;; CIO_Initialize - put the Z8536 CIO into a known state.
                      (   monitor1v4.asm):00628         ;;                  Call this before trying to use the
                      (   monitor1v4.asm):00629         ;;                  CIO_ReadReg and CIO_WriteReg functions!
                      (   monitor1v4.asm):00630         ;; inputs: none
                      (   monitor1v4.asm):00631         ;; return: A is destroyed
                      (   monitor1v4.asm):00632         ;;
E65F                  (   monitor1v4.asm):00633         CIO_Initialize:
E65F B6E003           (   monitor1v4.asm):00634                  LDA      CIOCTL                            ; read CIO control register to get to state 0
E662 8D1C             (   monitor1v4.asm):00635                  BSR      ZI?                               ; a read will force the z8536 into state 0 if in state 1, otherwise it will
                      (   monitor1v4.asm):00636         ; not cause any changes
E664 4F               (   monitor1v4.asm):00637                  CLRA                                       ; if the z8536 was reset, writing a 0 will force it into state 0. if in
E665 B7E003           (   monitor1v4.asm):00638                  STA      CIOCTL                            ; state 0, this will set the pointer to register 0 and go to state 1.
E668 8D16             (   monitor1v4.asm):00639                  BSR      ZI?
E66A B6E003           (   monitor1v4.asm):00640                  LDA      CIOCTL                            ; another read operation will force the 8536 into state 0, from where further
E66D 8D11             (   monitor1v4.asm):00641                  BSR      ZI?                               ; instructions can be done
E66F 4F               (   monitor1v4.asm):00642                  CLRA                                       ; set address pointer to master interrupt control register (addr 0)
E670 B7E003           (   monitor1v4.asm):00643                  STA      CIOCTL
E673 8D0B             (   monitor1v4.asm):00644                  BSR      ZI?
E675 8601             (   monitor1v4.asm):00645                  LDA      #1                                ; reset the z8536 by enabling the reset bit (b0)
E677 B7E003           (   monitor1v4.asm):00646                  STA      CIOCTL
E67A 8D04             (   monitor1v4.asm):00647                  BSR      ZI?                               ; next, by writing a 0 to register 0 during reset, the reset will be cleared.
E67C 4F               (   monitor1v4.asm):00648                  CLRA                                       ; successive writes can only be done during reset (during normal operation,
E67D B7E003           (   monitor1v4.asm):00649                  STA      CIOCTL                            ; successive writes will change the address pointer to that output value).
E680 12               (   monitor1v4.asm):00650         ZI?      NOP
E681 12               (   monitor1v4.asm):00651                  NOP
E682 12               (   monitor1v4.asm):00652                  NOP
E683 39               (   monitor1v4.asm):00653                  RTS
                      (   monitor1v4.asm):00654         
                      (   monitor1v4.asm):00655         ;;
                      (   monitor1v4.asm):00656         ;; CIO_ReadReg - Z8536 CIOCTL Register READ Function
                      (   monitor1v4.asm):00657         ;; inputs: A = register number to read (0...3F)
                      (   monitor1v4.asm):00658         ;; return: B = value from register
                      (   monitor1v4.asm):00659         ;;
E684                  (   monitor1v4.asm):00660         CIO_ReadReg:
E684 F6E003           (   monitor1v4.asm):00661                  LDB      CIOCTL                            ; read CIO control register to get to state 0
E687 843F             (   monitor1v4.asm):00662                  ANDA     #$3F                              ; make sure register value is in range
E689 B7E003           (   monitor1v4.asm):00663                  STA      CIOCTL                            ; set the address pointer to the desired register
E68C F6E003           (   monitor1v4.asm):00664                  LDB      CIOCTL                            ; read the contents of the register
E68F 39               (   monitor1v4.asm):00665                  RTS
                      (   monitor1v4.asm):00666         
                      (   monitor1v4.asm):00667         ;;
                      (   monitor1v4.asm):00668         ;; CIO_WriteReg - Z8536 CIOCTL register WRITE Function
                      (   monitor1v4.asm):00669         ;; inputs: A = register number to read (0...3F)
                      (   monitor1v4.asm):00670         ;;         B = value to write to register
                      (   monitor1v4.asm):00671         ;; return: none
                      (   monitor1v4.asm):00672         ;;
E690                  (   monitor1v4.asm):00673         CIO_WriteReg:
E690 7DE003           (   monitor1v4.asm):00674                  TST      CIOCTL                            ; read CIO control register to get to state 0
E693 843F             (   monitor1v4.asm):00675                  ANDA     #$3F                              ; make sure it's in range
E695 B7E003           (   monitor1v4.asm):00676                  STA      CIOCTL                            ; set the address pointer to the desired register
E698 F7E003           (   monitor1v4.asm):00677                  STB      CIOCTL
E69B 39               (   monitor1v4.asm):00678                  RTS
                      (   monitor1v4.asm):00679         
                      (   monitor1v4.asm):00680         ;;======================================================================
                      (   monitor1v4.asm):00681         ;; PLATFORM DEPENDENT Z85C30 CHARACTER INPUT AND OUTPUT FUNCTIONS
                      (   monitor1v4.asm):00682         ;;======================================================================
                      (   monitor1v4.asm):00683         
                      (   monitor1v4.asm):00684         ;; Map the CONSOLE functions to the appropriate SCC channel
                      (   monitor1v4.asm):00685                     IFEQ (CONSOLE_CH-SCC_CHA)
     E012             (   monitor1v4.asm):00686         CONSOLE_CMD    EQU  ZSCCAC
     E013             (   monitor1v4.asm):00687         CONSOLE_DAT    EQU  ZSCCAD
     E69C             (   monitor1v4.asm):00688         CONSOLE_INIT   EQU  SCC_InitA
                      (   monitor1v4.asm):00689                     ELSE
E69C                  (   monitor1v4.asm):00690         CONSOLE_CMD    EQU  ZSCCBC
E69C                  (   monitor1v4.asm):00691         CONSOLE_DAT    EQU  ZSCCBD
E69C                  (   monitor1v4.asm):00692         CONSOLE_INIT   EQU  SCC_InitB
                      (   monitor1v4.asm):00693                     ENDC                  
                      (   monitor1v4.asm):00694         
                      (   monitor1v4.asm):00695         ;; Map the DEBUG functions to the appropriate SCC channel
                      (   monitor1v4.asm):00696                     IFEQ (DEBUG_CH-SCC_CHA)
E69C                  (   monitor1v4.asm):00697         DEBUG_CMD      EQU  ZSCCAC
E69C                  (   monitor1v4.asm):00698         DEBUG_DAT      EQU  ZSCCAD
E69C                  (   monitor1v4.asm):00699         DEBUG_INIT     EQU  SCC_InitA
                      (   monitor1v4.asm):00700                     ELSE
     E010             (   monitor1v4.asm):00701         DEBUG_CMD      EQU  ZSCCBC
     E011             (   monitor1v4.asm):00702         DEBUG_DAT      EQU  ZSCCBD
     E6A7             (   monitor1v4.asm):00703         DEBUG_INIT     EQU  SCC_InitB
                      (   monitor1v4.asm):00704                     ENDC                  
                      (   monitor1v4.asm):00705         
                      (   monitor1v4.asm):00706         ;;
                      (   monitor1v4.asm):00707         ;; SCC_InitA - Initialize SCC channel A to default
                      (   monitor1v4.asm):00708         ;; return: all registers preserved
                      (   monitor1v4.asm):00709         ;;
E69C                  (   monitor1v4.asm):00710         SCC_InitA:
E69C 3432             (   monitor1v4.asm):00711                  PSHS     A,X,Y                             ; preserve A,X,Y
E69E 108EE012         (   monitor1v4.asm):00712                  LDY      #ZSCCAC                           ; Y points to channel A command reg
E6A2 8EE6C2           (   monitor1v4.asm):00713                  LDX      #SCCATBL                          ; X points to channel A config table
E6A5 2009             (   monitor1v4.asm):00714                  BRA      IS0                               ; perform channel init
                      (   monitor1v4.asm):00715         
                      (   monitor1v4.asm):00716         ;;
                      (   monitor1v4.asm):00717         ;; SCC_InitB - Initialize SCC channel B to default
                      (   monitor1v4.asm):00718         ;; return: all registers preserved
                      (   monitor1v4.asm):00719         ;;
E6A7                  (   monitor1v4.asm):00720         SCC_InitB:
E6A7 3432             (   monitor1v4.asm):00721                  PSHS     A,X,Y                             ; preserve A,X,Y
E6A9 108EE010         (   monitor1v4.asm):00722                  LDY      #ZSCCBC                           ; Y points to channel B command reg 
E6AD 8EE6D2           (   monitor1v4.asm):00723                  LDX      #SCCBTBL                          ; X points to channel B config table
E6B0 A6A4             (   monitor1v4.asm):00724         IS0      LDA      ,Y                                ; reset register pointer to WR0/RR0
E6B2 A680             (   monitor1v4.asm):00725         IS1?     LDA      ,X+                               ; load address from table
E6B4 81FF             (   monitor1v4.asm):00726                  CMPA     #$FF                              ; is it $FF? (end of table)
E6B6 2708             (   monitor1v4.asm):00727                  BEQ      IS2?                              ;    yes, done with init of channel
E6B8 A7A4             (   monitor1v4.asm):00728                  STA      ,Y                                ;    no, write the register pointer to WR0
E6BA A680             (   monitor1v4.asm):00729                  LDA      ,X+                               ; get data byte from table
E6BC A7A4             (   monitor1v4.asm):00730                  STA      ,Y                                ; write data to SCC command register
E6BE 20F2             (   monitor1v4.asm):00731                  BRA      IS1?                              ; repeat until EOT reached..
E6C0 35B2             (   monitor1v4.asm):00732         IS2?     PULS     A,X,Y,PC                          ; restore registers and return
                      (   monitor1v4.asm):00733         
                      (   monitor1v4.asm):00734         ; Initialization table for SCC Channel A in ASYNC mode, external 16x clock
                      (   monitor1v4.asm):00735         ; ACLK from CPLD is 1.843 MHz. 1.843 / 16 = 115.2kbps (USB VCP interface)
E6C2                  (   monitor1v4.asm):00736         SCCATBL:
E6C2 0980             (   monitor1v4.asm):00737                  FCB      $09,$80                           ; Point to WR9; Reset Ch A
E6C4 0900             (   monitor1v4.asm):00738                  FCB      $09,$00                           ; Point to WR9; un-reset CH A
E6C6 0444             (   monitor1v4.asm):00739                  FCB      $04,$44                           ; Point to WR4; X16 clock,1 Stop,NP
E6C8 03C1             (   monitor1v4.asm):00740                  FCB      $03,$C1                           ; Point to WR3; Enable receiver, No Auto Enable (Hardware CTS), Receive 8 bits
E6CA 05EA             (   monitor1v4.asm):00741                  FCB      $05,$EA                           ; Point to WR5; Enable, Transmit 8 bits RTS,DTR, Enable
E6CC 0B05             (   monitor1v4.asm):00742                  FCB      $0B,$05                           ; Point to WR11; RX clock = TX clock = RTXC pin; TRXC pin = xmit clock
E6CE 0F00             (   monitor1v4.asm):00743                  FCB      $0F,$00                           ; Point to WR15; no INT from hardware CTS/RTS
E6D0 FFFF             (   monitor1v4.asm):00744                  FCB      $FF,$FF                           ; EOT marker         
                      (   monitor1v4.asm):00745         
                      (   monitor1v4.asm):00746         ; Initialization table for SCC Channel B in ASYNC mode, external 32x clock
                      (   monitor1v4.asm):00747         ; BCLK from CPLD is 3.686 MHz. 3.686M / 32 = 115.2kbps (CH B Header)
E6D2                  (   monitor1v4.asm):00748         SCCBTBL:
E6D2 0940             (   monitor1v4.asm):00749                  FCB      $09,$40                           ; WR9, reset channel B
E6D4 0900             (   monitor1v4.asm):00750                  FCB      $09,$00                           ; WR9, un-reset channel B
E6D6 0484             (   monitor1v4.asm):00751                  FCB      $04,$84                           ; WR4, X32 clock,1 Stop,NP
E6D8 03C1             (   monitor1v4.asm):00752                  FCB      $03,$C1                           ; WR3, Enable receiver, No Auto Enable (Hardware CTS), Receive 8 bits
E6DA 05EA             (   monitor1v4.asm):00753                  FCB      $05,$EA                           ; WR5, Enable transmitter, Transmit 8 bits RTS,DTR
E6DC 0B05             (   monitor1v4.asm):00754                  FCB      $0B,$05                           ; WR11, RX clock = TX clock = RTXC pin; TRXC pin = xmit clock
E6DE 0F00             (   monitor1v4.asm):00755                  FCB      $0F,$00                           ; WR15, No INT from hardware CTS/RTS
E6E0 FFFF             (   monitor1v4.asm):00756                  FCB      $FF,$FF                           ; EOT marker
                      (   monitor1v4.asm):00757         
                      (   monitor1v4.asm):00758         ;;
                      (   monitor1v4.asm):00759         ;; GETCH - wait forever for a character from CONSOLE channel
                      (   monitor1v4.asm):00760         ;; GETCHT - as GETCH, but also toggle LED1 each timeout
                      (   monitor1v4.asm):00761         ;; GETCH1 - one attempt to get a character from CONSOLE channel
                      (   monitor1v4.asm):00762         ;; GETCH2 - attempt for ~500ms to get a character from CONSOLE channel
                      (   monitor1v4.asm):00763         ;; inputs:  none
                      (   monitor1v4.asm):00764         ;; return:  A=character received
                      (   monitor1v4.asm):00765         ;;          V=0 if data received
                      (   monitor1v4.asm):00766         ;;          V=1 if timeout (0.5 seconds)
                      (   monitor1v4.asm):00767         ;;
                      (   monitor1v4.asm):00768         ; GETCH entry point - infinite retry duration
E6E2                  (   monitor1v4.asm):00769         GETCH:
E6E2 8D1E             (   monitor1v4.asm):00770                  BSR      GETCH2                            ; process as GETCH2
E6E4 29FC             (   monitor1v4.asm):00771                  BVS      GETCH                             ;  if no character, keep trying
E6E6 39               (   monitor1v4.asm):00772                  RTS                                        ;  otherwise, return with char in A
                      (   monitor1v4.asm):00773         ; GETCHT entry point - infinite retry duration with LED1 toggle each timeout
E6E7                  (   monitor1v4.asm):00774         GETCHT:
                      (   monitor1v4.asm):00775                  OnLED1                                     ; turn on LED1 while attempting input
E6E7 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
E6EB 8D15             (   monitor1v4.asm):00776         G?T      BSR      GETCH2                            ; go try to get a character
E6ED 2806             (   monitor1v4.asm):00777                  BVC      G?X                               ;   got one, return
                      (   monitor1v4.asm):00778                  ToggleLED1                                 ; toggle LED1 each timeout
E6EF 7501E050         (       ToggleLED1):00001                  EIM      #IO.LED1,IOPORT                   ; toggle LED1
E6F3 20F6             (   monitor1v4.asm):00779                  BRA      G?T                               ; and try again
E6F5                  (   monitor1v4.asm):00780         G?X      OnLED1                                     ; got a character, turn LED1 back on
E6F5 7101E050         (           OnLED1):00001                  OIM      #IO.LED1,IOPORT                   ; turn on LED1
E6F9 39               (   monitor1v4.asm):00781                  RTS
                      (   monitor1v4.asm):00782         ; GETCH1 entry point - one attempt
E6FA                  (   monitor1v4.asm):00783         GETCH1:
E6FA 3420             (   monitor1v4.asm):00784                  PSHS     Y                                 ; preserve Y
E6FC 108E0002         (   monitor1v4.asm):00785                  LDY      #2                                ; only check once for a character in channel A
E700 2006             (   monitor1v4.asm):00786                  BRA      GC10?                             ; process as GETCH2
                      (   monitor1v4.asm):00787         ; GETCH2 entry point - standard timeout
E702                  (   monitor1v4.asm):00788         GETCH2:
E702 3420             (   monitor1v4.asm):00789                  PSHS     Y                                 ; preserve Y
E704 108E0000         (   monitor1v4.asm):00790                  LDY      #0                                ; clear Y for longest timeout (~450ms)
E708 1A02             (   monitor1v4.asm):00791         GC10?    ORCC     #CC_V                             ; set V flag ahead of decrement
E70A 313F             (   monitor1v4.asm):00792                  LEAY     -1,Y                              ; decrement timeout counter (V unaffected)
E70C 270F             (   monitor1v4.asm):00793                  BEQ      GC90?                             ;  EXIT IF TIMEOUT (with V=1)
E70E B6E012           (   monitor1v4.asm):00794                  LDA      CONSOLE_CMD                       ; reset register pointer to WR0/RR0
E711 B6E012           (   monitor1v4.asm):00795                  LDA      CONSOLE_CMD                       ; read RR0
E714 8401             (   monitor1v4.asm):00796                  ANDA     #ZSCC.RXBF                        ; examine the RX char available bit
E716 27F0             (   monitor1v4.asm):00797                  BEQ      GC10?                             ;  LOOP UNTIL CHARACTER AVAILABLE
E718 B6E013           (   monitor1v4.asm):00798                  LDA      CONSOLE_DAT                       ; read character
E71B 8A00             (   monitor1v4.asm):00799                  ORA      #0                                ; clear V flag
E71D 35A0             (   monitor1v4.asm):00800         GC90?    PULS     Y,PC                              ; restore Y and return
                      (   monitor1v4.asm):00801         
                      (   monitor1v4.asm):00802         ;;
                      (   monitor1v4.asm):00803         ;; PUTCH - output character in A to CONSOLE channel
                      (   monitor1v4.asm):00804         ;; inputs: character in A
                      (   monitor1v4.asm):00805         ;; return: all registers preserved
                      (   monitor1v4.asm):00806         ;;
E71F                  (   monitor1v4.asm):00807         PUTCH:
E71F 3402             (   monitor1v4.asm):00808                  PSHS     A
E721 B6E012           (   monitor1v4.asm):00809         PC10?    LDA      CONSOLE_CMD                       ; reset SCC register pointer to WR0/RR0
E724 B6E012           (   monitor1v4.asm):00810                  LDA      CONSOLE_CMD                       ; read RR0
E727 8404             (   monitor1v4.asm):00811                  ANDA     #ZSCC.TXBE                        ;  examine the TX buffer empty bit
E729 27F6             (   monitor1v4.asm):00812                  BEQ      PC10?                             ;  LOOP UNTIL EMPTY
E72B 3502             (   monitor1v4.asm):00813                  PULS     A
E72D B7E013           (   monitor1v4.asm):00814                  STA      CONSOLE_DAT                       ; write character to SCC A data reg
E730 39               (   monitor1v4.asm):00815                  RTS
                      (   monitor1v4.asm):00816         
                      (   monitor1v4.asm):00817         ;;======================================================================
                      (   monitor1v4.asm):00818         ;; PLATFORM DEPENDENT Z85C30 CONSOLE UTILITY FUNCTIONS
                      (   monitor1v4.asm):00819         ;;======================================================================
                      (   monitor1v4.asm):00820         
                      (   monitor1v4.asm):00821         ;;
                      (   monitor1v4.asm):00822         ;; PUTCR - output CRLF to CONSOLE channel
                      (   monitor1v4.asm):00823         ;; return: all registers preserved
                      (   monitor1v4.asm):00824         ;;
E731                  (   monitor1v4.asm):00825         PUTCR:
E731 3402             (   monitor1v4.asm):00826                  PSHS     A                                 ; save A value
E733 860D             (   monitor1v4.asm):00827         PUTCR1   LDA      #CR                               ; output a carriage return
E735 8DE8             (   monitor1v4.asm):00828                  BSR      PUTCH                             ;
E737 860A             (   monitor1v4.asm):00829                  LDA      #LF                               ; output a line feed
E739 8DE4             (   monitor1v4.asm):00830                  BSR      PUTCH                             ;
E73B 3582             (   monitor1v4.asm):00831                  PULS     A,PC                              ; restore A and PC and return
                      (   monitor1v4.asm):00832         
                      (   monitor1v4.asm):00833         ;;
                      (   monitor1v4.asm):00834         ;; PUTSPACE - output a SPACE to CONSOLE channel
                      (   monitor1v4.asm):00835         ;; return: all registers preserved
                      (   monitor1v4.asm):00836         ;;
E73D                  (   monitor1v4.asm):00837         PUTSPACE:
E73D 3402             (   monitor1v4.asm):00838                  PSHS     A
E73F 8620             (   monitor1v4.asm):00839                  LDA      #SPACE
E741 8DDC             (   monitor1v4.asm):00840                  BSR      PUTCH
E743 3582             (   monitor1v4.asm):00841                  PULS     A,PC
                      (   monitor1v4.asm):00842         
                      (   monitor1v4.asm):00843         ;;
                      (   monitor1v4.asm):00844         ;; PUTWORD - output ASCII HEX WORD to CONSOLE channel
                      (   monitor1v4.asm):00845         ;; inputs: D = value to output
                      (   monitor1v4.asm):00846         ;; return: all registers preserved
                      (   monitor1v4.asm):00847         ;;
E745                  (   monitor1v4.asm):00848         PUTWORD:
E745 8D07             (   monitor1v4.asm):00849                  BSR      PUTBYTE                           ; A is MSB, output it first
E747 1E98             (   monitor1v4.asm):00850                  EXG      B,A                               ; swap bytes
E749 8D03             (   monitor1v4.asm):00851                  BSR      PUTBYTE                           ; now output LSB
E74B 1E98             (   monitor1v4.asm):00852                  EXG      B,A                               ; restore A and B
E74D 39               (   monitor1v4.asm):00853                  RTS
                      (   monitor1v4.asm):00854         
                      (   monitor1v4.asm):00855         ;;
                      (   monitor1v4.asm):00856         ;; PUTBYTE - output ASCII HEX BYTE to CONSOLE channel
                      (   monitor1v4.asm):00857         ;; inputs: A = value to output
                      (   monitor1v4.asm):00858         ;; return: all registers preserved
                      (   monitor1v4.asm):00859         ;;
E74E                  (   monitor1v4.asm):00860         PUTBYTE:
E74E 3402             (   monitor1v4.asm):00861                  PSHS     A                                 ; Save low nibble
E750 44               (   monitor1v4.asm):00862                  LSRA                                       ; Rotate
E751 44               (   monitor1v4.asm):00863                  LSRA                                       ; upper nibble
E752 44               (   monitor1v4.asm):00864                  LSRA                                       ; into
E753 44               (   monitor1v4.asm):00865                  LSRA                                       ; lower nibble
E754 8D02             (   monitor1v4.asm):00866                  BSR      PUTHEX                            ; Output high nibble
E756 3502             (   monitor1v4.asm):00867                  PULS     A                                 ; Restore low nibble
                      (   monitor1v4.asm):00868         ; fall into PUTHEX...
                      (   monitor1v4.asm):00869         
                      (   monitor1v4.asm):00870         ;;
                      (   monitor1v4.asm):00871         ;; PUTHEX - output ASCII HEX NIBBLE to CONSOLE channel
                      (   monitor1v4.asm):00872         ;; inputs: A = value to output
                      (   monitor1v4.asm):00873         ;; return: all registers preserved
                      (   monitor1v4.asm):00874         ;;
E758                  (   monitor1v4.asm):00875         PUTHEX:
E758 3402             (   monitor1v4.asm):00876                  PSHS     A                                 ; preserve A
E75A 840F             (   monitor1v4.asm):00877                  ANDA     #$0F                              ; Remove upper half
E75C 8B30             (   monitor1v4.asm):00878                  ADDA     #'0'                              ; Convert to printable
E75E 8139             (   monitor1v4.asm):00879                  CMPA     #'9'                              ; In range?
E760 2302             (   monitor1v4.asm):00880                  BLS      P?H0                              ;   yes, skip alpha adjust
E762 8B07             (   monitor1v4.asm):00881                  ADDA     #7                                ; Convert to alpha
E764 8DB9             (   monitor1v4.asm):00882         P?H0     BSR      PUTCH                             ; output via PUTCH
E766 3582             (   monitor1v4.asm):00883                  PULS     A,PC                              ; restore A and return
                      (   monitor1v4.asm):00884         
                      (   monitor1v4.asm):00885         ;;
                      (   monitor1v4.asm):00886         ;; PUTCONST - output character at PC to CONSOLE channel.
                      (   monitor1v4.asm):00887         ;; inputs:  PC = address of character to output
                      (   monitor1v4.asm):00888         ;; return:  all registers preserved
                      (   monitor1v4.asm):00889         ;;
E768                  (   monitor1v4.asm):00890         PUTCONST:
E768 3412             (   monitor1v4.asm):00891                  PSHS     A,X                               ; preserve A,X
E76A AE63             (   monitor1v4.asm):00892                  LDX      3,S                               ; get old PC
E76C A680             (   monitor1v4.asm):00893                  LDA      ,X+                               ; get character, increment past it (new PC)
E76E 8DAF             (   monitor1v4.asm):00894                  BSR      PUTCH                             ; output character
E770 AF63             (   monitor1v4.asm):00895                  STX      3,S                               ; store new PC
E772 3592             (   monitor1v4.asm):00896                  PULS     A,X,PC
                      (   monitor1v4.asm):00897         
                      (   monitor1v4.asm):00898         ;;
                      (   monitor1v4.asm):00899         ;; PUTMSG - output NULL/FF terminated string at PC to CONSOLE channel
                      (   monitor1v4.asm):00900         ;; terminate with either 0, or $FF (CRLF before terminates)
                      (   monitor1v4.asm):00901         ;; inputs: PC = address of string to output
                      (   monitor1v4.asm):00902         ;; return: all registers intact
                      (   monitor1v4.asm):00903         ;;
E774                  (   monitor1v4.asm):00904         PUTMSG:
E774 3410             (   monitor1v4.asm):00905                  PSHS     X                                             ; save old x                                     
E776 AE62             (   monitor1v4.asm):00906                  LDX      2,S                               ; get old pc
E778 8D04             (   monitor1v4.asm):00907                  BSR      PUTSTR                            ; output string
E77A AF62             (   monitor1v4.asm):00908                  STX      2,S                               ; update old pc
E77C 3590             (   monitor1v4.asm):00909                  PULS     X,PC                              ; restore X and return
                      (   monitor1v4.asm):00910                  
                      (   monitor1v4.asm):00911         ;;
                      (   monitor1v4.asm):00912         ;; PUTSTR - output NULL/FF terminated string at X to CONSOLE channel
                      (   monitor1v4.asm):00913         ;; terminate with either 0, or $FF (CRLF before terminates)
                      (   monitor1v4.asm):00914         ;; inputs: X = address of string to output
                      (   monitor1v4.asm):00915         ;; return: X = terminator byte of string+1
                      (   monitor1v4.asm):00916         ;;
E77E                  (   monitor1v4.asm):00917         PUTSTR:
E77E 3402             (   monitor1v4.asm):00918                  PSHS     A                                 ; preserve A
E780 A680             (   monitor1v4.asm):00919         P?S1     LDA      ,X+                               ; get char from message
E782 2709             (   monitor1v4.asm):00920                  BEQ      PSTRX?                            ;  0 = end
E784 81FF             (   monitor1v4.asm):00921                  CMPA     #$FF                              ; FF = newline end?
E786 27AB             (   monitor1v4.asm):00922                  BEQ      PUTCR1                            ;  yes, new line, exit via PUTCR
E788 BDE71F           (   monitor1v4.asm):00923                  JSR      PUTCH                             ; output character to term
E78B 20F3             (   monitor1v4.asm):00924                  BRA      P?S1                              ; keep going
E78D 3582             (   monitor1v4.asm):00925         PSTRX?   PULS     A,PC                              ; restore A and return
                      (   monitor1v4.asm):00926         
                      (   monitor1v4.asm):00927         ;;
                      (   monitor1v4.asm):00928         ;; GETBYTE - acquire an ASCII HEX byte from CONSOLE channel and return in A
                      (   monitor1v4.asm):00929         ;; inputs: none
                      (   monitor1v4.asm):00930         ;; return: V=0 means input was valid, byte value in A
                      (   monitor1v4.asm):00931         ;;         V=1 means input was non-ASII HEX, A is destroyed
                      (   monitor1v4.asm):00932         ;;
E78F                  (   monitor1v4.asm):00933         GETBYTE:
E78F 8D11             (   monitor1v4.asm):00934                  BSR      GETNIB                            ; Get FIRST nibble
E791 290E             (   monitor1v4.asm):00935                  BVS      GETB1?                            ; Invalid, abort (V=1)
E793 48               (   monitor1v4.asm):00936                  LSLA                                       ; Rotate
E794 48               (   monitor1v4.asm):00937                  LSLA                                       ; into
E795 48               (   monitor1v4.asm):00938                  LSLA                                       ; high
E796 48               (   monitor1v4.asm):00939                  LSLA                                       ; nibble
E797 3402             (   monitor1v4.asm):00940                  PSHS     A                                 ; Save for later
E799 8D07             (   monitor1v4.asm):00941                  BSR      GETNIB                            ; Get SECOND nibble
E79B 2902             (   monitor1v4.asm):00942                  BVS      GETB2?                            ;  bad, release storage and return with V=1
E79D AAE4             (   monitor1v4.asm):00943                  ORA      ,S                                ; Include high (and clear V)
E79F 3261             (   monitor1v4.asm):00944         GETB2?   LEAS     1,S                               ; release stack storage (V unaffected)
E7A1 39               (   monitor1v4.asm):00945         GETB1?   RTS
                      (   monitor1v4.asm):00946         
                      (   monitor1v4.asm):00947         ;;
                      (   monitor1v4.asm):00948         ;; GETNIB - acquire an ASCII HEX nibble from CONSOLE channel and return in A
                      (   monitor1v4.asm):00949         ;; inputs: none
                      (   monitor1v4.asm):00950         ;; return: V=0 means input was valid, nibble value in A
                      (   monitor1v4.asm):00951         ;;         V=1 means input was non-ASII HEX, A is preserved
                      (   monitor1v4.asm):00952         ;;
E7A2                  (   monitor1v4.asm):00953         GETNIB:
E7A2 BDE6E7           (   monitor1v4.asm):00954                  JSR      GETCHT                             ; get a character
E7A5 8030             (   monitor1v4.asm):00955                  SUBA     #'0'                              ; Convert numbers
E7A7 8109             (   monitor1v4.asm):00956                  CMPA     #9                                ; Numeric?
E7A9 230A             (   monitor1v4.asm):00957                  BLS      G?N1                              ; Yes, OK
E7AB 8007             (   monitor1v4.asm):00958                  SUBA     #7                                ; Convert alphas
E7AD 810A             (   monitor1v4.asm):00959                  CMPA     #10                               ; Under?
E7AF 2507             (   monitor1v4.asm):00960                  BLO      G?N2                              ; Yes, error
E7B1 810F             (   monitor1v4.asm):00961                  CMPA     #15                               ; Over?
E7B3 2203             (   monitor1v4.asm):00962                  BHI      G?N2                              ; Yes, error
E7B5 840F             (   monitor1v4.asm):00963         G?N1     ANDA     #$0F                              ; V=0 indicates good input
E7B7 39               (   monitor1v4.asm):00964                  RTS
E7B8 8B37             (   monitor1v4.asm):00965         G?N2     ADDA     #$37                              ; Normalize character
E7BA 1A02             (   monitor1v4.asm):00966                  ORCC     #CC_V                             ; V=1 indicates non-hex input
E7BC 39               (   monitor1v4.asm):00967                  RTS
                      (   monitor1v4.asm):00968         
                      (   monitor1v4.asm):00969         ;;
                      (   monitor1v4.asm):00970         ;; GETBDIG - acquire a bounded ASCII digit from CONSOLE channel and return in A
                      (   monitor1v4.asm):00971         ;; inputs: B = upper bound of valid digit ($00...$0F)
                      (   monitor1v4.asm):00972         ;; return: V=0 means input was valid, nibble value in A
                      (   monitor1v4.asm):00973         ;;         V=1 means input was invalid, A holds entry digit
                      (   monitor1v4.asm):00974         ;;         B is preserved
                      (   monitor1v4.asm):00975         ;;
E7BD                  (   monitor1v4.asm):00976         GETBDIG:
E7BD C40F             (   monitor1v4.asm):00977                  ANDB     #$0F                              ; strip bound to 0-F
E7BF 8DE1             (   monitor1v4.asm):00978                  BSR      GETNIB                            ; get a nibble from CONSOLE channel
E7C1 2906             (   monitor1v4.asm):00979                  BVS      G?D1                              ; exit with V=1 on error
E7C3 103789           (   monitor1v4.asm):00980                  CMPR     A,B                               ; compare input value with bound
E7C6 2501             (   monitor1v4.asm):00981                  BLO      G?D1                              ; input exceeded bound
E7C8 39               (   monitor1v4.asm):00982                  RTS                                        ; exit with V=0
E7C9 1A02             (   monitor1v4.asm):00983         G?D1     ORCC     #CC_V                             ; V=1 indicates non-hex input
E7CB 39               (   monitor1v4.asm):00984                  RTS
                      (   monitor1v4.asm):00985         
                      (   monitor1v4.asm):00986         ;;
                      (   monitor1v4.asm):00987         ;; GETPATT - Pattern input function (with echo)
                      (   monitor1v4.asm):00988         ;;         Get numeric input, each digit with upper bound. Values
                      (   monitor1v4.asm):00989         ;;         can be shifted/rotated, and then OR'd or STORED into
                      (   monitor1v4.asm):00990         ;;         a RAM array. This is all controlled via a PATTERN TABLE.
                      (   monitor1v4.asm):00991         ;; inputs: X = pointer to RAM array (typ. RTC regs 0-15)
                      (   monitor1v4.asm):00992         ;;         Y = pointer to PATTERN TABLE (see below)
                      (   monitor1v4.asm):00993         ;; return: V = 0 no error
                      (   monitor1v4.asm):00994         ;;         V = 1 error occurred
                      (   monitor1v4.asm):00995         ;;         Y is advanced to end of pattern table
                      (   monitor1v4.asm):00996         ;;         A,B are destroyed
                      (   monitor1v4.asm):00997         ;;
                      (   monitor1v4.asm):00998         ;; Time/Date Pattern Table conists of 3-byte tuples
                      (   monitor1v4.asm):00999         ;; and must be terminated by a NEGATIVE postbyte
                      (   monitor1v4.asm):01000         ;;
                      (   monitor1v4.asm):01001         ;; [SHIFT/BOUND],[OPER/OFFSET],[POSTBYTE]
                      (   monitor1v4.asm):01002         ;; SHIFT/BOUND
                      (   monitor1v4.asm):01003         ;; SSxxBBBB
                      (   monitor1v4.asm):01004         ;;  |    |
                      (   monitor1v4.asm):01005         ;;  |    +--- upper bound value (hex)
                      (   monitor1v4.asm):01006         ;;  +-------- 00 = no SHIFT of nybble
                      (   monitor1v4.asm):01007         ;;            01 = SHIFT nybble left by 4 (+$40)
                      (   monitor1v4.asm):01008         ;;            1x = ROTATE nybble right by 2 through carry (+$80)
                      (   monitor1v4.asm):01009         ;;
                      (   monitor1v4.asm):01010         ;; OPER/OFFSET
                      (   monitor1v4.asm):01011         ;; PPxxTTTT
                      (   monitor1v4.asm):01012         ;;  |    |
                      (   monitor1v4.asm):01013         ;;  |    +--- RTC array offset
                      (   monitor1v4.asm):01014         ;;  +-------- 00 = discard value
                      (   monitor1v4.asm):01015         ;;            01 = OR value into array (+$40)
                      (   monitor1v4.asm):01016         ;;            1x = STORE value into array (+$80)
                      (   monitor1v4.asm):01017         ;;
                      (   monitor1v4.asm):01018         ;; POSTBYTE
                      (   monitor1v4.asm):01019         ;;     > 127 = TERMINATE
                      (   monitor1v4.asm):01020         ;;     0 = No postbyte
                      (   monitor1v4.asm):01021         ;;     <x> = output ASCII character
                      (   monitor1v4.asm):01022         ;;
E7CC                  (   monitor1v4.asm):01023         GETPATT:
E7CC E6A4             (   monitor1v4.asm):01024                  LDB      ,Y                                ; get bounds/shift/rotate op
E7CE C40F             (   monitor1v4.asm):01025                  ANDB     #$0F                              ; mask off shift/rot info
E7D0 BDE7BD           (   monitor1v4.asm):01026                  JSR      GETBDIG                           ; get the bounded digit
E7D3 292E             (   monitor1v4.asm):01027                  BVS      P?ONE                             ; exit if error
E7D5 BDE758           (   monitor1v4.asm):01028                  JSR      PUTHEX                            ; echo character
E7D8 E6A0             (   monitor1v4.asm):01029                  LDB      ,Y+                               ; get bounds/shift/rotate op
E7DA C4C0             (   monitor1v4.asm):01030                  ANDB     #$C0                              ; isolate shift/rotate bits
E7DC 2A03             (   monitor1v4.asm):01031                  BPL      P?NOROT                           ;   if bit7 clear, not a rotate operation
E7DE 5F               (   monitor1v4.asm):01032                  CLRB                                       ; clear carry and shift op bit prior to rotate
E7DF 46               (   monitor1v4.asm):01033                  RORA                                       ; rotate lsb into CF
E7E0 46               (   monitor1v4.asm):01034                  RORA                                       ; rotate CF into msb
E7E1 5D               (   monitor1v4.asm):01035         P?NOROT  TSTB                                       ; check bit6 (if b7 was set, it's cleared already)
E7E2 2704             (   monitor1v4.asm):01036                  BEQ      P?NOOP                            ;   no shift required
E7E4 48               (   monitor1v4.asm):01037                  ASLA                                       ; shift A LSD into MSD
E7E5 48               (   monitor1v4.asm):01038                  ASLA     
E7E6 48               (   monitor1v4.asm):01039                  ASLA     
E7E7 48               (   monitor1v4.asm):01040                  ASLA     
E7E8 E6A0             (   monitor1v4.asm):01041         P?NOOP   LDB      ,Y+                               ; get operation/offset
E7EA 2B08             (   monitor1v4.asm):01042                  BMI      P?STOR                            ; if bit7 is set, STORE operation
E7EC C540             (   monitor1v4.asm):01043                  BITB     #$40                              ; bit7 clear, check bit6
E7EE 2708             (   monitor1v4.asm):01044                  BEQ      P?POST                            ;   bit76=00 means discard value
E7F0 C40F             (   monitor1v4.asm):01045                  ANDB     #$0F                              ; isolate offset info
E7F2 AA85             (   monitor1v4.asm):01046                  ORA      B,X                               ; OR old value into A
E7F4 C40F             (   monitor1v4.asm):01047         P?STOR   ANDB     #$0F                              ; isolate offset info
E7F6 A785             (   monitor1v4.asm):01048                  STA      B,X                               ; store value at offset
E7F8 A6A0             (   monitor1v4.asm):01049         P?POST   LDA      ,Y+                               ; get postbyte
E7FA 27D0             (   monitor1v4.asm):01050                  BEQ      GETPATT                           ;   if null, continue to next entry
E7FC 2B05             (   monitor1v4.asm):01051                  BMI      P?ONE                             ;   if neg, end of table
E7FE BDE71F           (   monitor1v4.asm):01052                  JSR      PUTCH                             ; otherwise, echo post character
E801 20C9             (   monitor1v4.asm):01053                  BRA      GETPATT                           ; continue to next entry
E803 39               (   monitor1v4.asm):01054         P?ONE    RTS
                      (   monitor1v4.asm):01055         
                      (   monitor1v4.asm):01056         ;;======================================================================
                      (   monitor1v4.asm):01057         ;; PLATFORM DEPENDENT TIME DELAY FUNCTIONS
                      (   monitor1v4.asm):01058         ;;======================================================================
                      (   monitor1v4.asm):01059         
                      (   monitor1v4.asm):01060         ;;
                      (   monitor1v4.asm):01061         ;; DELAYMS - software loop time delay function (ms)
                      (   monitor1v4.asm):01062         ;; inputs: X = number of ms to delay
                      (   monitor1v4.asm):01063         ;; output: X = 0, Z flag set
                      (   monitor1v4.asm):01064         ;;
     0258             (   monitor1v4.asm):01065         TIM1M             EQU  (CPU_FREQ_MHZ*1000)/5        ; TIM1M such that (5*TIMCON*CYCLE TIME)=1ms
E804                  (   monitor1v4.asm):01066         DELAYMS:
E804 3406             (   monitor1v4.asm):01067                  PSHS     D
E806 CC0258           (   monitor1v4.asm):01068         D?LY0    LDD      #TIM1M
E809 104A             (   monitor1v4.asm):01069         D?LY1    DECD                                       ;(2 cyc)
E80B 26FC             (   monitor1v4.asm):01070                  BNE      D?LY1                             ;(3 cyc) = 5 cycle inner loop
E80D 301F             (   monitor1v4.asm):01071                  LEAX     -1,X                              ;(5 cyc)
E80F 26F5             (   monitor1v4.asm):01072                  BNE      D?LY0                             ;(3 cyc) = TIMCON*5 + 8 outer loop
E811 3586             (   monitor1v4.asm):01073                  PULS     D,PC
                      (   monitor1v4.asm):01074         
                      (   monitor1v4.asm):01075         ;;
                      (   monitor1v4.asm):01076         ;; DELAYUS - software loop time delay function (10us)
                      (   monitor1v4.asm):01077         ;; inputs: X = number of 10us to delay
                      (   monitor1v4.asm):01078         ;; output: X = 0, Z flag set
                      (   monitor1v4.asm):01079         ;;
     0006             (   monitor1v4.asm):01080         TIM10U            EQU  (CPU_FREQ_MHZ*10)/5          ; TIM10U such that (5*TIMCON*CYCLE TIME)=1ms
E813                  (   monitor1v4.asm):01081         DELAYUS:
E813 3406             (   monitor1v4.asm):01082                  PSHS     D
E815 CC0006           (   monitor1v4.asm):01083         D?LY0    LDD      #TIM10U
E818 104A             (   monitor1v4.asm):01084         D?LY1    DECD                                       ;(2 cyc)
E81A 26FC             (   monitor1v4.asm):01085                  BNE      D?LY1                             ;(3 cyc) = 5 cycle inner loop
E81C 301F             (   monitor1v4.asm):01086                  LEAX     -1,X                              ;(5 cyc)
E81E 26F5             (   monitor1v4.asm):01087                  BNE      D?LY0                             ;(3 cyc) = TIMCON*5 + 8 outer loop
E820 3586             (   monitor1v4.asm):01088                  PULS     D,PC
                      (   monitor1v4.asm):01089         
                      (   monitor1v4.asm):01090         ;;======================================================================
                      (   monitor1v4.asm):01091         ;; PLATFORM DEPENDENT SOFT I2C FUNCTIONS - LOW LEVEL DRIVER
                      (   monitor1v4.asm):01092         ;;======================================================================
                      (   monitor1v4.asm):01093         
                      (   monitor1v4.asm):01094         ;; I2C status flags
     0000             (   monitor1v4.asm):01095         I2C_Success       EQU  0
     0001             (   monitor1v4.asm):01096         I2C_NoSlaveAck    EQU  1
     0002             (   monitor1v4.asm):01097         I2C_BusError      EQU  2
                      (   monitor1v4.asm):01098         
                      (   monitor1v4.asm):01099         ;; I2C Acknowledge Constants
     0001             (   monitor1v4.asm):01100         I2C_ACKNOWLEDGE   EQU  1
     0000             (   monitor1v4.asm):01101         I2C_NOTACKNOWLEDGE EQU 0
                      (   monitor1v4.asm):01102         
                      (   monitor1v4.asm):01103         ;;
                      (   monitor1v4.asm):01104         ;; I2C_Initialize - cycle SCK until SDA goes high, up to 255 times
                      (   monitor1v4.asm):01105         ;; This is per the DS3232M datasheet to re-sync communication.
                      (   monitor1v4.asm):01106         ;; inputs:  none
                      (   monitor1v4.asm):01107         ;; return:  V=0 if SDA went high during init
                      (   monitor1v4.asm):01108         ;;          V=1 if SDA remained low
                      (   monitor1v4.asm):01109         ;;
E822                  (   monitor1v4.asm):01110         I2C_Initialize:
E822 8680             (   monitor1v4.asm):01111                  LDA      #$80                              ; init cycle counter to $80
E824 BDE88F           (   monitor1v4.asm):01112         IN0?     JSR      I2C_SendNAK                       ; do a NAK cycle (toggles SCL with SDA high), SDA status in Z
E827 2629             (   monitor1v4.asm):01113                  BNE      I2C_SendStop                      ; SDA is high, so all is well, return via SendStop
E829 4C               (   monitor1v4.asm):01114                  INCA                                       ; increment cycle counter
E82A 28F8             (   monitor1v4.asm):01115                  BVC      IN0?                              ; not wrapped around to $80 yet, keep trying
E82C 39               (   monitor1v4.asm):01116                  RTS
                      (   monitor1v4.asm):01117         
                      (   monitor1v4.asm):01118         ;;
                      (   monitor1v4.asm):01119         ;; I2C_SendByte - sends one byte of data to an I2C slave device and check for Slave ACK
                      (   monitor1v4.asm):01120         ;; inputs:  A = byte to send to slave
                      (   monitor1v4.asm):01121         ;; return:  A = byte sent to slave
                      (   monitor1v4.asm):01122         ;;          Z = 1 if slave ACK'd byte
                      (   monitor1v4.asm):01123         ;;          Z = 0 if no slave ACK
                      (   monitor1v4.asm):01124         ;;
E82D                  (   monitor1v4.asm):01125         I2C_SendByte:
E82D 3416             (   monitor1v4.asm):01126                  PSHS     A,B,X                             ; preserve ACC A, B and X
E82F 8E0008           (   monitor1v4.asm):01127                  LDX      #8                                ; init X as loop counter
E832 F6E020           (   monitor1v4.asm):01128         SB0?     LDB      I2CPORT                           ; move I2C.DSDA [6] to B[7]
E835 58               (   monitor1v4.asm):01129                  ASLB
E836 103689           (   monitor1v4.asm):01130                  EORR     A,B                               ; EOR A[7] with I2C.DSDA
E839 2A04             (   monitor1v4.asm):01131                  BPL      SB1?                              ;   B[7]=0 means drive is correct
E83B 7540E020         (   monitor1v4.asm):01132                  EIM      #(I2C.DSDA),I2CPORT               ; change drive output polarity
E83F                  (   monitor1v4.asm):01133         SB1?     I2C_ReleaseSCL                             ; release SCL
E83F 7180E020         (   I2C_ReleaseSCL):00001                  OIM      #I2C.DSCL,I2CPORT                 ;Release SCL line
                      (   monitor1v4.asm):01134                  I2C_BitDelay                               ; half-bit delay
E843 12               (     I2C_BitDelay):00001                  NOP
                      (   monitor1v4.asm):01135                  I2C_SinkSCL                                ; drive SCL low
E844 727FE020         (      I2C_SinkSCL):00001                  AIM      #~I2C.DSCL,I2CPORT                ;Drive SCL line low
                      (   monitor1v4.asm):01136                  I2C_BitDelay                               ; half-bit delay
E848 12               (     I2C_BitDelay):00001                  NOP
E849 48               (   monitor1v4.asm):01137                  ASLA                                       ; shift ACC A to expose next bit to send
E84A 301F             (   monitor1v4.asm):01138                  LEAX     -1,X                              ; decrement loop counter
E84C 26E4             (   monitor1v4.asm):01139                  BNE      SB0?                              ;   repeat until all bits are sent
E84E 3516             (   monitor1v4.asm):01140                  PULS     A,B,X                             ; restore ACC A,B and X 
E850 203D             (   monitor1v4.asm):01141                  BRA      I2C_SendNAK                       ; exit via SendNAK (to check for slave ACK)
                      (   monitor1v4.asm):01142         
                      (   monitor1v4.asm):01143         ;;
                      (   monitor1v4.asm):01144         ;; I2C_SendStop - send a STOP condition
                      (   monitor1v4.asm):01145         ;; return: all registers preserved
                      (   monitor1v4.asm):01146         ;;
E852                  (   monitor1v4.asm):01147         I2C_SendStop:
                      (   monitor1v4.asm):01148                  I2C_SinkSDA                                ; SCL high followed by SDA high is STOP condition
E852 72BFE020         (      I2C_SinkSDA):00001                  AIM      #~I2C.DSDA,I2CPORT                ;Drive SDA line low
                      (   monitor1v4.asm):01149                  I2C_ReleaseSCL
E856 7180E020         (   I2C_ReleaseSCL):00001                  OIM      #I2C.DSCL,I2CPORT                 ;Release SCL line
                      (   monitor1v4.asm):01150                  I2C_BitDelay
E85A 12               (     I2C_BitDelay):00001                  NOP
                      (   monitor1v4.asm):01151                  I2C_ReleaseSDA                             
E85B 7140E020         (   I2C_ReleaseSDA):00001                  OIM      #I2C.DSDA,I2CPORT                 ;Release SDA line
                      (   monitor1v4.asm):01152                  I2C_BitDelay         
E85F 12               (     I2C_BitDelay):00001                  NOP
E860 39               (   monitor1v4.asm):01153                  RTS
                      (   monitor1v4.asm):01154         
                      (   monitor1v4.asm):01155         ;;
                      (   monitor1v4.asm):01156         ;; I2C_RcvByte - receives one byte of data from an I2C slave device, with
                      (   monitor1v4.asm):01157         ;;                the ability to control NAK or ACK of the received data
                      (   monitor1v4.asm):01158         ;; inputs: A = 0 to NAK upon receipt
                      (   monitor1v4.asm):01159         ;;         A != 0 to ACK upon receipt
                      (   monitor1v4.asm):01160         ;; return: A = byte received from slave
                      (   monitor1v4.asm):01161         ;;
E861                  (   monitor1v4.asm):01162         I2C_RcvByte:
E861 3414             (   monitor1v4.asm):01163                  PSHS     B,X                               ; preserve B and X
E863 1F89             (   monitor1v4.asm):01164                  TFR      A,B                               ; copy ACC A to B (to save ACK/NAK status)
E865 8E0008           (   monitor1v4.asm):01165                  LDX      #8                                ; init X as loop counter
E868 4F               (   monitor1v4.asm):01166                  CLRA                                       ; clear A before shifting in bits
                      (   monitor1v4.asm):01167                  I2C_ReleaseSDA                             ; allow SDA to be asserted by slave
E869 7140E020         (   I2C_ReleaseSDA):00001                  OIM      #I2C.DSDA,I2CPORT                 ;Release SDA line
E86D 48               (   monitor1v4.asm):01168         RB0?     LSLA                                       ; shift A left each loop iteration
                      (   monitor1v4.asm):01169                  I2C_ReleaseSCL                             ; release SCL, wait for stretch
E86E 7180E020         (   I2C_ReleaseSCL):00001                  OIM      #I2C.DSCL,I2CPORT                 ;Release SCL line
                      (   monitor1v4.asm):01170                  I2C_BitDelay                               ; half-bit delay
E872 12               (     I2C_BitDelay):00001                  NOP
                      (   monitor1v4.asm):01171                  I2C_StatSDA                                ; check SDA pin (Z = 1 if low)
E873 7B04E020         (      I2C_StatSDA):00001                  TIM      #I2C.MSDA,I2CPORT                 ;(Z = 1 if SDA is low)
E877 2702             (   monitor1v4.asm):01172                  BEQ      RB1?                              ; if SDA is low, leave ACC A alone
E879 8A01             (   monitor1v4.asm):01173                  ORA      #$01                              ; otherwise, set lsb
E87B                  (   monitor1v4.asm):01174         RB1?     I2C_SinkSCL                                ; clear SCL to end bit
E87B 727FE020         (      I2C_SinkSCL):00001                  AIM      #~I2C.DSCL,I2CPORT                ;Drive SCL line low
                      (   monitor1v4.asm):01175                  I2C_BitDelay                               ; half-bit delay
E87F 12               (     I2C_BitDelay):00001                  NOP
E880 301F             (   monitor1v4.asm):01176                  LEAX     -1,X                              ; decrement loop counter
E882 26E9             (   monitor1v4.asm):01177                  BNE      RB0?                              ; loop back until all bits are received
E884 5D               (   monitor1v4.asm):01178                  TSTB                                       ; examine ACK/NAK status (set/clear Z)
E885 3514             (   monitor1v4.asm):01179                  PULS     B,X                               ; restore B and X (flags unaffected)
E887 2706             (   monitor1v4.asm):01180                  BEQ      I2C_SendNAK                       ;   input parameter = 0, send a NAK
                      (   monitor1v4.asm):01181                  ; ..otherwise, fall into I2C_SendACK
                      (   monitor1v4.asm):01182                                                             
                      (   monitor1v4.asm):01183         ;;
                      (   monitor1v4.asm):01184         ;; I2C_SendACK - send ACK to I2C slave device
                      (   monitor1v4.asm):01185         ;; inputs: none
                      (   monitor1v4.asm):01186         ;; return: ACK/NAK status in Z (Z = 1 if either slave or master ACK)
                      (   monitor1v4.asm):01187         ;;
E889                  (   monitor1v4.asm):01188         I2C_SendACK:
                      (   monitor1v4.asm):01189                  I2C_SinkSDA                                ; assert SDA for MASTER ACK
E889 72BFE020         (      I2C_SinkSDA):00001                  AIM      #~I2C.DSDA,I2CPORT                ;Drive SDA line low
E88D 2004             (   monitor1v4.asm):01190                  BRA      I2C_SN0                           ; the rest is just like a NAK                                                   
                      (   monitor1v4.asm):01191                  
                      (   monitor1v4.asm):01192         ;;
                      (   monitor1v4.asm):01193         ;; I2C_SendNAK & SendACK - send a NAK or ACK to I2C slave device
                      (   monitor1v4.asm):01194         ;; inputs: none
                      (   monitor1v4.asm):01195         ;; return: ACK/NAK status in Z (Z = 1 if either slave or master ACK)
                      (   monitor1v4.asm):01196         ;;
E88F                  (   monitor1v4.asm):01197         I2C_SendNAK:
                      (   monitor1v4.asm):01198                  I2C_ReleaseSDA                             ; release SDA line for MASTER NAK / or query slave ACK
E88F 7140E020         (   I2C_ReleaseSDA):00001                  OIM      #I2C.DSDA,I2CPORT                 ;Release SDA line
E893                  (   monitor1v4.asm):01199         I2C_SN0  I2C_ReleaseSCL                             ; send clock for NAK
E893 7180E020         (   I2C_ReleaseSCL):00001                  OIM      #I2C.DSCL,I2CPORT                 ;Release SCL line
                      (   monitor1v4.asm):01200                  I2C_BitDelay                               ; half-bit delay
E897 12               (     I2C_BitDelay):00001                  NOP
                      (   monitor1v4.asm):01201                  I2C_StatSDA                                ; check of ACK bit
E898 7B04E020         (      I2C_StatSDA):00001                  TIM      #I2C.MSDA,I2CPORT                 ;(Z = 1 if SDA is low)
E89C 3401             (   monitor1v4.asm):01202                  PSHS     CC                                ; save CC bits                                                    
                      (   monitor1v4.asm):01203                  I2C_SinkSCL                                ; finish the NAK bit
E89E 727FE020         (      I2C_SinkSCL):00001                  AIM      #~I2C.DSCL,I2CPORT                ;Drive SCL line low
                      (   monitor1v4.asm):01204                  I2C_BitDelay                               ; half-bit delay
E8A2 12               (     I2C_BitDelay):00001                  NOP
E8A3 3581             (   monitor1v4.asm):01205                  PULS     CC,PC                             ; restore CC bits and return
                      (   monitor1v4.asm):01206         
                      (   monitor1v4.asm):01207         ;;
                      (   monitor1v4.asm):01208         ;; I2C_GoMaster - sends an I2C start and slave address and check for acknowledge
                      (   monitor1v4.asm):01209         ;; inputs:  A = slave address A[7:1] + R/W A[0]
                      (   monitor1v4.asm):01210         ;; return:  A = I2C.Success(0) or I2C_NoSlaveAck(1) or I2C.BusError(2)
                      (   monitor1v4.asm):01211         ;;          Z = 0 when I2C.Success, otherwise Z = 0
                      (   monitor1v4.asm):01212         ;;
E8A5                  (   monitor1v4.asm):01213         I2C_GoMaster:
                      (   monitor1v4.asm):01214                  I2C_ReleaseBoth                            ; release SDA and SCL
E8A5 71C0E020         (  I2C_ReleaseBoth):00001                  OIM      #(I2C.DSCL+I2C.DSDA),I2CPORT      ;Release both SDA and SCL lines
                      (   monitor1v4.asm):01215                  I2C_BitDelay                               ; allow SDA to float high
E8A9 12               (     I2C_BitDelay):00001                  NOP
                      (   monitor1v4.asm):01216                  I2C_StatSDA                                ; check SDA state
E8AA 7B04E020         (      I2C_StatSDA):00001                  TIM      #I2C.MSDA,I2CPORT                 ;(Z = 1 if SDA is low)
E8AE 2712             (   monitor1v4.asm):01217                  BEQ      GMBERR?                           ; if SDA is still low, return with fBusError
                      (   monitor1v4.asm):01218                  I2C_SinkSDA                                ; begin I2C START by bringing SDA low first
E8B0 72BFE020         (      I2C_SinkSDA):00001                  AIM      #~I2C.DSDA,I2CPORT                ;Drive SDA line low
                      (   monitor1v4.asm):01219                  I2C_BitDelay                               ; half-bit delay
E8B4 12               (     I2C_BitDelay):00001                  NOP
                      (   monitor1v4.asm):01220                  I2C_SinkSCL                                ; complete I2C START by bringing SCL low
E8B5 727FE020         (      I2C_SinkSCL):00001                  AIM      #~I2C.DSCL,I2CPORT                ;Drive SCL line low
                      (   monitor1v4.asm):01221                  I2C_BitDelay                               ; half-bit delay
E8B9 12               (     I2C_BitDelay):00001                  NOP
E8BA BDE82D           (   monitor1v4.asm):01222                  JSR      I2C_SendByte                      ; now send the byte in A, Z = 1 means sent OK
E8BD 2606             (   monitor1v4.asm):01223                  BNE      GMSNAK?                           ; if no slave ACK, then return with fNoSlaveAck
E8BF 8600             (   monitor1v4.asm):01224                  LDA      #I2C_Success                      ; send a fSuccess code (0)
E8C1 39               (   monitor1v4.asm):01225                  RTS
E8C2 8602             (   monitor1v4.asm):01226         GMBERR?  LDA      #I2C_BusError                     ; return a fBusError code (2)
E8C4 39               (   monitor1v4.asm):01227                  RTS
E8C5 8601             (   monitor1v4.asm):01228         GMSNAK?  LDA      #I2C_NoSlaveAck                   ; send a fNoSlaveAck code (1)
E8C7 39               (   monitor1v4.asm):01229                  RTS
                      (   monitor1v4.asm):01230         
                      (   monitor1v4.asm):01231         ;;======================================================================
                      (   monitor1v4.asm):01232         ;; PLATFORM DEPENDENT SOFT I2C FUNCTIONS - HIGH LEVEL SLAVE R/W
                      (   monitor1v4.asm):01233         ;;======================================================================
     00D0             (   monitor1v4.asm):01234         RTC.ADDRESS       EQU   $D0
     0000             (   monitor1v4.asm):01235         RTC.SECONDS       EQU   0
     0001             (   monitor1v4.asm):01236         RTC.MINUTES       EQU   1
     0002             (   monitor1v4.asm):01237         RTC.HOURS         EQU   2
     0003             (   monitor1v4.asm):01238         RTC.WEEKDAY       EQU   3
     0004             (   monitor1v4.asm):01239         RTC.DAY           EQU   4
     0005             (   monitor1v4.asm):01240         RTC.MONTH         EQU   5
     0006             (   monitor1v4.asm):01241         RTC.YEAR          EQU   6
     000E             (   monitor1v4.asm):01242         RTC.CONTROL       EQU   14
                      (   monitor1v4.asm):01243         
                      (   monitor1v4.asm):01244         ;;
                      (   monitor1v4.asm):01245         ;; RTC_ReadStatus - read the STATUS register from DS3232M RTC
                      (   monitor1v4.asm):01246         ;; RTC_ReadByte - read a single byte from the DS3232M RTC
                      (   monitor1v4.asm):01247         ;; inputs: B = register address
                      (   monitor1v4.asm):01248         ;;
                      (   monitor1v4.asm):01249         ;; I2C_ReadByte - read a single byte from a specific address
                      (   monitor1v4.asm):01250         ;; inputs: E = slave address
                      (   monitor1v4.asm):01251         ;;         B = register address
                      (   monitor1v4.asm):01252         ;; 
                      (   monitor1v4.asm):01253         ;; return: A = I2C.Success(0) or I2C_NoSlaveAck(1) or I2C.BusError(2)
                      (   monitor1v4.asm):01254         ;;         B = value of read data byte
                      (   monitor1v4.asm):01255         ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (   monitor1v4.asm):01256         ;;
                      (   monitor1v4.asm):01257         ;; READ REG  == [START], ADDR, [ack], <REG ADDR>, [ack], [START], ADDR, [ack], <read data>, [ACK], [STOP]
                      (   monitor1v4.asm):01258         ;;
E8C8                  (   monitor1v4.asm):01259         RTC_ReadStatus:
E8C8 C60F             (   monitor1v4.asm):01260                  LDB      #RTC.STATUS                       ; RTC status addr into B      
E8CA                  (   monitor1v4.asm):01261         RTC_ReadByte:
E8CA 1186D0           (   monitor1v4.asm):01262                  LDE      #RTC.ADDRESS                      ; RTC address into E
E8CD                  (   monitor1v4.asm):01263         I2C_ReadByte:
E8CD 1FE8             (   monitor1v4.asm):01264                  TFR      E,A                               ; slave address into A
E8CF 84FE             (   monitor1v4.asm):01265                  ANDA     #$FE                              ; send START and slave address (WRITE)
E8D1 BDE8A5           (   monitor1v4.asm):01266                  JSR      I2C_GoMaster                      ; try to send slave address
E8D4 2668             (   monitor1v4.asm):01267                  BNE      I_ERR                             ; error, return with status!
E8D6 1F98             (   monitor1v4.asm):01268                  TFR      B,A                               ; register address into A
E8D8 BDE82D           (   monitor1v4.asm):01269                  JSR      I2C_SendByte                      ; try to send register address
E8DB 2661             (   monitor1v4.asm):01270                  BNE      I_ERR                             ; error, return with status!
E8DD 1FE8             (   monitor1v4.asm):01271                  TFR      E,A                               ; slave address back into A
E8DF 8A01             (   monitor1v4.asm):01272                  ORA      #$01                              ; send START and slave address (READ)
E8E1 BDE8A5           (   monitor1v4.asm):01273                  JSR      I2C_GoMaster                      ; try to send slave address
E8E4 2658             (   monitor1v4.asm):01274                  BNE      I_ERR                             ; error, return with status!
E8E6 8600             (   monitor1v4.asm):01275                  LDA      #I2C_NOTACKNOWLEDGE               ; only one byte, so NAK it
E8E8 BDE861           (   monitor1v4.asm):01276                  JSR      I2C_RcvByte                       ; read the data byte
E8EB 1F89             (   monitor1v4.asm):01277                  TFR      A,B                               ; copy byte value to B
E8ED 2047             (   monitor1v4.asm):01278                  BRA      I_OK
                      (   monitor1v4.asm):01279         
                      (   monitor1v4.asm):01280         ;;
                      (   monitor1v4.asm):01281         ;; RTC_ClearStatus - clear STATUS:OSF,BSY,A1F,A2F bits in the DS3232M RTC
                      (   monitor1v4.asm):01282         ;;
                      (   monitor1v4.asm):01283         ;; RTC_WriteByte - write a single byte to the DS3232M RTC
                      (   monitor1v4.asm):01284         ;; inputs: B = register address
                      (   monitor1v4.asm):01285         ;;
                      (   monitor1v4.asm):01286         ;; I2C_WriteByte - write one byte of data to a specific address
                      (   monitor1v4.asm):01287         ;; inputs: E = slave address
                      (   monitor1v4.asm):01288         ;;         B = register address
                      (   monitor1v4.asm):01289         ;;                 A = data to write
                      (   monitor1v4.asm):01290         ;; return: A = I2C.Success(0) or I2C_NoSlaveAck(1) or I2C.BusError(2)
                      (   monitor1v4.asm):01291         ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (   monitor1v4.asm):01292         ;;
                      (   monitor1v4.asm):01293         ;; WRITE REG == [START], ADDR, [ack], <REG ADDR>, [ack], <WRITE DATA>, [ack], [STOP]
                      (   monitor1v4.asm):01294         ;;
E8EF                  (   monitor1v4.asm):01295         RTC_ClearStatus:
E8EF 4F               (   monitor1v4.asm):01296                  CLRA                                       ; clear OSF, 32KHz, BSY, A1F, A2F
E8F0 C60F             (   monitor1v4.asm):01297                  LDB      #RTC.STATUS                       ; RTC status addr into B      
E8F2                  (   monitor1v4.asm):01298         RTC_WriteByte:
E8F2 1186D0           (   monitor1v4.asm):01299                  LDE      #RTC.ADDRESS                      ; RTC address into E
E8F5                  (   monitor1v4.asm):01300         I2C_WriteByte:
E8F5 1E8E             (   monitor1v4.asm):01301                  EXG      A,E                               ; slave address in A, data in E
E8F7 84FE             (   monitor1v4.asm):01302                  ANDA     #$FE                              ; send START and slave address (WRITE)
E8F9 8DAA             (   monitor1v4.asm):01303                  BSR      I2C_GoMaster                      ; try to send slave address
E8FB 2641             (   monitor1v4.asm):01304                  BNE      I_ERR                             ; error, return with status!
E8FD 1F98             (   monitor1v4.asm):01305                  TFR      B,A                               ; copy register address into A
E8FF BDE82D           (   monitor1v4.asm):01306                  JSR      I2C_SendByte                      ; try to send register address
E902 263A             (   monitor1v4.asm):01307                  BNE      I_ERR                             ; error, return with status!
E904 1FE8             (   monitor1v4.asm):01308                  TFR      E,A                               ; copy data byte to be written into A
E906 BDE82D           (   monitor1v4.asm):01309                  JSR      I2C_SendByte                      ; try to send data byte
E909 2633             (   monitor1v4.asm):01310                  BNE      I_ERR                             ; error, return with status!
E90B 2729             (   monitor1v4.asm):01311                  BEQ      I_OK                              ; send stop and return with success
                      (   monitor1v4.asm):01312         
                      (   monitor1v4.asm):01313         ;;
                      (   monitor1v4.asm):01314         ;; RTC_WriteRegs - write registers 0-15 to the DS3232M RTC
                      (   monitor1v4.asm):01315         ;; inputs: Y = addr of write data buffer
                      (   monitor1v4.asm):01316         ;;
                      (   monitor1v4.asm):01317         ;; I2C_WriteBlock - writes one or more bytes of data to a specific address
                      (   monitor1v4.asm):01318         ;; inputs: E = slave address
                      (   monitor1v4.asm):01319         ;;         B = register address
                      (   monitor1v4.asm):01320         ;;         Y = addr of write data buffer
                      (   monitor1v4.asm):01321         ;;         X = number of bytes to write
                      (   monitor1v4.asm):01322         ;; return: A = I2C.Success(0) or I2C_NoSlaveAck(1) or I2C.BusError(2)
                      (   monitor1v4.asm):01323         ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (   monitor1v4.asm):01324         ;;         Y is preserved
                      (   monitor1v4.asm):01325         ;;         X is destroyed
                      (   monitor1v4.asm):01326         ;;
                      (   monitor1v4.asm):01327         ;; WRITE MANY == [START], ADDR, [ack], <REG ADDR>, [ack], <WRITE DATA>, [ack], <WRITE DATA>, [ack], ... [STOP]
                      (   monitor1v4.asm):01328         ;;
E90D                  (   monitor1v4.asm):01329         RTC_WriteRegs:
E90D 5F               (   monitor1v4.asm):01330                  CLRB                                       ; start at Reg 0
E90E 8E000F           (   monitor1v4.asm):01331                  LDX      #15                               ; end at Reg 15
E911                  (   monitor1v4.asm):01332         RTC_WriteBlock:         
E911 1186D0           (   monitor1v4.asm):01333                  LDE      #RTC.ADDRESS                      ; RTC address into E                  
E914                  (   monitor1v4.asm):01334         I2C_WriteBlock:
E914 3420             (   monitor1v4.asm):01335                  PSHS     Y                                 ; preserve write buffer address
E916 1FE8             (   monitor1v4.asm):01336                  TFR      E,A                               ; slave address in A
E918 84FE             (   monitor1v4.asm):01337                  ANDA     #$FE                              ; send START and slave address (WRITE)
E91A 8D89             (   monitor1v4.asm):01338                  BSR      I2C_GoMaster                      ; try to send slave address
E91C 261E             (   monitor1v4.asm):01339                  BNE      I_ERRX                            ; error, return with status!
E91E 1F98             (   monitor1v4.asm):01340                  TFR      B,A                               ; copy register address into A
E920 BDE82D           (   monitor1v4.asm):01341                  JSR      I2C_SendByte                      ; try to send register address
E923 2617             (   monitor1v4.asm):01342                  BNE      I_ERRX                            ; error, return with status!
E925 3000             (   monitor1v4.asm):01343         WM0?     LEAX     0,X                               ; test the byte counter
E927 270B             (   monitor1v4.asm):01344                  BEQ      I_OKX                             ; all done, send a STOP
E929 A6A0             (   monitor1v4.asm):01345         WM1?     LDA      ,Y+                               ; copy byte from write buffer to A
E92B BDE82D           (   monitor1v4.asm):01346                  JSR      I2C_SendByte                      ; try to send data byte
E92E 260C             (   monitor1v4.asm):01347                  BNE      I_ERRX                            ; error, return with status!
E930 301F             (   monitor1v4.asm):01348                  LEAX     -1,X                              ; decrement the byte counter
E932 26F5             (   monitor1v4.asm):01349                  BNE      WM1?                              ; repeat until finished
E934 3520             (   monitor1v4.asm):01350         I_OKX    PULS     Y                                 ; restore buffer start address
E936 BDE852           (   monitor1v4.asm):01351         I_OK     JSR      I2C_SendStop                      ; send a STOP condition
E939 8600             (   monitor1v4.asm):01352                  LDA      #I2C_Success                      ; send a fSuccess code (0) and set Z = 1
E93B 39               (   monitor1v4.asm):01353                  RTS
E93C 3520             (   monitor1v4.asm):01354         I_ERRX   PULS     Y                                 ; restore buffer start address
E93E BDE852           (   monitor1v4.asm):01355         I_ERR    JSR      I2C_SendStop                      ; send a STOP condition
E941 8601             (   monitor1v4.asm):01356                  LDA      #I2C_NoSlaveAck                   ; send a fNoSlaveAck code (1) and set Z = 0
E943 39               (   monitor1v4.asm):01357                  RTS
                      (   monitor1v4.asm):01358         
                      (   monitor1v4.asm):01359         ;;
                      (   monitor1v4.asm):01360         ;; RTC_ReadRegs - read registers 0-15 from the DS3232M RTC
                      (   monitor1v4.asm):01361         ;; inputs: Y = addr of read data buffer
                      (   monitor1v4.asm):01362         ;;
                      (   monitor1v4.asm):01363         ;; I2C_ReadBlock - read one or more bytes of data from a specific (8 bit) address
                      (   monitor1v4.asm):01364         ;; inputs: E = slave address
                      (   monitor1v4.asm):01365         ;;         B = register address
                      (   monitor1v4.asm):01366         ;;         Y = addr of read data buffer
                      (   monitor1v4.asm):01367         ;;         X = number of bytes to read
                      (   monitor1v4.asm):01368         ;; return: A = I2C.Success(0) or I2C_NoSlaveAck(1) or I2C.BusError(2)
                      (   monitor1v4.asm):01369         ;;         B = value of last read data byte
                      (   monitor1v4.asm):01370         ;;         Z = 1 when I2C.Success, otherwise Z = 0
                      (   monitor1v4.asm):01371         ;;         Y is preserved
                      (   monitor1v4.asm):01372         ;;         X is destroyed
                      (   monitor1v4.asm):01373         ;;
                      (   monitor1v4.asm):01374         ;; READ MANY == [START], ADDR, [ack], <REG ADDR>, [ack], [START], ADDR, [ack], <read data>, [ACK], <read data>, [ACK], ... [STOP]
                      (   monitor1v4.asm):01375         ;;
E944                  (   monitor1v4.asm):01376         RTC_ReadRegs:
E944 5F               (   monitor1v4.asm):01377                  CLRB                                       ; start at Reg 0
E945 8E000F           (   monitor1v4.asm):01378                  LDX      #15                               ; end at Reg 15
E948                  (   monitor1v4.asm):01379         RTC_ReadBlock:         
E948 1186D0           (   monitor1v4.asm):01380                  LDE      #RTC.ADDRESS                      ; RTC address into E                  
E94B                  (   monitor1v4.asm):01381         I2C_ReadBlock:
E94B 3420             (   monitor1v4.asm):01382                  PSHS     Y                                 ; preserve buffer start address
E94D 1FE8             (   monitor1v4.asm):01383                  TFR      E,A                               ; slave address in A
E94F 84FE             (   monitor1v4.asm):01384                  ANDA     #$FE                              ; send START and slave address (WRITE)
E951 BDE8A5           (   monitor1v4.asm):01385                  JSR      I2C_GoMaster                      ; try to send slave address
E954 26E6             (   monitor1v4.asm):01386                  BNE      I_ERRX                            ; error, return with status!
E956 1F98             (   monitor1v4.asm):01387                  TFR      B,A                               ; register address into A
E958 BDE82D           (   monitor1v4.asm):01388                  JSR      I2C_SendByte                      ; try to send register address
E95B 26DF             (   monitor1v4.asm):01389                  BNE      I_ERRX                            ; error, return with status!
E95D 1FE8             (   monitor1v4.asm):01390                  TFR      E,A                               ; slave address back into A
E95F 8A01             (   monitor1v4.asm):01391                  ORA      #$01                              ; send START and slave address (READ)
E961 BDE8A5           (   monitor1v4.asm):01392                  JSR      I2C_GoMaster                      ; try to send slave address
E964 26D6             (   monitor1v4.asm):01393                  BNE      I_ERRX                            ; error, return with status!
E966 3000             (   monitor1v4.asm):01394         RM0?     LEAX     0,X                               ; test the byte counter
E968 27CA             (   monitor1v4.asm):01395                  BEQ      I_OKX                             ; all done, send a STOP
E96A 8601             (   monitor1v4.asm):01396         RM1?     LDA      #I2C_ACKNOWLEDGE                  ; assume ACK (1)
E96C 301F             (   monitor1v4.asm):01397                  LEAX     -1,X                              ; decrement the byte counter
E96E 2601             (   monitor1v4.asm):01398                  BNE      RM2?                              ; not the last byte to read
E970 4F               (   monitor1v4.asm):01399                  CLRA                                       ; yes, last byte, respond with NAK (0)
E971 BDE861           (   monitor1v4.asm):01400         RM2?     JSR      I2C_RcvByte                       ; read the data byte
E974 A7A0             (   monitor1v4.asm):01401                  STA      ,Y+                               ; store in buffer
E976 1F89             (   monitor1v4.asm):01402                  TFR      A,B                               ; copy read byte to B
E978 20EC             (   monitor1v4.asm):01403                  BRA      RM0?                              ; repeat until finished         
                      (   monitor1v4.asm):01404                  
                      (   monitor1v4.asm):01405         ;;======================================================================
                      (   monitor1v4.asm):01406         ;; PLATFORM DEPENDENT DS3232M I2C REALTIME CLOCK FUNCTIONS
                      (   monitor1v4.asm):01407         ;;======================================================================
                      (   monitor1v4.asm):01408         ;;
                      (   monitor1v4.asm):01409         ;; RTC_FmtDate - format the date from DS3232 RTC in MM/DD/YYYY format
                      (   monitor1v4.asm):01410         ;; inputs:  Y = pointer to 16 bytes of scratch RAM
                      (   monitor1v4.asm):01411         ;; output:  A = RTC status register value
                      (   monitor1v4.asm):01412         ;;          V = 1 if I2C bus error or RTC communication error
                      (   monitor1v4.asm):01413         ;;          V = 0 if successful read
                      (   monitor1v4.asm):01414         ;;          null terminated ASCII string structure
                      (   monitor1v4.asm):01415         ;;                                1 1
                      (   monitor1v4.asm):01416         ;;        X + 0 1 2 3 4 5 6 7 8 9 0 1
                      (   monitor1v4.asm):01417         ;;            M M / D D / C C Y Y * 0
                      (   monitor1v4.asm):01418         ;;          * at position 11 is only if OSF detected, otherwise NULL
                      (   monitor1v4.asm):01419         ;;
E97A                  (   monitor1v4.asm):01420         RTC_FmtDate:
E97A BDE822           (   monitor1v4.asm):01421                  JSR      I2C_Initialize                    ; try to initialize the I2C
E97D 2936             (   monitor1v4.asm):01422                  BVS      R?NORTC                           ; SDA stuck low, abort
E97F BDE944           (   monitor1v4.asm):01423                  JSR      RTC_ReadRegs                      ; read RTC registers 0-15
E982 2631             (   monitor1v4.asm):01424                  BNE      R?NORTC                           ; error return from read, abort
E984 A626             (   monitor1v4.asm):01425                  LDA      RTC.YEAR,Y                        ; get the year (6)
E986 8D30             (   monitor1v4.asm):01426                  BSR      FMTBCD                            ; convert year to ASCII
E988 ED28             (   monitor1v4.asm):01427                  STD      8,Y                               ; store in buffer (8,9)
E98A 8620             (   monitor1v4.asm):01428                  LDA      #$20                              ; Assume 21st century
E98C E625             (   monitor1v4.asm):01429                  LDB      RTC.MONTH,Y                       ; get the month/century (5)         
E98E 58               (   monitor1v4.asm):01430                  ASLB                                       ; shift CENTURY bit into C
E98F 8900             (   monitor1v4.asm):01431                  ADCA     #0                                ; add CENTURY bit to $20 (= $20 or $21)
E991 8D25             (   monitor1v4.asm):01432         R?DCEN   BSR      FMTBCD                            ; convert century to ASCII
E993 ED26             (   monitor1v4.asm):01433                  STD      6,Y                               ; store in buffer (6,7)
E995 A625             (   monitor1v4.asm):01434                  LDA      RTC.MONTH,Y                       ; get the month/century (5)
E997 C41F             (   monitor1v4.asm):01435                  ANDB     #$1F                              ; strip off the century info
E999 8D1D             (   monitor1v4.asm):01436                  BSR      FMTBCD                            ; convert BCD to ASCII
E99B EDA4             (   monitor1v4.asm):01437                  STD      ,Y                                ; store in buffer (0,1)
E99D A624             (   monitor1v4.asm):01438                  LDA      RTC.DAY,Y                         ; get the day of month (4)
E99F 8D17             (   monitor1v4.asm):01439                  BSR      FMTBCD                            ; convert BCD to ASCII
E9A1 ED23             (   monitor1v4.asm):01440                  STD      3,Y                               ; store in buffer (3,4)
E9A3 862F             (   monitor1v4.asm):01441                  LDA      #'/'                              ; separator character
E9A5 A722             (   monitor1v4.asm):01442                  STA      2,Y                               ; month/date
E9A7 A725             (   monitor1v4.asm):01443                  STA      5,Y                               ; date/year
E9A9 104F             (   monitor1v4.asm):01444                  CLRD
E9AB ED2A             (   monitor1v4.asm):01445                  STD      10,Y                              ; null terminate the string (even with *) (10,11)
E9AD A62F             (   monitor1v4.asm):01446                  LDA      RTC.STATUS,Y                      ; get status register
E9AF 2A03             (   monitor1v4.asm):01447                  BPL      R?NOOSF                           ; OSF in b7, if clear no OSF events occurred
E9B1 612A2A           (   monitor1v4.asm):01448                  OIM      #'*',10,Y                         ; put OSF event indicator after date
E9B4 39               (   monitor1v4.asm):01449         R?NOOSF  RTS                                        ; return with overflow clear
E9B5 1A02             (   monitor1v4.asm):01450         R?NORTC  ORCC     #CC_V                             ; set the overflow flag for RTC read error
E9B7 39               (   monitor1v4.asm):01451                  RTS
                      (   monitor1v4.asm):01452                  
                      (   monitor1v4.asm):01453         ;;
                      (   monitor1v4.asm):01454         ;; FMTBCD - convert a BCD value in A to ASCII characters in D
                      (   monitor1v4.asm):01455         ;; inputs: A = BCD input value
                      (   monitor1v4.asm):01456         ;; output: D = ASCII character pairs (MSD in A, LSD in B)
                      (   monitor1v4.asm):01457         ;;
E9B8                  (   monitor1v4.asm):01458         FMTBCD:
E9B8 1F89             (   monitor1v4.asm):01459                  TFR      A,B                               ; copy A to B
E9BA 44               (   monitor1v4.asm):01460                  LSRA                                       ; move MSD down to lower nybble
E9BB 44               (   monitor1v4.asm):01461                  LSRA
E9BC 44               (   monitor1v4.asm):01462                  LSRA
E9BD 44               (   monitor1v4.asm):01463                  LSRA
E9BE C40F             (   monitor1v4.asm):01464                  ANDB     #$0F                              ; clear upper bits in LSD         
E9C0 108A3030         (   monitor1v4.asm):01465                  ORD      #$3030                            ; convert to ASCII 00-99
E9C4 39               (   monitor1v4.asm):01466                  RTS
                      (   monitor1v4.asm):01467                  
                      (   monitor1v4.asm):01468         ;;
                      (   monitor1v4.asm):01469         ;; RTC_FmtTime - format the time from DS3232 RTC in HH:MM:SS format
                      (   monitor1v4.asm):01470         ;; inputs:  Y = pointer to 16 bytes of scratch RAM
                      (   monitor1v4.asm):01471         ;; output:  A = RTC status register value
                      (   monitor1v4.asm):01472         ;;          V = 1 if I2C bus error or RTC communication error
                      (   monitor1v4.asm):01473         ;;          V = 0 if successful read
                      (   monitor1v4.asm):01474         ;;          null terminated ASCII string structure
                      (   monitor1v4.asm):01475         ;;        X + 0 1 2 3 4 5 6 7 8 9
                      (   monitor1v4.asm):01476         ;;            H H : M M : S S * 0
                      (   monitor1v4.asm):01477         ;;          * at position 11 is only if OSF detected, otherwise NULL
                      (   monitor1v4.asm):01478         ;;
E9C5                  (   monitor1v4.asm):01479         RTC_FmtTime:
E9C5 BDE822           (   monitor1v4.asm):01480                  JSR      I2C_Initialize                    ; try to initialize the I2C
E9C8 293A             (   monitor1v4.asm):01481                  BVS      R?NORTC                           ; SDA stuck low, abort
E9CA BDE944           (   monitor1v4.asm):01482                  JSR      RTC_ReadRegs                      ; read RTC registers 0-15
E9CD 2635             (   monitor1v4.asm):01483                  BNE      R?NORTC                           ; error return from read, abort
E9CF A6A4             (   monitor1v4.asm):01484                  LDA      RTC.SECONDS,Y                     ; get the seconds (0)
E9D1 8DE5             (   monitor1v4.asm):01485                  BSR      FMTBCD                            ; convert seconds to ASCII
E9D3 ED26             (   monitor1v4.asm):01486                  STD      6,Y                               ; store in buffer (6,7)
E9D5 A621             (   monitor1v4.asm):01487                  LDA      RTC.MINUTES,Y                     ; get the minutes (1)
E9D7 8DDF             (   monitor1v4.asm):01488                  BSR      FMTBCD                            ; convert BCD to ASCII
E9D9 ED23             (   monitor1v4.asm):01489                  STD      3,Y                               ; store in buffer (3,4)
E9DB A622             (   monitor1v4.asm):01490                  LDA      RTC.HOURS,Y                       ; get the hours (2)
E9DD 1F89             (   monitor1v4.asm):01491                  TFR      A,B                               ; copy hours to B (for LSD)
E9DF 8540             (   monitor1v4.asm):01492                  BITA     #$40                              ; test the 12/24 bit (1 = 12, 0 = 24)
E9E1 2709             (   monitor1v4.asm):01493                  BEQ      R?T24                             ;  24HR time already
E9E3 8520             (   monitor1v4.asm):01494                  BITA     #$20                              ; is it AM or PM (0 = AM, 1 = PM)
E9E5 2705             (   monitor1v4.asm):01495                  BEQ      R?T24                             ;   AM, so leave it alone
E9E7 841F             (   monitor1v4.asm):01496                  ANDA     #$1F                              ; start with BCD 12H time
E9E9 8B12             (   monitor1v4.asm):01497                  ADDA     #$12                              ; add BCD 12 hours
E9EB 19               (   monitor1v4.asm):01498                  DAA                                        ; adjust decimal result
E9EC 843F             (   monitor1v4.asm):01499         R?T24    ANDA     #$3F                              ; retain only the 24 hour time
E9EE 8DC8             (   monitor1v4.asm):01500                  BSR      FMTBCD                            ; convert BCD to ASCII
E9F0 ED20             (   monitor1v4.asm):01501                  STD      0,Y                               ; store in buffer (0,1)
E9F2 863A             (   monitor1v4.asm):01502                  LDA      #':'                              ; separator character
E9F4 A722             (   monitor1v4.asm):01503                  STA      2,Y                               ; month/date
E9F6 A725             (   monitor1v4.asm):01504                  STA      5,Y                               ; date/year
E9F8 104F             (   monitor1v4.asm):01505                  CLRD
E9FA ED28             (   monitor1v4.asm):01506                  STD      8,Y                               ; null terminate the string (even with *) (8,9)
E9FC A62F             (   monitor1v4.asm):01507                  LDA      RTC.STATUS,Y                      ; get status register
E9FE 2A03             (   monitor1v4.asm):01508                  BPL      R?NOOSF                           ; OSF in b7, if clear no OSF events occurred
EA00 612A28           (   monitor1v4.asm):01509                  OIM      #'*',8,Y                          ; put OSF event indicator after time
EA03 39               (   monitor1v4.asm):01510         R?NOOSF  RTS                                        ; return with overflow clear
EA04 1A02             (   monitor1v4.asm):01511         R?NORTC  ORCC     #CC_V                             ; set the overflow flag for RTC read error
EA06 39               (   monitor1v4.asm):01512                  RTS
                      (   monitor1v4.asm):01513                  
                      (   monitor1v4.asm):01514         ;;
                      (   monitor1v4.asm):01515         ;; RTC_NMIEnable - enable the RTC NMI output, set source to 1Hz
                      (   monitor1v4.asm):01516         ;; inputs:  none
                      (   monitor1v4.asm):01517         ;; output:  V = 1 if I2C bus error or RTC communication error
                      (   monitor1v4.asm):01518         ;;          V = 0 if successful read
                      (   monitor1v4.asm):01519         ;;
EA07                  (   monitor1v4.asm):01520         RTC_NMIEnable:
EA07 BDE822           (   monitor1v4.asm):01521                  JSR      I2C_Initialize                    ; try to initialize the I2C
EA0A 2912             (   monitor1v4.asm):01522                  BVS      R?NORTC                           ; SDA stuck low, abort
EA0C 108EEA34         (   monitor1v4.asm):01523                  LDY      #RTCISR                           ; address of simple NMI service routine
EA10 10BFBF8F         (   monitor1v4.asm):01524                  STY      RV_NMI                            ; assign to NMI vector
EA14 C60E             (   monitor1v4.asm):01525                  LDB      #RTC.CONTROL                      ; write register 14 (CONTROL)
EA16 4F               (   monitor1v4.asm):01526                  CLRA                                       ; data to write is 0
                      (   monitor1v4.asm):01527                                                             ;   ENOSC=0, INTCN=0, A1E & A2E=0
                      (   monitor1v4.asm):01528                                                             ;   This enables 1HZ SQ wave on INT pin
EA17 BDE8F2           (   monitor1v4.asm):01529                  JSR      RTC_WriteByte                     ; write the CONTROL register
EA1A 2702             (   monitor1v4.asm):01530                  BEQ      R?NORTC                           ; error return from read, abort
EA1C 4D               (   monitor1v4.asm):01531                  TSTA                                       ; clear the overflow flag
EA1D 39               (   monitor1v4.asm):01532         R?NOOSF  RTS                                        ; return with overflow clear
EA1E 1A02             (   monitor1v4.asm):01533         R?NORTC  ORCC     #CC_V                             ; set the overflow flag for RTC read error
EA20 39               (   monitor1v4.asm):01534                  RTS
                      (   monitor1v4.asm):01535                  
                      (   monitor1v4.asm):01536         ;;
                      (   monitor1v4.asm):01537         ;; RTC_NMIDisable - disable the RTC NMI output
                      (   monitor1v4.asm):01538         ;; inputs:  none
                      (   monitor1v4.asm):01539         ;; output:  V = 1 if I2C bus error or RTC communication error
                      (   monitor1v4.asm):01540         ;;          V = 0 if successful read
                      (   monitor1v4.asm):01541         ;;
EA21                  (   monitor1v4.asm):01542         RTC_NMIDisable:
EA21 BDE822           (   monitor1v4.asm):01543                  JSR      I2C_Initialize                    ; try to initialize the I2C
EA24 290B             (   monitor1v4.asm):01544                  BVS      R?NORTC                           ; SDA stuck low, abort
EA26 C60E             (   monitor1v4.asm):01545                  LDB      #RTC.CONTROL                      ; write register 14 (CONTROL)
EA28 8604             (   monitor1v4.asm):01546                  LDA      #4                                ; data to write is 4
                      (   monitor1v4.asm):01547                                                             ;   ENOSC=0, INTCN=1, A1E & A2E=0
                      (   monitor1v4.asm):01548                                                             ;   This disables 1HZ, A1, and A2 ints
EA2A BDE8F2           (   monitor1v4.asm):01549                  JSR      RTC_WriteByte                     ; write the CONTROL register
EA2D 2702             (   monitor1v4.asm):01550                  BEQ      R?NORTC                           ; error return from read, abort
EA2F 4D               (   monitor1v4.asm):01551                  TSTA                                       ; clear the overflow flag
EA30 39               (   monitor1v4.asm):01552         R?NOOSF  RTS                                        ; return with overflow clear
EA31 1A02             (   monitor1v4.asm):01553         R?NORTC  ORCC     #CC_V                             ; set the overflow flag for RTC read error
EA33 39               (   monitor1v4.asm):01554                  RTS
                      (   monitor1v4.asm):01555         ;
                      (   monitor1v4.asm):01556         ; LED blinking NMI/IRQ service routine
                      (   monitor1v4.asm):01557         ;
EA34                  (   monitor1v4.asm):01558         RTCISR:
EA34 7502E050         (   monitor1v4.asm):01559                  EIM      #%00000010,IOPORT                 ; toggle IOPORT bit 1 (LED #2)
EA38 3B               (   monitor1v4.asm):01560                  RTI
                      (   monitor1v4.asm):01561         
                      (   monitor1v4.asm):01562         ;;======================================================================
                      (   monitor1v4.asm):01563         ;; PLATFORM DEPENDENT SPI MASTER FUNCTIONS - LOW LEVEL
                      (   monitor1v4.asm):01564         ;;======================================================================
                      (   monitor1v4.asm):01565         ;; CPOL=0 the base value of the clock is zero
                      (   monitor1v4.asm):01566         ;; CPHA=0, data is propagated on a falling edge (high->low clock transition)
                      (   monitor1v4.asm):01567         ;;
                      (   monitor1v4.asm):01568         ;; SPI_Write - write a byte via HW SPI master
                      (   monitor1v4.asm):01569         ;; inputs: A = byte to send
                      (   monitor1v4.asm):01570         ;; return: A is preserved
                      (   monitor1v4.asm):01571         ;;
EA39                  (   monitor1v4.asm):01572         SPI_Write:
                      (   monitor1v4.asm):01573                  SPI_Status                                 ; make sure SPI is ready
EA39 7B40E050         (       SPI_Status):00001                  TIM      #IO.SDBSY,IOPORT                  ; check the SPI busy bit (Z=0 means busy)
EA3D 26FA             (   monitor1v4.asm):01574                  BNE      SPI_Write
EA3F B7E030           (   monitor1v4.asm):01575                  STA      SDPORT                            ; send A via SPI
EA42                  (   monitor1v4.asm):01576         RW?0     SPI_Status                                 ; wait for transaction to end
EA42 7B40E050         (       SPI_Status):00001                  TIM      #IO.SDBSY,IOPORT                  ; check the SPI busy bit (Z=0 means busy)
EA46 26FA             (   monitor1v4.asm):01577                  BNE      RW?0
EA48 39               (   monitor1v4.asm):01578                  RTS
                      (   monitor1v4.asm):01579         
                      (   monitor1v4.asm):01580         ;;
                      (   monitor1v4.asm):01581         ;; SPI_Read - read a byte via HW SPI master (send $FF)
                      (   monitor1v4.asm):01582         ;; inputs: none
                      (   monitor1v4.asm):01583         ;; return: A = byte received
                      (   monitor1v4.asm):01584         ;;
EA49                  (   monitor1v4.asm):01585         SPI_Read:
EA49 4F               (   monitor1v4.asm):01586                  CLRA
EA4A 43               (   monitor1v4.asm):01587                  COMA                                       ; load dummy byte value
                      (   monitor1v4.asm):01588         ; fall into SPI_Xcg...
                      (   monitor1v4.asm):01589         
                      (   monitor1v4.asm):01590         ;;
                      (   monitor1v4.asm):01591         ;; SPI_Xcg - write/read (exchange) a byte via HW SPI master
                      (   monitor1v4.asm):01592         ;; inputs: A = byte to send
                      (   monitor1v4.asm):01593         ;; return: A = byte received
                      (   monitor1v4.asm):01594         ;;
EA4B                  (   monitor1v4.asm):01595         SPI_Xcg:
EA4B 8DEC             (   monitor1v4.asm):01596                  BSR      SPI_Write                         ; send the byte in A
EA4D B6E030           (   monitor1v4.asm):01597                  LDA      SDPORT                            ; load received byte into A
EA50 39               (   monitor1v4.asm):01598                  RTS
                      (   monitor1v4.asm):01599         
                      (   monitor1v4.asm):01600         ;;
                      (   monitor1v4.asm):01601         ;; SPI_ReadBlock - read multiple bytes via SPI master
                      (   monitor1v4.asm):01602         ;; inputs: Y = addr of destination block
                      (   monitor1v4.asm):01603         ;;         X = number of bytes to read
                      (   monitor1v4.asm):01604         ;; return: X = 0
                      (   monitor1v4.asm):01605         ;;
EA51                  (   monitor1v4.asm):01606         SPI_ReadBlock:
EA51 3420             (   monitor1v4.asm):01607                  PSHS     Y                                 ; preserve Y
EA53 3000             (   monitor1v4.asm):01608                  LEAX     0,X                               ; test X for 0 before reading anything!
EA55 2708             (   monitor1v4.asm):01609                  BEQ      R?MX                              ;    entered with X=0, so exit
EA57 8DF0             (   monitor1v4.asm):01610         R?M0     BSR      SPI_Read                          ; send a dummy and read a data byte
EA59 A7A0             (   monitor1v4.asm):01611                  STA      ,Y+                               ; store in buffer
EA5B 301F             (   monitor1v4.asm):01612                  LEAX     -1,X                              ; decrement byte counter
EA5D 26F8             (   monitor1v4.asm):01613                  BNE      R?M0                              ;    not done yet, keep reading
EA5F 35A0             (   monitor1v4.asm):01614         R?MX     PULS     Y,PC                              ; restore Y and return
                      (   monitor1v4.asm):01615         
                      (   monitor1v4.asm):01616         ;;
                      (   monitor1v4.asm):01617         ;; SPI_WriteBlock - send multiple bytes via SPI master
                      (   monitor1v4.asm):01618         ;; inputs: Y = pointer to source block
                      (   monitor1v4.asm):01619         ;;         X = number of bytes to write
                      (   monitor1v4.asm):01620         ;; return: X = 0
                      (   monitor1v4.asm):01621         ;;
EA61                  (   monitor1v4.asm):01622         SPI_WriteBlock:
EA61 3422             (   monitor1v4.asm):01623                  PSHS     A,Y                               ; preserve A and Y
EA63 3000             (   monitor1v4.asm):01624                  LEAX     0,X                               ; test X for 0 before writing anything!
EA65 2708             (   monitor1v4.asm):01625                  BEQ      W?MX                              ;    entered with X=0, so exit
EA67 A6A0             (   monitor1v4.asm):01626         W?M0     LDA      ,Y+                               ; get byte to send from source block
EA69 8DCE             (   monitor1v4.asm):01627                  BSR      SPI_Write                         ; send data byte
EA6B 301F             (   monitor1v4.asm):01628                  LEAX     -1,X                              ; decrement byte counter
EA6D 26F8             (   monitor1v4.asm):01629                  BNE      W?M0                              ;    not done yet, keep reading
EA6F 35A2             (   monitor1v4.asm):01630         W?MX     PULS     A,Y,PC                            ; restore A and Y and return
                      (   monitor1v4.asm):01631         
                      (   monitor1v4.asm):01632         ;;======================================================================
                      (   monitor1v4.asm):01633         ;; PLATFORM DEPENDENT SD CARD FUNCTIONS (USING SPI MASTER)
                      (   monitor1v4.asm):01634         ;;======================================================================
                      (   monitor1v4.asm):01635         
                      (   monitor1v4.asm):01636         ; https://electronics.stackexchange.com/questions/77417/what-is-the-correct-command-sequence-for-microsd-card-initialization-in-spi
                      (   monitor1v4.asm):01637         
                      (   monitor1v4.asm):01638         ; Definitions for MMC/SDC command
     0040             (   monitor1v4.asm):01639         SD_CMD0           EQU  ($40+0)                      ; GO_IDLE_STATE
     0048             (   monitor1v4.asm):01640         SD_CMD8           EQU  ($40+8)                      ; SEND_IF_COND
     0050             (   monitor1v4.asm):01641         SD_CMD16          EQU  ($40+16)                     ; SET_BLOCKLEN
     0051             (   monitor1v4.asm):01642         SD_CMD17          EQU  ($40+17)                     ; READ_SINGLE_BLOCK
     0058             (   monitor1v4.asm):01643         SD_CMD24          EQU  ($40+24)                     ; WRITE_BLOCK
     0069             (   monitor1v4.asm):01644         SD_ACMD41         EQU  ($40+41)                     ; SEND_OP_COND (SDC)
     0077             (   monitor1v4.asm):01645         SD_CMD55          EQU  ($40+55)                     ; APP_CMD
     007A             (   monitor1v4.asm):01646         SD_CMD58          EQU  ($40+58)                     ; READ_OCR
     0095             (   monitor1v4.asm):01647         SD_CMD0CRC        EQU  $95
     0087             (   monitor1v4.asm):01648         SD_CMD8CRC        EQU  $87
     0077             (   monitor1v4.asm):01649         SD_CMD41CRC       EQU  $77
     0065             (   monitor1v4.asm):01650         SD_CMD55CRC       EQU  $65
     00FD             (   monitor1v4.asm):01651         SD_CMD58CRC       EQU  $FD
     0001             (   monitor1v4.asm):01652         SD_NOCRC          EQU  $01
                      (   monitor1v4.asm):01653         
                      (   monitor1v4.asm):01654         ; SD CMD0 GO_IDLE_STATE --> R1
EA71 400000000095     (   monitor1v4.asm):01655         SD_XCMD0          FCB  SD_CMD0,$00,$00,$00,$00,SD_CMD0CRC
                      (   monitor1v4.asm):01656         
                      (   monitor1v4.asm):01657         ; SD CMD8 SEND_IF_COND --> R7
EA77 48000001AA87     (   monitor1v4.asm):01658         SD_XCMD8          FCB  SD_CMD8,$00,$00,$01,$AA,SD_CMD8CRC
                      (   monitor1v4.asm):01659         
                      (   monitor1v4.asm):01660         ; SD ACMD41 SEND_OP_COND (SDC)--> R1
EA7D 694000000077     (   monitor1v4.asm):01661         SD_XCMD41         FCB  SD_ACMD41,$40,$00,$00,$00,SD_CMD41CRC
                      (   monitor1v4.asm):01662         
                      (   monitor1v4.asm):01663         ; SD CMD55 APP_CMD --> R1
EA83 770000000065     (   monitor1v4.asm):01664         SD_XCMD55         FCB  SD_CMD55,$00,$00,$00,$00,SD_CMD55CRC
                      (   monitor1v4.asm):01665         
                      (   monitor1v4.asm):01666         ; SD CMD58 READ_OCR --> R7
EA89 7A00000000FD     (   monitor1v4.asm):01667         SD_XCMD58         FCB  SD_CMD58,$00,$00,$00,$00,SD_CMD58CRC
                      (   monitor1v4.asm):01668         
                      (   monitor1v4.asm):01669         ; Definitions of command fields
     0000             (   monitor1v4.asm):01670         SD.CMD            EQU  0                            ; command byte
     0001             (   monitor1v4.asm):01671         SD.A3             EQU  1                            ; A3
     0002             (   monitor1v4.asm):01672         SD.A2             EQU  2                            ; A2
     0003             (   monitor1v4.asm):01673         SD.A1             EQU  3                            ; A1
     0004             (   monitor1v4.asm):01674         SD.A0             EQU  4                            ; A0 offset
     0005             (   monitor1v4.asm):01675         SD.CRC            EQU  5                            ; CRC offset
                      (   monitor1v4.asm):01676         
                      (   monitor1v4.asm):01677         ; Definitions of response fields
     0000             (   monitor1v4.asm):01678         SD.R1             EQU  0                            ; response
     0001             (   monitor1v4.asm):01679         SD.OCR0           EQU  1
     0002             (   monitor1v4.asm):01680         SD.OCR1           EQU  2
     0003             (   monitor1v4.asm):01681         SD.OCR2           EQU  3
     0004             (   monitor1v4.asm):01682         SD.OCR3           EQU  4
                      (   monitor1v4.asm):01683         
                      (   monitor1v4.asm):01684         ; Card type flags (CardType)
     0001             (   monitor1v4.asm):01685         CT_MMC            EQU  $01                          ; MMC ver 3
     0002             (   monitor1v4.asm):01686         CT_SD1            EQU  $02                          ; SD ver 1
     0004             (   monitor1v4.asm):01687         CT_SD2            EQU  $04                          ; SD ver 2
     0008             (   monitor1v4.asm):01688         CT_BLOCK          EQU  $08                          ; Block addressing
                      (   monitor1v4.asm):01689         
                      (   monitor1v4.asm):01690         ;;
                      (   monitor1v4.asm):01691         ;; SD_NativeMode - if card present bring it to NATIVE mode
                      (   monitor1v4.asm):01692         ;; inputs: none
                      (   monitor1v4.asm):01693         ;; return: V=1, no SD CARD present
                      (   monitor1v4.asm):01694         ;;         V=0, SD CARD present and selected
                      (   monitor1v4.asm):01695         ;;
EA8F                  (   monitor1v4.asm):01696         SD_NativeMode:
EA8F 3416             (   monitor1v4.asm):01697                  PSHS     A,B,X                             ; preserve regs
                      (   monitor1v4.asm):01698                  SD_NegateCS                                ; start by negating CS
EA91 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
                      (   monitor1v4.asm):01699                  SD_CardPresent                             ; check for a card
EA95 7B80E050         (   SD_CardPresent):00001                  TIM      #IO.SDSW,IOPORT                   ; examine SD card switch
EA99 1A02             (   monitor1v4.asm):01700                  ORCC     #CC_V                             ; set the V flag (assume failure)
EA9B 2710             (   monitor1v4.asm):01701                  BEQ      S?I0                              ;    if no card, leave CS negated and return
                      (   monitor1v4.asm):01702                  SPI_SlowMode                               ; set SPI to slow mode
EA9D 7120E050         (     SPI_SlowMode):00001                  OIM      #IO.SDCLK,IOPORT                  ; set SPI to slow mode
EAA1 C60A             (   monitor1v4.asm):01703                  LDB      #10                               ; send 80 bits of 1's
EAA3 BDEA49           (   monitor1v4.asm):01704         S?I1     JSR      SPI_Read                          ;  (10 bytes of $FF)
EAA6 5A               (   monitor1v4.asm):01705                  DECB                                       ; decrement counter
EAA7 26FA             (   monitor1v4.asm):01706                  BNE      S?I1                              ; loop until all pulses sent
                      (   monitor1v4.asm):01707                  SPI_FastMode                               ; set SPI to fast mode (clears V)
EAA9 72DFE050         (     SPI_FastMode):00001                  AIM      #~IO.SDCLK,IOPORT                 ; set SPI to fast mode
EAAD 3596             (   monitor1v4.asm):01708         S?I0     PULS     A,B,X,PC                          ; restore regs and return
                      (   monitor1v4.asm):01709         
                      (   monitor1v4.asm):01710         ;;
                      (   monitor1v4.asm):01711         ;; SD_Initialize - attempt to open an SD card for read/write operations
                      (   monitor1v4.asm):01712         ;; inputs:  X=address of 5 byte result buffer
                      (   monitor1v4.asm):01713         ;;          F=output specifier
                      (   monitor1v4.asm):01714         ;;            0, do not display status to console
                      (   monitor1v4.asm):01715         ;;            <128, display short status to console
                      (   monitor1v4.asm):01716         ;;            >127, display verbose status to console
                      (   monitor1v4.asm):01717         ;; return:  V=0, SD CARD present and selected
                      (   monitor1v4.asm):01718         ;;          V=1, no SD CARD present, or error in communication
                      (   monitor1v4.asm):01719         ;;          E=last command attempted
                      (   monitor1v4.asm):01720         ;;             (0 = RESET, $40=CMD0, $48=CMD8, etc...)
                      (   monitor1v4.asm):01721         ;;
EAAF                  (   monitor1v4.asm):01722         SD_Initialize:
EAAF 3446             (   monitor1v4.asm):01723                  PSHS     A,B,U                             ; preserve registers
EAB1 115D             (   monitor1v4.asm):01724                  TSTF                                       ; check output specifier
EAB3 270E             (   monitor1v4.asm):01725                  BEQ      O?C1A                             ; no status output
EAB5 BDE774           (   monitor1v4.asm):01726                  JSR      PUTMSG
EAB8 0D0A             (   monitor1v4.asm):01727                  FCB      CR,LF
EABA 53443A5265736574 (   monitor1v4.asm):01728                  FCN      "SD:Reset"
     00
EAC3 114F             (   monitor1v4.asm):01729         O?C1A    CLRE                                       ; indicate step 0 (reset)
EAC5 8DC8             (   monitor1v4.asm):01730                  BSR      SD_NativeMode                     ; put card into Native mode
EAC7 102900DE         (   monitor1v4.asm):01731                  LBVS     O?SDE                             ;  V=1 means no card, so exit
                      (   monitor1v4.asm):01732         ; attempt repeated CMD0 to put the SD card into IDLE state (R1 = 01)
EACB C60B             (   monitor1v4.asm):01733                  LDB      #11                               ; init attempts counter         
EACD 5A               (   monitor1v4.asm):01734         O?C2     DECB                                       ; decrement attempt counter
EACE 102700D7         (   monitor1v4.asm):01735                  LBEQ     O?SDE                             ;   no more attempts; terminate
EAD2 115D             (   monitor1v4.asm):01736                  TSTF                                       ; check output specifier
EAD4 270D             (   monitor1v4.asm):01737                  BEQ      O?C3A                             ; no status output
EAD6 BDE774           (   monitor1v4.asm):01738                  JSR      PUTMSG
EAD9 0D0A             (   monitor1v4.asm):01739                  FCB      CR,LF
EADB 53443A434D443000 (   monitor1v4.asm):01740                  FCN      "SD:CMD0"
EAE3 CEEA71           (   monitor1v4.asm):01741         O?C3A    LDU      #SD_XCMD0                         ; point to CMD0 string
EAE6 11A6C4           (   monitor1v4.asm):01742                  LDE      ,U                                ; put command byte into E
EAE9 BDEBE3           (   monitor1v4.asm):01743                  JSR      SD_SendCmd                        ; send it
                      (   monitor1v4.asm):01744                  SD_NegateCS                                ; negate CS after command
EAEC 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EAF0 BDEC24           (   monitor1v4.asm):01745                  JSR      SD_DisplayR1                      ; display response if enabled
EAF3 8101             (   monitor1v4.asm):01746         O?C4     CMPA     #1                                ; R1 = 1?
EAF5 1026FFD4         (   monitor1v4.asm):01747                  LBNE     O?C2                              ;   no = retry
                      (   monitor1v4.asm):01748         ; send a CMD8 to query the card for SD V2
EAF9 115D             (   monitor1v4.asm):01749                  TSTF                                       ; check output specifier
EAFB 270D             (   monitor1v4.asm):01750                  BEQ      O?C5                              ; no status output
EAFD BDE774           (   monitor1v4.asm):01751                  JSR      PUTMSG                            ; output status to console
EB00 0D0A             (   monitor1v4.asm):01752                  FCB      CR,LF
EB02 53443A434D443800 (   monitor1v4.asm):01753                  FCN      "SD:CMD8"
EB0A CEEA77           (   monitor1v4.asm):01754         O?C5     LDU      #SD_XCMD8                         ; point to CMD8 string
EB0D 11A6C4           (   monitor1v4.asm):01755                  LDE      ,U                                ; put command byte into E
EB10 BDEBE3           (   monitor1v4.asm):01756                  JSR      SD_SendCmd                        ; send the command, return R1 in A
                      (   monitor1v4.asm):01757                  SD_NegateCS                                ; negate CS after command         
EB13 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EB17 BDEC0B           (   monitor1v4.asm):01758                  JSR      SD_GetR7                          ; get R7 response type (R1 + 32bits of data)
EB1A BDEC3A           (   monitor1v4.asm):01759                  JSR      SD_DisplayR7                      ; display R7 response if enabled (Acc F)
EB1D 102B0088         (   monitor1v4.asm):01760                  LBMI     O?SDE                             ; if R1 is negative, init failed, not SD V2
                      (   monitor1v4.asm):01761         ; IDLE period (send four $FF bytes)
EB21 BDEA49           (   monitor1v4.asm):01762                  JSR      SPI_Read
EB24 BDEA49           (   monitor1v4.asm):01763                  JSR      SPI_Read
EB27 BDEA49           (   monitor1v4.asm):01764                  JSR      SPI_Read
EB2A BDEA49           (   monitor1v4.asm):01765                  JSR      SPI_Read
                      (   monitor1v4.asm):01766         ; attempt repeated ACMD41 to bring card out of IDLE state (can take a while)         
EB2D C60B             (   monitor1v4.asm):01767                  LDB      #11                               ; init attempts counter         
EB2F 5A               (   monitor1v4.asm):01768         O?C7A    DECB                                       ; decrement attempt counter
EB30 2777             (   monitor1v4.asm):01769                  BEQ      O?SDE                             ;   no more attempts; terminate
EB32 115D             (   monitor1v4.asm):01770                  TSTF                                       ; check output specifier
EB34 270E             (   monitor1v4.asm):01771                  BEQ      O?C7B                             ; no status output
EB36 BDE774           (   monitor1v4.asm):01772                  JSR      PUTMSG
EB39 0D0A             (   monitor1v4.asm):01773                  FCB      CR,LF
EB3B 53443A434D443535 (   monitor1v4.asm):01774                  FCN      "SD:CMD55"
     00
EB44 CEEA83           (   monitor1v4.asm):01775         O?C7B    LDU      #SD_XCMD55                        ; point to CMD55 string
EB47 11A6C4           (   monitor1v4.asm):01776                  LDE      ,U                                ; put command byte into E
EB4A BDEBE3           (   monitor1v4.asm):01777                  JSR      SD_SendCmd                        ; send the command, return R1 in A
                      (   monitor1v4.asm):01778                  SD_NegateCS                                ; negate CS after command         
EB4D 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EB51 BDEC24           (   monitor1v4.asm):01779                  JSR      SD_DisplayR1                      ; display response if enabled         
EB54 115D             (   monitor1v4.asm):01780                  TSTF                                       ; check output specifier
EB56 270E             (   monitor1v4.asm):01781                  BEQ      O?C7C                             ; no status output
EB58 BDE774           (   monitor1v4.asm):01782                  JSR      PUTMSG
EB5B 0D0A             (   monitor1v4.asm):01783                  FCB      CR,LF
EB5D 53443A434D443431 (   monitor1v4.asm):01784                  FCN      "SD:CMD41"
     00
EB66 CEEA7D           (   monitor1v4.asm):01785         O?C7C    LDU      #SD_XCMD41                        ; point to CMD41 string
EB69 11A6C4           (   monitor1v4.asm):01786                  LDE      ,U                                ; put command byte into E
EB6C BDEBE3           (   monitor1v4.asm):01787                  JSR      SD_SendCmd                        ; send the command, return R1 in A
                      (   monitor1v4.asm):01788                  SD_NegateCS                                ; negate CS after command         
EB6F 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EB73 BDEC24           (   monitor1v4.asm):01789                  JSR      SD_DisplayR1                      ; display response if enabled                  
EB76 8401             (   monitor1v4.asm):01790                  ANDA     #1                                ; desired R1 lsb is 0
EB78 26B5             (   monitor1v4.asm):01791                  BNE      O?C7A                             ; loop until init is complete
                      (   monitor1v4.asm):01792         ; send CMD58 to and check CCS bit in OCR block addressing is in effect
EB7A 115D             (   monitor1v4.asm):01793                  TSTF                                       ; check output specifier
EB7C 270E             (   monitor1v4.asm):01794                  BEQ      O?C12                             ; no status output
EB7E BDE774           (   monitor1v4.asm):01795                  JSR      PUTMSG
EB81 0D0A             (   monitor1v4.asm):01796                  FCB      CR,LF
EB83 53443A434D443538 (   monitor1v4.asm):01797                  FCN      "SD:CMD58"
     00
EB8C CEEA89           (   monitor1v4.asm):01798         O?C12    LDU      #SD_XCMD58                        ; point to CMD58 string
EB8F 11A6C4           (   monitor1v4.asm):01799                  LDE      ,U                                ; put command byte into E
EB92 BDEBE3           (   monitor1v4.asm):01800                  JSR      SD_SendCmd                        ; send the command
                      (   monitor1v4.asm):01801                  SD_NegateCS                                ; negate CS after command         
EB95 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EB99 BDEC0B           (   monitor1v4.asm):01802                  JSR      SD_GetR7                          ; get R7 response type (R1 + 32bits of data)
EB9C BDEC3A           (   monitor1v4.asm):01803                  JSR      SD_DisplayR7                      ; display response if enabled (Acc F)
EB9F 2B08             (   monitor1v4.asm):01804                  BMI      O?SDE                             ; if R1 is negative, init failed, so terminate
EBA1 A601             (   monitor1v4.asm):01805                  LDA      SD.OCR0,X                         ; examine OCR0 in response
EBA3 84C0             (   monitor1v4.asm):01806                  ANDA     #$C0                              ; mask all but CCS bit (bit 30) and Powerup bit (bit 31)
EBA5 81C0             (   monitor1v4.asm):01807                  CMPA     #$C0                              ; these need to both be set
EBA7 271C             (   monitor1v4.asm):01808                  BEQ      O?CX                              ;    if CCS=1 the SD card uses LBA, which clears V (success)
                      (   monitor1v4.asm):01809         ; SD Card Access ERROR handler
EBA9 115D             (   monitor1v4.asm):01810         O?SDE    TSTF                                       ; check output specifier
EBAB 270D             (   monitor1v4.asm):01811                  BEQ      O?C13                             ; no status output
EBAD BDE774           (   monitor1v4.asm):01812                  JSR      PUTMSG                            ; output FAIL status to console
EBB0 0D0A             (   monitor1v4.asm):01813                  FCB      CR,LF
EBB2 53443A4641494C   (   monitor1v4.asm):01814                  FCC      "SD:FAIL"
EBB9 FF               (   monitor1v4.asm):01815                  FCB      $FF
EBBA                  (   monitor1v4.asm):01816         O?C13    SD_NegateCS                                ; negate SD csel
EBBA 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EBBE BDEA49           (   monitor1v4.asm):01817                  JSR      SPI_Read                          ; flush SD output buffer
EBC1 1A02             (   monitor1v4.asm):01818                  ORCC     #CC_V                             ; set the V flag
EBC3 35C6             (   monitor1v4.asm):01819                  PULS     A,B,U,PC                          ; restore registers and return
EBC5 115D             (   monitor1v4.asm):01820         O?CX     TSTF                                       ; check output specifier
EBC7 2710             (   monitor1v4.asm):01821                  BEQ      O?C14                             ; no status output
EBC9 BDE774           (   monitor1v4.asm):01822                  JSR      PUTMSG                            ; output FAIL status to console
EBCC 0D0A             (   monitor1v4.asm):01823                  FCB      CR,LF
EBCE 53443A5355434345 (   monitor1v4.asm):01824                  FCC      "SD:SUCCESS"
     5353
EBD8 FF               (   monitor1v4.asm):01825                  FCB      $FF
EBD9                  (   monitor1v4.asm):01826         O?C14    SD_NegateCS                                ; negate CS after command             
EBD9 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EBDD BDEA49           (   monitor1v4.asm):01827                  JSR      SPI_Read                          ; flush SD output buffer
EBE0 5F               (   monitor1v4.asm):01828                  CLRB                                       ; clear V flag
EBE1 35C6             (   monitor1v4.asm):01829                  PULS     A,B,U,PC                          ; restore registers and return
                      (   monitor1v4.asm):01830         ;;
                      (   monitor1v4.asm):01831         ;; SD_SendCmd - sends a command to MMC/SD card, get R1 response byte
                      (   monitor1v4.asm):01832         ;;              Negates and flus
                      (   monitor1v4.asm):01833         ;; inputs:  U = address of 6 byte command sequence
                      (   monitor1v4.asm):01834         ;; return:  A is R1 response byte
                      (   monitor1v4.asm):01835         ;;          N & Z reflect A value
                      (   monitor1v4.asm):01836         ;;          CS is left asserted after command is sent
                      (   monitor1v4.asm):01837         ;;
EBE3                  (   monitor1v4.asm):01838         SD_SendCmd:
EBE3 3444             (   monitor1v4.asm):01839                  PSHS     U,B                               ; preserve U and B
                      (   monitor1v4.asm):01840                  SD_NegateCS                                ; de-Select the card
EBE5 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EBE9 BDEA49           (   monitor1v4.asm):01841                  JSR      SPI_Read                          ; send 8 idle clocks
                      (   monitor1v4.asm):01842                  SD_AssertCS                                ; Select the card
EBEC 72EFE050         (      SD_AssertCS):00001                  AIM      #~IO.SDCS,IOPORT                  ; assert SD card select
EBF0 BDEA49           (   monitor1v4.asm):01843                  JSR      SPI_Read                          ; send 8 idle clocks
EBF3 C606             (   monitor1v4.asm):01844                  LDB      #6                                ; init byte counter
EBF5 A6C0             (   monitor1v4.asm):01845         S?SC1    LDA      ,U+                               ; command + addr + crc
EBF7 BDEA39           (   monitor1v4.asm):01846                  JSR      SPI_Write                         ; send the byte
EBFA 5A               (   monitor1v4.asm):01847                  DECB                                       ; decrement byte counter
EBFB 26F8             (   monitor1v4.asm):01848                  BNE      S?SC1                             ;    loop until all 6 bytes sent
EBFD C60A             (   monitor1v4.asm):01849                  LDB      #10                               ; init attempt counter
EBFF BDEA49           (   monitor1v4.asm):01850         S?SC2    JSR      SPI_Read                          ; read the response
EC02 4D               (   monitor1v4.asm):01851                  TSTA                                       ; examine the received byte
EC03 2A03             (   monitor1v4.asm):01852                  BPL      S?SC3                             ;    non-negative, got a response!
EC05 5A               (   monitor1v4.asm):01853                  DECB                                       ; negative, decrement attempt counter
EC06 26F7             (   monitor1v4.asm):01854                  BNE      S?SC2                             ;    keep trying for 10 attempts
EC08 4D               (   monitor1v4.asm):01855         S?SC3    TSTA                                       ; reflect error status in N and Z flags
EC09 35C4             (   monitor1v4.asm):01856                  PULS     U,B,PC                            ; restore registers and return
                      (   monitor1v4.asm):01857         
                      (   monitor1v4.asm):01858         ;;
                      (   monitor1v4.asm):01859         ;; SD_GetR7 - get remainder of R7 type command response
                      (   monitor1v4.asm):01860         ;;            (R1 was already fetched by SD_SendCmd)
                      (   monitor1v4.asm):01861         ;; inputs:  X = address of 5 byte result buffer
                      (   monitor1v4.asm):01862         ;;          A = R1 response (from SD_SendCmd)
                      (   monitor1v4.asm):01863         ;; return:  all registers preserved
                      (   monitor1v4.asm):01864         ;;          N & Z reflect A value
                      (   monitor1v4.asm):01865         ;;
EC0B                  (   monitor1v4.asm):01866         SD_GetR7:
EC0B A784             (   monitor1v4.asm):01867                  STA      SD.R1,X                           ; move R1 to result buffer
EC0D BDEA49           (   monitor1v4.asm):01868                  JSR      SPI_Read                          ; read next byte from card
EC10 A701             (   monitor1v4.asm):01869                  STA      SD.OCR0,X                         ; move OCR0 to result buffer
EC12 BDEA49           (   monitor1v4.asm):01870                  JSR      SPI_Read                          ; read next byte from card
EC15 A702             (   monitor1v4.asm):01871                  STA      SD.OCR1,X                         ; move OCR1 to result buffer
EC17 BDEA49           (   monitor1v4.asm):01872                  JSR      SPI_Read                          ; read next byte from card
EC1A A703             (   monitor1v4.asm):01873                  STA      SD.OCR2,X                         ; move OCR2 to result buffer
EC1C BDEA49           (   monitor1v4.asm):01874                  JSR      SPI_Read                          ; read next byte from card
EC1F A704             (   monitor1v4.asm):01875                  STA      SD.OCR3,X                         ; move OCR3 to result buffer
EC21 A684             (   monitor1v4.asm):01876                  LDA      SD.R1,X                           ; restore R1 to A (and set flags)
EC23 39               (   monitor1v4.asm):01877                  RTS
                      (   monitor1v4.asm):01878         
                      (   monitor1v4.asm):01879         ;;
                      (   monitor1v4.asm):01880         ;; SD_DisplayR1 - display R1 results (per ACC F)
                      (   monitor1v4.asm):01881         ;; inputs:  A = R1 result value
                      (   monitor1v4.asm):01882         ;;          F > 127 display info, otherwise exit
                      (   monitor1v4.asm):01883         ;; return:  A = R1 value
                      (   monitor1v4.asm):01884         ;;          N & Z reflect A value
                      (   monitor1v4.asm):01885         ;;
EC24                  (   monitor1v4.asm):01886         SD_DisplayR1:
EC24 3402             (   monitor1v4.asm):01887                  PSHS     A                                 ; save A (destroyed by PUTBYTE)
EC26 115D             (   monitor1v4.asm):01888                  TSTF                                       ; check output specifier
EC28 2A0D             (   monitor1v4.asm):01889                  BPL      O?P0                              ; if <127, do not display verbose output
EC2A BDE774           (   monitor1v4.asm):01890                  JSR      PUTMSG
EC2D 2E2E2E52313D00   (   monitor1v4.asm):01891                  FCN      "...R1="
EC34 BDE74E           (   monitor1v4.asm):01892                  JSR      PUTBYTE
EC37 A6E0             (   monitor1v4.asm):01893         O?P0     LDA      ,S+                               ; restore A and set flags
EC39 39               (   monitor1v4.asm):01894                  RTS
                      (   monitor1v4.asm):01895         
                      (   monitor1v4.asm):01896         ;;
                      (   monitor1v4.asm):01897         ;; SD_DisplayR7 - display R7 results (per ACC F)
                      (   monitor1v4.asm):01898         ;; inputs:  X = address of result buffer
                      (   monitor1v4.asm):01899         ;;          F > 127 display info, otherwise exit
                      (   monitor1v4.asm):01900         ;; return:  A = R1 value
                      (   monitor1v4.asm):01901         ;;          All other registers preserved
                      (   monitor1v4.asm):01902         ;;          N & Z reflect A value
                      (   monitor1v4.asm):01903         ;;
EC3A                  (   monitor1v4.asm):01904         SD_DisplayR7:
EC3A 115D             (   monitor1v4.asm):01905                  TSTF                                       ; check output specifier
EC3C 2A1C             (   monitor1v4.asm):01906                  BPL      O?P1                              ;  if <127, do not display verbose output
EC3E BDE774           (   monitor1v4.asm):01907                  JSR      PUTMSG
EC41 2E2E2E523D00     (   monitor1v4.asm):01908                  FCN      "...R="
EC47 3414             (   monitor1v4.asm):01909                  PSHS     B,X                               ; preserve B and X
EC49 C605             (   monitor1v4.asm):01910                  LDB      #5                                ; init loop counter
EC4B A680             (   monitor1v4.asm):01911         O?P0     LDA      ,X+                               ; get byte from result buffer
EC4D BDE74E           (   monitor1v4.asm):01912                  JSR      PUTBYTE                           ; output it
EC50 BDE73D           (   monitor1v4.asm):01913                  JSR      PUTSPACE                          ;   and a space
EC53 5A               (   monitor1v4.asm):01914                  DECB
EC54 26F5             (   monitor1v4.asm):01915                  BNE      O?P0                              ; loop until finished
EC56 3514             (   monitor1v4.asm):01916                  PULS     B,X                               ; restore B and X
EC58 A684             (   monitor1v4.asm):01917                  LDA      ,X                                ; restore R1 and flags
EC5A 39               (   monitor1v4.asm):01918         O?P1     RTS
                      (   monitor1v4.asm):01919         
                      (   monitor1v4.asm):01920         ;;
                      (   monitor1v4.asm):01921         ;; SD_ReadBlock - read a block (sector) from SD card
                      (   monitor1v4.asm):01922         ;; inputs:  X = pointer to 6 byte command structure
                      (   monitor1v4.asm):01923         ;;              0,X...3,X = LBA block number to read
                      (   monitor1v4.asm):01924         ;;          Y = pointer to block data buffer (512 bytes)
                      (   monitor1v4.asm):01925         ;; return:  V=1, read error
                      (   monitor1v4.asm):01926         ;;              A != 0 CMD51 failed
                      (   monitor1v4.asm):01927         ;;              A = 0 no read token received
                      (   monitor1v4.asm):01928         ;;          V=0, block data read successfully
                      (   monitor1v4.asm):01929         ;;          D = CRC of data block
                      (   monitor1v4.asm):01930         ;;
EC5B                  (   monitor1v4.asm):01931         SD_ReadBlock:
EC5B 1038             (   monitor1v4.asm):01932                  PSHSW                                      ; preserve E and F
EC5D 3440             (   monitor1v4.asm):01933                  PSHS     U                                 ; preserve U
EC5F 10EC84           (   monitor1v4.asm):01934                  LDQ      ,X                                ; copy LBA block value
EC62 10ED01           (   monitor1v4.asm):01935                  STQ      SD.A3,X                           ; to A3...A0 of command string
EC65 1039             (   monitor1v4.asm):01936                  PULSW                                      ; restore E and F
EC67 6F05             (   monitor1v4.asm):01937                  CLR      SD.CRC,X                          ; clear the CRC byte of string
EC69 8651             (   monitor1v4.asm):01938                  LDA      #SD_CMD17                         ; READ_SINGLE_BLOCK command (17)
EC6B A784             (   monitor1v4.asm):01939                  STA      SD.CMD,X                          ; put it in the command byte
EC6D 1F13             (   monitor1v4.asm):01940                  TFR      X,U                               ; put command buffer address in U
EC6F BDEBE3           (   monitor1v4.asm):01941                  JSR      SD_SendCmd                        ; send the command to SD Card
EC72 3540             (   monitor1v4.asm):01942                  PULS     U                                 ; restore U         
EC74 261E             (   monitor1v4.asm):01943                  BNE      R?DERR                            ;   R1 is negative, terminate!
EC76 BDEA49           (   monitor1v4.asm):01944         R?D1     JSR      SPI_Read                          ; get token value from card
EC79 2A19             (   monitor1v4.asm):01945                  BPL      R?DERR                            ;   positive: error token
EC7B 81FE             (   monitor1v4.asm):01946                  CMPA     #$FE                              ; is it the $FE start token?
EC7D 26F7             (   monitor1v4.asm):01947                  BNE      R?D1                              ;   no, loop until we get one
EC7F 8E0200           (   monitor1v4.asm):01948                  LDX      #512                              ; put transfer count (512) into X
EC82 BDEA51           (   monitor1v4.asm):01949                  JSR      SPI_ReadBlock                     ; transfer 512 bytes to buffer at Y
EC85 BDEA49           (   monitor1v4.asm):01950                  JSR      SPI_Read                          ; read the CRC MSB
EC88 1F89             (   monitor1v4.asm):01951                  TFR      A,B                               ; copy MSB to B
EC8A BDEA49           (   monitor1v4.asm):01952                  JSR      SPI_Read                          ; read the CRC LSB into A (V=0 always)
EC8D 1E89             (   monitor1v4.asm):01953                  EXG      A,B                               ; put MSB in A, LSB in B
                      (   monitor1v4.asm):01954                  SD_NegateCS                                ; negate CS after command                           
EC8F 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EC93 39               (   monitor1v4.asm):01955                  RTS                                        ; return with CRC in D and Z clear
EC94                  (   monitor1v4.asm):01956         R?DERR   SD_NegateCS                                ; negate CS on error return
EC94 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
EC98 1A02             (   monitor1v4.asm):01957                  ORCC     #CC_V                             ; set the V flag
EC9A 39               (   monitor1v4.asm):01958                  RTS                                        ; return with error info in A and V set
                      (   monitor1v4.asm):01959         
                      (   monitor1v4.asm):01960         ;;
                      (   monitor1v4.asm):01961         ;; SD_WriteBlock - write a block (sector) to SD card
                      (   monitor1v4.asm):01962         ;; inputs:  X = pointer to 6 byte command structure
                      (   monitor1v4.asm):01963         ;;              0,X...3,X = LBA block number to read
                      (   monitor1v4.asm):01964         ;;          Y = pointer to block data buffer (512 bytes)
                      (   monitor1v4.asm):01965         ;; return:  V=1, write error
                      (   monitor1v4.asm):01966         ;;          V=0, block data written successfully
                      (   monitor1v4.asm):01967         ;;          A is destroyed
                      (   monitor1v4.asm):01968         ;;
EC9B                  (   monitor1v4.asm):01969         SD_WriteBlock:
EC9B 1038             (   monitor1v4.asm):01970                  PSHSW                                      ; preserve E and F
EC9D 3440             (   monitor1v4.asm):01971                  PSHS     U                                 ; preserve U
EC9F 10EC84           (   monitor1v4.asm):01972                  LDQ      ,X                                ; copy LBA block value
ECA2 10ED01           (   monitor1v4.asm):01973                  STQ      SD.A3,X                           ; to A3...A0 of command string
ECA5 1039             (   monitor1v4.asm):01974                  PULSW                                      ; restore E and F
ECA7 6F05             (   monitor1v4.asm):01975                  CLR      SD.CRC,X                          ; clear the CRC byte of string
ECA9 8658             (   monitor1v4.asm):01976                  LDA      #SD_CMD24                         ; WRITE_SINGLE_BLOCK command (24)
ECAB A784             (   monitor1v4.asm):01977                  STA      SD.CMD,X                          ; put it in the command byte
ECAD 1F13             (   monitor1v4.asm):01978                  TFR      X,U                               ; put command buffer address in U
ECAF BDEBE3           (   monitor1v4.asm):01979                  JSR      SD_SendCmd                        ; send the command to SD Card
ECB2 3540             (   monitor1v4.asm):01980                  PULS     U
ECB4 2627             (   monitor1v4.asm):01981                  BNE      W?ERR                             ;   R1 is negative, terminate!
ECB6 BDEA49           (   monitor1v4.asm):01982                  JSR      SPI_Read                          ; send two $FF bytes
ECB9 BDEA49           (   monitor1v4.asm):01983                  JSR      SPI_Read
ECBC 86FE             (   monitor1v4.asm):01984                  LDA      #$FE                              ; send the $FE start token
ECBE BDEA39           (   monitor1v4.asm):01985                  JSR      SPI_Write
ECC1 8E0200           (   monitor1v4.asm):01986                  LDX      #512                              ; init transfer counter
ECC4 BDEA61           (   monitor1v4.asm):01987                  JSR      SPI_WriteBlock                    ; transfer 512 bytes from buffer at Y
ECC7 BDEA49           (   monitor1v4.asm):01988                  JSR      SPI_Read                          ; write a dummy CRC value to card
ECCA BDEA49           (   monitor1v4.asm):01989                  JSR      SPI_Read
ECCD BDEA49           (   monitor1v4.asm):01990                  JSR      SPI_Read                          ; get data response
ECD0 8D12             (   monitor1v4.asm):01991                  BSR      SD_WaitReady                      ; wait for card to do the write
ECD2 841F             (   monitor1v4.asm):01992                  ANDA     #$1F                              ; mask off unused bits
ECD4 8105             (   monitor1v4.asm):01993                  CMPA     #$05                              ; $15 = data accepted?
ECD6 2605             (   monitor1v4.asm):01994                  BNE      W?ERR                             ;    no, so return with error
                      (   monitor1v4.asm):01995                  SD_NegateCS                                ; negate CS after command                           
ECD8 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
ECDC 39               (   monitor1v4.asm):01996                  RTS
ECDD                  (   monitor1v4.asm):01997         W?ERR    SD_NegateCS                                ; negate CS on error return
ECDD 7110E050         (      SD_NegateCS):00001                  OIM      #IO.SDCS,IOPORT                   ; negate SD card select
ECE1 1A02             (   monitor1v4.asm):01998                  ORCC     #CC_V                             ; set the V flag
ECE3 39               (   monitor1v4.asm):01999                  RTS                                        ; return with error info in A and V set
                      (   monitor1v4.asm):02000         
                      (   monitor1v4.asm):02001         ;;
                      (   monitor1v4.asm):02002         ;; SD_WaitReady - wait for the SD card to become ready
                      (   monitor1v4.asm):02003         ;;                   (e.g. after WriteBlock)
                      (   monitor1v4.asm):02004         ;; return:  Z=1, timeout error
                      (   monitor1v4.asm):02005         ;;          Z=0, card is ready
                      (   monitor1v4.asm):02006         ;;
ECE4                  (   monitor1v4.asm):02007         SD_WaitReady:
ECE4 3432             (   monitor1v4.asm):02008                  PSHS     A,Y,X                             ; preserve A,Y,X
ECE6 108E61A8         (   monitor1v4.asm):02009                  LDY      #25000                            ; 25,000 attempts
ECEA 8E0002           (   monitor1v4.asm):02010         S?W0     LDX      #2                                ; 20us in between attempts = 500ms
ECED BDE813           (   monitor1v4.asm):02011                  JSR      DELAYUS
ECF0 313F             (   monitor1v4.asm):02012                  LEAY     -1,Y
ECF2 2707             (   monitor1v4.asm):02013                  BEQ      S?W1                              ; timeout (Y=0 -> Z=1)
ECF4 BDEA49           (   monitor1v4.asm):02014                  JSR      SPI_Read                          ; send an FF over SPI
ECF7 43               (   monitor1v4.asm):02015                  COMA                                       ; $FF -> $00?
ECF8 26F0             (   monitor1v4.asm):02016                  BNE      S?W0                              ;    nope, next attempt
ECFA 43               (   monitor1v4.asm):02017                  COMA                                       ; $00 -> $FF (Z=0)
ECFB 35B2             (   monitor1v4.asm):02018         S?W1     PULS     A,Y,X,PC
                      (   monitor1v4.asm):02019         
                      (   monitor1v4.asm):02020         ;======================================================================
                      (   monitor1v4.asm):02021         ;
                      (   monitor1v4.asm):02022         ;  6309 Debug monitor for use with NOICE09
                      (   monitor1v4.asm):02023         ;  Adapted for HD6309 SBC April 2020
                      (   monitor1v4.asm):02024         ;
                      (   monitor1v4.asm):02025         ;  Copyright (c) 1992-2006 by John Hartman
                      (   monitor1v4.asm):02026         ;
                      (   monitor1v4.asm):02027         ;  Modification History:
                      (   monitor1v4.asm):02028         ;    13-Mar-2006 JLH ported from 6809 version with assistance from Robert Gault
                      (   monitor1v4.asm):02029         ;     8-Mar-2016 TJL corrected bug in the RUN_TARGET handler
                      (   monitor1v4.asm):02030         ;    11-Mar-2020 TJL ported to HD6309 SBC platform, lwasm assembler
                      (   monitor1v4.asm):02031         ;
                      (   monitor1v4.asm):02032         ;======================================================================
                      (   monitor1v4.asm):02033         
                      (   monitor1v4.asm):02034         ;===========================================================================
                      (   monitor1v4.asm):02035         ; PLATFORM DEPENDENT INPUT/OUTPUT CODE
                      (   monitor1v4.asm):02036         ;===========================================================================
                      (   monitor1v4.asm):02037         
                      (   monitor1v4.asm):02038         ;===========================================================================
                      (   monitor1v4.asm):02039         ;  DBGETCH Get a character to A from SCC DEBUG CHANNEL
                      (   monitor1v4.asm):02040         ;
                      (   monitor1v4.asm):02041         ;return: character in A
                      (   monitor1v4.asm):02042         ;        V=0 if data received
                      (   monitor1v4.asm):02043         ;        V=1 if timeout (0.5 seconds)
                      (   monitor1v4.asm):02044         ;
                      (   monitor1v4.asm):02045         ;  Uses 4 bytes of stack including return address
                      (   monitor1v4.asm):02046         ;
                      (   monitor1v4.asm):02047         ; DBGETCH1 entry point - one attempt
ECFD                  (   monitor1v4.asm):02048         DBGETCH1:
ECFD 3420             (   monitor1v4.asm):02049                  PSHS     Y                                 ; preserve Y
ECFF 108E0002         (   monitor1v4.asm):02050                  LDY      #2                                ; only check once for a character in channel A
ED03 2006             (   monitor1v4.asm):02051                  BRA      GC11?                             ; process as DBGETCH
ED05                  (   monitor1v4.asm):02052         DBGETCH:
ED05 3420             (   monitor1v4.asm):02053                  PSHS     Y                                 ; preserve Y
ED07 108E0000         (   monitor1v4.asm):02054                  LDY      #0                                ; clear Y for longest timeout (~450ms)
ED0B 1A02             (   monitor1v4.asm):02055         GC11?    ORCC     #CC_V                             ; set V flag ahead of decrement
ED0D 313F             (   monitor1v4.asm):02056                  LEAY     -1,Y                              ; decrement timeout counter (V unaffected)
ED0F 270F             (   monitor1v4.asm):02057                  BEQ      GC91?                             ;  EXIT IF TIMEOUT (with V=1)
ED11 B6E010           (   monitor1v4.asm):02058                  LDA      DEBUG_CMD                            ; reset register pointer to WR0/RR0
ED14 B6E010           (   monitor1v4.asm):02059                  LDA      DEBUG_CMD                            ; read RR0
ED17 8401             (   monitor1v4.asm):02060                  ANDA     #ZSCC.RXBF                        ; examine the RX char available bit
ED19 27F0             (   monitor1v4.asm):02061                  BEQ      GC11?                             ;  LOOP UNTIL CHARACTER AVAILABLE
ED1B B6E011           (   monitor1v4.asm):02062                  LDA      DEBUG_DAT                            ; read character
ED1E 8A00             (   monitor1v4.asm):02063                  ORA      #0                                ; clear V flag
ED20 35A0             (   monitor1v4.asm):02064         GC91?    PULS     Y,PC                              ; restore Y and return
                      (   monitor1v4.asm):02065         
                      (   monitor1v4.asm):02066         
                      (   monitor1v4.asm):02067         ;===========================================================================
                      (   monitor1v4.asm):02068         ;  DBPUTCH Output character to SCC DEBUG CHANNEL
                      (   monitor1v4.asm):02069         ;
                      (   monitor1v4.asm):02070         ;  Uses 2 bytes of stack including return address
                      (   monitor1v4.asm):02071         ;
                      (   monitor1v4.asm):02072         ; inputs: character in A
                      (   monitor1v4.asm):02073         ; return: character in A
                      (   monitor1v4.asm):02074         ;
ED22                  (   monitor1v4.asm):02075         DBPUTCH:
ED22 3402             (   monitor1v4.asm):02076                  PSHS     A
ED24 B6E010           (   monitor1v4.asm):02077         PC10?    LDA      DEBUG_CMD                            ; reset SCC register pointer to WR0/RR0
ED27 B6E010           (   monitor1v4.asm):02078                  LDA      DEBUG_CMD                            ; read RR0
ED2A 8404             (   monitor1v4.asm):02079                  ANDA     #ZSCC.TXBE                        ;  examine the TX buffer empty bit
ED2C 27F6             (   monitor1v4.asm):02080                  BEQ      PC10?                             ;  LOOP UNTIL EMPTY
ED2E 3502             (   monitor1v4.asm):02081                  PULS     A
ED30 B7E011           (   monitor1v4.asm):02082                  STA      DEBUG_DAT                            ; write character to SCC B data reg
ED33 39               (   monitor1v4.asm):02083                  RTS
                      (   monitor1v4.asm):02084         ;
                      (   monitor1v4.asm):02085         ;======================================================================
                      (   monitor1v4.asm):02086         ;  Response string for GET TARGET STATUS request
                      (   monitor1v4.asm):02087         ;  Reply describes target:
ED34 11               (   monitor1v4.asm):02088         TSTG              FCB   17                          ; 2: PROCESSOR TYPE = 6309
ED35 80               (   monitor1v4.asm):02089                           FCB   COMBUF_SIZE                 ; 3: SIZE OF COMMUNICATIONS BUFFER
ED36 00               (   monitor1v4.asm):02090                           FCB   0                           ; 4: NO TASKING SUPPORT
ED37 00000000         (   monitor1v4.asm):02091                           FDB   0,0                         ; 5-8: LOW AND HIGH LIMIT OF MAPPED MEM (NONE)
ED3B 01               (   monitor1v4.asm):02092                           FCB   B1-B0                       ; 9:  BREAKPOINT INSTR LENGTH
ED3C 3F               (   monitor1v4.asm):02093         B0                SWI                               ; 10: BREAKPOINT INSTRUCTION
ED3D 4844363330392053 (   monitor1v4.asm):02094         B1                FCC   'HD6309 SBC V1.41'          ; DESCRIPTION TEXT
     42432056312E3431
ED4D 00               (   monitor1v4.asm):02095                           FCB   0                           ; DESCRIPTION NULL TERMINATOR
     001A             (   monitor1v4.asm):02096         TSTG_SIZE         EQU   *-TSTG                      ; SIZE OF STRING
                      (   monitor1v4.asm):02097         
                      (   monitor1v4.asm):02098         ;======================================================================
                      (   monitor1v4.asm):02099         ;  HARDWARE PLATFORM INDEPENDENT EQUATES AND CODE
                      (   monitor1v4.asm):02100         ;
                      (   monitor1v4.asm):02101         ;  Communications function codes.
     00FF             (   monitor1v4.asm):02102         FN_GET_STAT       EQU   $FF                         ; reply with device info
     00FE             (   monitor1v4.asm):02103         FN_READ_MEM       EQU   $FE                         ; reply with data
     00FD             (   monitor1v4.asm):02104         FN_WRITE_M        EQU   $FD                         ; reply with status (+/-)
     00FC             (   monitor1v4.asm):02105         FN_READ_RG        EQU   $FC                         ; reply with registers
     00FB             (   monitor1v4.asm):02106         FN_WRITE_RG       EQU   $FB                         ; reply with status
     00FA             (   monitor1v4.asm):02107         FN_RUN_TARG       EQU   $FA                         ; reply (delayed) with registers
     00F9             (   monitor1v4.asm):02108         FN_SET_BYTE       EQU   $F9                         ; reply with data (truncate if error)
     00F8             (   monitor1v4.asm):02109         FN_IN             EQU   $F8                         ; input from port
     00F7             (   monitor1v4.asm):02110         FN_OUT            EQU   $F7                         ; output to port
                      (   monitor1v4.asm):02111         ;                                       ;
     00F7             (   monitor1v4.asm):02112         FN_MIN            EQU   $F7                         ; MINIMUM RECOGNIZED FUNCTION CODE
     00F0             (   monitor1v4.asm):02113         FN_ERROR          EQU   $F0                         ; error reply to unknown op-code
                      (   monitor1v4.asm):02114         ;
                      (   monitor1v4.asm):02115         
                      (   monitor1v4.asm):02116         ;  Set CPU mode to safe state, configure hardware
                      (   monitor1v4.asm):02117         ;
ED4E 1A50             (   monitor1v4.asm):02118         NOICE:   ORCC     #CC_I+CC_F                        ; INTERRUPTS OFF
ED50 10CEBFAB         (   monitor1v4.asm):02119                  LDS      #MONSTACK                         ; CLEAN STACK IS HAPPY STACK
ED54 BDE6A7           (   monitor1v4.asm):02120                  JSR      DEBUG_INIT                        ; init debug SCC channel for 115.2kbps
                      (   monitor1v4.asm):02121         ;
                      (   monitor1v4.asm):02122         ;  Initialize RAM interrupt vectors
ED57 108EEDA2         (   monitor1v4.asm):02123                  LDY      #INT_ENTRY                        ; ADDRESS OF DEFAULT HANDLER
ED5B 8EBF83           (   monitor1v4.asm):02124                  LDX      #RAMVEC                           ; POINTER TO RAM VECTORS
ED5E C608             (   monitor1v4.asm):02125                  LDB      #NVEC                             ; NUMBER OF VECTORS
ED60 10AF81           (   monitor1v4.asm):02126         RES10    STY      ,X++                              ; SET VECTOR
ED63 5A               (   monitor1v4.asm):02127                  DECB
ED64 26FA             (   monitor1v4.asm):02128                  BNE      RES10
                      (   monitor1v4.asm):02129         ;
                      (   monitor1v4.asm):02130         ;  Initialize user registers
ED66 CCBF00           (   monitor1v4.asm):02131                  LDD      #INITSTACK
ED69 B7BFBF           (   monitor1v4.asm):02132                  STA      REG_SP+1                          ; INIT USER'S STACK POINTER MSB
ED6C F7BFBE           (   monitor1v4.asm):02133                  STB      REG_SP                            ; LSB
                      (   monitor1v4.asm):02134         ;
ED6F 104F             (   monitor1v4.asm):02135                  CLRD
ED71 FDBFCF           (   monitor1v4.asm):02136                  STD      REG_PC
ED74 B7BFC9           (   monitor1v4.asm):02137                  STA      REG_A
ED77 B7BFC8           (   monitor1v4.asm):02138                  STA      REG_B
ED7A B7BFC7           (   monitor1v4.asm):02139                  STA      REG_E
ED7D B7BFC6           (   monitor1v4.asm):02140                  STA      REG_F
ED80 B7BFCA           (   monitor1v4.asm):02141                  STA      REG_DP
ED83 B7BFCC           (   monitor1v4.asm):02142                  STA      REG_MD
ED86 FDBFC4           (   monitor1v4.asm):02143                  STD      REG_X
ED89 FDBFC2           (   monitor1v4.asm):02144                  STD      REG_Y
ED8C FDBFC0           (   monitor1v4.asm):02145                  STD      REG_U
ED8F FDBFCD           (   monitor1v4.asm):02146                  STD      REG_V
ED92 B7BFBC           (   monitor1v4.asm):02147                  STA      REG_STATE                         ; initial state is "RESET"
                      (   monitor1v4.asm):02148         ;
ED95 86D0             (   monitor1v4.asm):02149                  LDA      #CC_E+CC_I+CC_F                   ; state "all regs pushed", no ints
ED97 B7BFCB           (   monitor1v4.asm):02150                  STA      REG_CC
                      (   monitor1v4.asm):02151         ;
                      (   monitor1v4.asm):02152         ;  Set function code for "GO".  Then if we reset after being told to
                      (   monitor1v4.asm):02153         ;  GO, we will come back with registers so user can see the crash
ED9A 86FA             (   monitor1v4.asm):02154                  LDA      #FN_RUN_TARG
ED9C B7BF00           (   monitor1v4.asm):02155                  STA      COMBUF
ED9F 7EEEF4           (   monitor1v4.asm):02156                  JMP      RETURN_REGS                       ; DUMP REGS, ENTER MONITOR
                      (   monitor1v4.asm):02157         
                      (   monitor1v4.asm):02158         ;===========================================================================
                      (   monitor1v4.asm):02159         ;  Common handler for default interrupt handlers
                      (   monitor1v4.asm):02160         ;  Enter with A=interrupt code = processor state
                      (   monitor1v4.asm):02161         ;  All registers stacked, PC=next instruction
                      (   monitor1v4.asm):02162         ;
                      (   monitor1v4.asm):02163         ;  If 6809 mode, stack has CC A B DP XH XL YH YL UH UL PCH PCL
                      (   monitor1v4.asm):02164         ;  If 6309 mode, stack has CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      (   monitor1v4.asm):02165         ;
EDA2                  (   monitor1v4.asm):02166         INT_ENTRY
EDA2 B7BFBC           (   monitor1v4.asm):02167                  STA      REG_STATE                         ; SAVE STATE
                      (   monitor1v4.asm):02168         ;
                      (   monitor1v4.asm):02169         ;  Save registers from stack to reg block for return to master
                      (   monitor1v4.asm):02170         ;  Host wants least significant bytes first, so flip as necessary
EDA5 3502             (   monitor1v4.asm):02171                  PULS     A
EDA7 B7BFCB           (   monitor1v4.asm):02172                  STA      REG_CC                            ; CONDITION CODES
EDAA 3502             (   monitor1v4.asm):02173                  PULS     A
EDAC B7BFC9           (   monitor1v4.asm):02174                  STA      REG_A                             ; A
EDAF 3502             (   monitor1v4.asm):02175                  PULS     A
EDB1 B7BFC8           (   monitor1v4.asm):02176                  STA      REG_B                             ; B
                      (   monitor1v4.asm):02177         
                      (   monitor1v4.asm):02178         ;  If native mode, E and F are on stack
                      (   monitor1v4.asm):02179         ;  If 6809 mode, E and F are in registers, unchanged from interrupt til here
EDB4 BDF083           (   monitor1v4.asm):02180                  JSR      MD_TEST
EDB7 2602             (   monitor1v4.asm):02181                  BNE      IE_10                             ; Jump if 6809 mode
EDB9 1039             (   monitor1v4.asm):02182                  PULSW                                      ; else native: get from stack
EDBB 11B7BFC7         (   monitor1v4.asm):02183         IE_10    STE      REG_E
EDBF 11F7BFC6         (   monitor1v4.asm):02184                  STF      REG_F
                      (   monitor1v4.asm):02185         
                      (   monitor1v4.asm):02186         ;  V isn't on the stack, but we haven't touched it.  Copy to RAM
EDC3 1F70             (   monitor1v4.asm):02187                  TFR      V,D
EDC5 B7BFCE           (   monitor1v4.asm):02188                  STA      REG_V+1                           ; MSB V
EDC8 F7BFCD           (   monitor1v4.asm):02189                  STB      REG_V                             ; LSB V
                      (   monitor1v4.asm):02190         
                      (   monitor1v4.asm):02191         ;  There seems to be no way to store MD, and no way to load it except immediate
                      (   monitor1v4.asm):02192         ;  Thus we have to construct it by BITMD
EDCB B6BFCC           (   monitor1v4.asm):02193                  LDA      REG_MD
EDCE 8403             (   monitor1v4.asm):02194                  ANDA     #$03                              ; save only bits 1 and 0 (set by MD_TEST)
EDD0 113C40           (   monitor1v4.asm):02195                  BITMD    #$40
EDD3 2702             (   monitor1v4.asm):02196                  BEQ      IE_11
EDD5 8A40             (   monitor1v4.asm):02197                  ORA      #$40
EDD7 113C80           (   monitor1v4.asm):02198         IE_11    BITMD    #$80
EDDA 2702             (   monitor1v4.asm):02199                  BEQ      IE_12
EDDC 8A80             (   monitor1v4.asm):02200                  ORA      #$80
EDDE B7BFCC           (   monitor1v4.asm):02201         IE_12    STA      REG_MD
                      (   monitor1v4.asm):02202         
EDE1 3502             (   monitor1v4.asm):02203                  PULS     A
EDE3 B7BFCA           (   monitor1v4.asm):02204                  STA      REG_DP                            ; DP
EDE6 3506             (   monitor1v4.asm):02205                  PULS     D
EDE8 B7BFC5           (   monitor1v4.asm):02206                  STA      REG_X+1                           ; MSB X
EDEB F7BFC4           (   monitor1v4.asm):02207                  STB      REG_X                             ; LSB X
EDEE 3506             (   monitor1v4.asm):02208                  PULS     D
EDF0 B7BFC3           (   monitor1v4.asm):02209                  STA      REG_Y+1                           ; MSB Y
EDF3 F7BFC2           (   monitor1v4.asm):02210                  STB      REG_Y                             ; LSB Y
EDF6 3506             (   monitor1v4.asm):02211                  PULS     D
EDF8 B7BFC1           (   monitor1v4.asm):02212                  STA      REG_U+1                           ; MSB U
EDFB F7BFC0           (   monitor1v4.asm):02213                  STB      REG_U                             ; LSB U
                      (   monitor1v4.asm):02214         ;
                      (   monitor1v4.asm):02215         ;  If this is a breakpoint (state = 1), then back up PC to point at SWI
EDFE 3510             (   monitor1v4.asm):02216                  PULS     X                                 ; PC AFTER INTERRUPT
EE00 B6BFBC           (   monitor1v4.asm):02217                  LDA      REG_STATE
EE03 8101             (   monitor1v4.asm):02218                  CMPA     #1
EE05 2602             (   monitor1v4.asm):02219                  BNE      NOTBP                             ; BR IF NOT A BREAKPOINT
EE07 301F             (   monitor1v4.asm):02220                  LEAX     -1,X                              ; ELSE BACK UP TO POINT AT SWI LOCATION
EE09 1F10             (   monitor1v4.asm):02221         NOTBP    TFR      X,D                               ; TRANSFER PC TO D
EE0B B7BFD0           (   monitor1v4.asm):02222                  STA      REG_PC+1                          ; MSB
EE0E F7BFCF           (   monitor1v4.asm):02223                  STB      REG_PC                            ; LSB
EE11 7EEF87           (   monitor1v4.asm):02224                  JMP      ENTER_MON                         ; REG_PC POINTS AT POST-INTERRUPT OPCODE
                      (   monitor1v4.asm):02225         ;
                      (   monitor1v4.asm):02226         ;===========================================================================
                      (   monitor1v4.asm):02227         ;  Main loop  wait for command frame from master
                      (   monitor1v4.asm):02228         ;
                      (   monitor1v4.asm):02229         ;  Uses 6 bytes of stack including return address
                      (   monitor1v4.asm):02230         ;
EE14 10CEBFAB         (   monitor1v4.asm):02231         MAIN     LDS      #MONSTACK                         ; CLEAN STACK IS HAPPY STACK
EE18 8EBF00           (   monitor1v4.asm):02232                  LDX      #COMBUF                           ; BUILD MESSAGE HERE
                      (   monitor1v4.asm):02233         ;
                      (   monitor1v4.asm):02234         ;  First byte is a function code
EE1B BDED05           (   monitor1v4.asm):02235         MA05     JSR      DBGETCH                           ; GET A FUNCTION (6 bytes of stack)
EE1E 29F4             (   monitor1v4.asm):02236                  BVS      MAIN                              ; JIF TIMEOUT: RESYNC
EE20 81F7             (   monitor1v4.asm):02237                  CMPA     #FN_MIN
EE22 25F0             (   monitor1v4.asm):02238                  BLO      MAIN                              ; JIF BELOW MIN: ILLEGAL FUNCTION
EE24 A780             (   monitor1v4.asm):02239                  STA      ,X+                               ; SAVE FUNCTION CODE
                      (   monitor1v4.asm):02240         ;
                      (   monitor1v4.asm):02241         ;  Second byte is data byte count (may be zero)
EE26 BDED05           (   monitor1v4.asm):02242                  JSR      DBGETCH                           ; GET A LENGTH BYTE
EE29 29E9             (   monitor1v4.asm):02243                  BVS      MAIN                              ; JIF TIMEOUT: RESYNC
EE2B 8180             (   monitor1v4.asm):02244                  CMPA     #COMBUF_SIZE
EE2D 22E5             (   monitor1v4.asm):02245                  BHI      MAIN                              ; JIF TOO LONG: ILLEGAL LENGTH
EE2F A780             (   monitor1v4.asm):02246                  STA      ,X+                               ; SAVE LENGTH
EE31 8100             (   monitor1v4.asm):02247                  CMPA     #0
EE33 270C             (   monitor1v4.asm):02248                  BEQ      MA80                              ; SKIP DATA LOOP IF LENGTH = 0
                      (   monitor1v4.asm):02249         ;
                      (   monitor1v4.asm):02250         ;  Loop for data
EE35 1F89             (   monitor1v4.asm):02251                  TFR      A,B                               ; SAVE LENGTH FOR LOOP
EE37 BDED05           (   monitor1v4.asm):02252         MA10     JSR      DBGETCH                           ; GET A DATA BYTE
EE3A 29D8             (   monitor1v4.asm):02253                  BVS      MAIN                              ; JIF TIMEOUT: RESYNC
EE3C A780             (   monitor1v4.asm):02254                  STA      ,X+                               ; SAVE DATA BYTE
EE3E 5A               (   monitor1v4.asm):02255                  DECB
EE3F 26F6             (   monitor1v4.asm):02256                  BNE      MA10
                      (   monitor1v4.asm):02257         ;
                      (   monitor1v4.asm):02258         ;  Get the checksum
EE41 BDED05           (   monitor1v4.asm):02259         MA80     JSR      DBGETCH                           ; GET THE CHECKSUM
EE44 29CE             (   monitor1v4.asm):02260                  BVS      MAIN                              ; JIF TIMEOUT: RESYNC
EE46 3402             (   monitor1v4.asm):02261                  PSHS     A                                 ; SAVE CHECKSUM
                      (   monitor1v4.asm):02262         ;
                      (   monitor1v4.asm):02263         ;  Compare received checksum to that calculated on received buffer
                      (   monitor1v4.asm):02264         ;  (Sum should be 0)
EE48 BDF004           (   monitor1v4.asm):02265                  JSR      CHECKSUM
EE4B ABE0             (   monitor1v4.asm):02266                  ADDA     ,S+                               ; ADD SAVED CHECKSUM TO COMPUTED
EE4D 26C5             (   monitor1v4.asm):02267                  BNE      MAIN                              ; JIF BAD CHECKSUM
                      (   monitor1v4.asm):02268         ;
                      (   monitor1v4.asm):02269         ;  Process the message.
EE4F 8EBF00           (   monitor1v4.asm):02270                  LDX      #COMBUF
EE52 A680             (   monitor1v4.asm):02271                  LDA      ,X+                               ; GET THE FUNCTION CODE
EE54 E680             (   monitor1v4.asm):02272                  LDB      ,X+                               ; GET THE LENGTH
EE56 81FF             (   monitor1v4.asm):02273                  CMPA     #FN_GET_STAT
EE58 2742             (   monitor1v4.asm):02274                  BEQ      TARGET_STAT
EE5A 81FE             (   monitor1v4.asm):02275                  CMPA     #FN_READ_MEM
EE5C 2726             (   monitor1v4.asm):02276                  BEQ      JREAD_MEM
EE5E 81FD             (   monitor1v4.asm):02277                  CMPA     #FN_WRITE_M
EE60 2725             (   monitor1v4.asm):02278                  BEQ      JWRITE_MEM
EE62 81FC             (   monitor1v4.asm):02279                  CMPA     #FN_READ_RG
EE64 2724             (   monitor1v4.asm):02280                  BEQ      JREAD_REGS
EE66 81FB             (   monitor1v4.asm):02281                  CMPA     #FN_WRITE_RG
EE68 2723             (   monitor1v4.asm):02282                  BEQ      JWRITE_REGS
EE6A 81FA             (   monitor1v4.asm):02283                  CMPA     #FN_RUN_TARG
EE6C 2722             (   monitor1v4.asm):02284                  BEQ      JRUN_TARGET
EE6E 81F9             (   monitor1v4.asm):02285                  CMPA     #FN_SET_BYTE
EE70 2721             (   monitor1v4.asm):02286                  BEQ      JSET_BYTES
EE72 81F8             (   monitor1v4.asm):02287                  CMPA     #FN_IN
EE74 2720             (   monitor1v4.asm):02288                  BEQ      JIN_PORT
EE76 81F7             (   monitor1v4.asm):02289                  CMPA     #FN_OUT
EE78 271F             (   monitor1v4.asm):02290                  BEQ      JOUT_PORT
                      (   monitor1v4.asm):02291         ;
                      (   monitor1v4.asm):02292         ;  Error: unknown function.  Complain
EE7A 86F0             (   monitor1v4.asm):02293                  LDA      #FN_ERROR
EE7C B7BF00           (   monitor1v4.asm):02294                  STA      COMBUF                            ; SET FUNCTION AS "ERROR"
EE7F 8601             (   monitor1v4.asm):02295                  LDA      #1
EE81 7EEFE2           (   monitor1v4.asm):02296                  JMP      SEND_STATUS                       ; VALUE IS "ERROR"
                      (   monitor1v4.asm):02297         ;
                      (   monitor1v4.asm):02298         ;  long jumps to handlers
EE84 7EEEB1           (   monitor1v4.asm):02299         JREAD_MEM         JMP  READ_MEM
EE87 7EEEC8           (   monitor1v4.asm):02300         JWRITE_MEM        JMP  WRITE_MEM
EE8A 7EEEF4           (   monitor1v4.asm):02301         JREAD_REGS        JMP  READ_REGS
EE8D 7EEF09           (   monitor1v4.asm):02302         JWRITE_REGS       JMP  WRITE_REGS
EE90 7EEF1B           (   monitor1v4.asm):02303         JRUN_TARGET       JMP  RUN_TARGET
EE93 7EEF9B           (   monitor1v4.asm):02304         JSET_BYTES        JMP  SET_BYTES
EE96 7EEFC9           (   monitor1v4.asm):02305         JIN_PORT          JMP  IN_PORT
EE99 7EEFD4           (   monitor1v4.asm):02306         JOUT_PORT         JMP  OUT_PORT
                      (   monitor1v4.asm):02307         
                      (   monitor1v4.asm):02308         ;===========================================================================
                      (   monitor1v4.asm):02309         ;
                      (   monitor1v4.asm):02310         ;  Target Status:  FN, len
                      (   monitor1v4.asm):02311         ;
                      (   monitor1v4.asm):02312         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02313         ;
EE9C                  (   monitor1v4.asm):02314         TARGET_STAT
EE9C 8EED34           (   monitor1v4.asm):02315                  LDX      #TSTG                             ; DATA FOR REPLY
EE9F 108EBF01         (   monitor1v4.asm):02316                  LDY      #COMBUF+1                         ; POINTER TO RETURN BUFFER
EEA3 C61A             (   monitor1v4.asm):02317                  LDB      #TSTG_SIZE                        ; LENGTH OF REPLY
EEA5 E7A0             (   monitor1v4.asm):02318                  STB      ,Y+                               ; SET SIZE IN REPLY BUFFER
EEA7 A680             (   monitor1v4.asm):02319         TS10     LDA      ,X+                               ; MOVE REPLY DATA TO BUFFER
EEA9 A7A0             (   monitor1v4.asm):02320                  STA      ,Y+
EEAB 5A               (   monitor1v4.asm):02321                  DECB
EEAC 26F9             (   monitor1v4.asm):02322                  BNE      TS10
                      (   monitor1v4.asm):02323         ;
                      (   monitor1v4.asm):02324         ;  Compute checksum on buffer, and send to master, then return
EEAE 7EEFEC           (   monitor1v4.asm):02325                  JMP      SEND
                      (   monitor1v4.asm):02326         
                      (   monitor1v4.asm):02327         ;===========================================================================
                      (   monitor1v4.asm):02328         ;
                      (   monitor1v4.asm):02329         ;  Read Memory:  FN, len, page, Alo, Ahi, Nbytes
                      (   monitor1v4.asm):02330         ;
                      (   monitor1v4.asm):02331         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02332         ;
EEB1                  (   monitor1v4.asm):02333         READ_MEM
                      (   monitor1v4.asm):02334         ;
                      (   monitor1v4.asm):02335         ;  Set map
                      (   monitor1v4.asm):02336         ;;;;    LDA     0,X
                      (   monitor1v4.asm):02337         ;;;;    STA     MAPIMG
                      (   monitor1v4.asm):02338         ;;;;    STA     MAPREG
                      (   monitor1v4.asm):02339         ;
                      (   monitor1v4.asm):02340         ;  Get address
EEB1 A602             (   monitor1v4.asm):02341                  LDA      2,X                               ; MSB OF ADDRESS IN A
EEB3 E601             (   monitor1v4.asm):02342                  LDB      1,X                               ; LSB OF ADDRESS IN B
EEB5 1F02             (   monitor1v4.asm):02343                  TFR      D,Y                               ; ADDRESS IN Y
                      (   monitor1v4.asm):02344         ;
                      (   monitor1v4.asm):02345         ;  Prepare return buffer: FN (unchanged), LEN, DATA
EEB7 E603             (   monitor1v4.asm):02346                  LDB      3,X                               ; NUMBER OF BYTES TO RETURN
EEB9 F7BF01           (   monitor1v4.asm):02347                  STB      COMBUF+1                          ; RETURN LENGTH = REQUESTED DATA
EEBC 2707             (   monitor1v4.asm):02348                  BEQ      GLP90                             ; JIF NO BYTES TO GET
                      (   monitor1v4.asm):02349         ;
                      (   monitor1v4.asm):02350         ;  Read the requested bytes from local memory
EEBE A6A0             (   monitor1v4.asm):02351         GLP      LDA      ,Y+                               ; GET BYTE
EEC0 A780             (   monitor1v4.asm):02352                  STA      ,X+                               ; STORE TO RETURN BUFFER
EEC2 5A               (   monitor1v4.asm):02353                  DECB
EEC3 26F9             (   monitor1v4.asm):02354                  BNE      GLP
                      (   monitor1v4.asm):02355         ;
                      (   monitor1v4.asm):02356         ;  Compute checksum on buffer, and send to master, then return
EEC5 7EEFEC           (   monitor1v4.asm):02357         GLP90    JMP      SEND
                      (   monitor1v4.asm):02358         
                      (   monitor1v4.asm):02359         ;===========================================================================
                      (   monitor1v4.asm):02360         ;
                      (   monitor1v4.asm):02361         ;  Write Memory:  FN, len, page, Alo, Ahi, (len-3 bytes of Data)
                      (   monitor1v4.asm):02362         ;
                      (   monitor1v4.asm):02363         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02364         ;
                      (   monitor1v4.asm):02365         ;  Uses 6 bytes of stack
                      (   monitor1v4.asm):02366         ;
EEC8                  (   monitor1v4.asm):02367         WRITE_MEM
                      (   monitor1v4.asm):02368         ;
                      (   monitor1v4.asm):02369         ;  Set map
EEC8 A680             (   monitor1v4.asm):02370                  LDA      ,X+
                      (   monitor1v4.asm):02371         ;;;;    STA     MAPIMG
                      (   monitor1v4.asm):02372         ;;;;    STA     MAPREG
                      (   monitor1v4.asm):02373         ;
                      (   monitor1v4.asm):02374         ;  Get address
EECA E680             (   monitor1v4.asm):02375                  LDB      ,X+                               ; LSB OF ADDRESS IN B
EECC A680             (   monitor1v4.asm):02376                  LDA      ,X+                               ; MSB OF ADDRESS IN A
EECE 1F02             (   monitor1v4.asm):02377                  TFR      D,Y                               ; ADDRESS IN Y
                      (   monitor1v4.asm):02378         ;
                      (   monitor1v4.asm):02379         ;  Compute number of bytes to write
EED0 F6BF01           (   monitor1v4.asm):02380                  LDB      COMBUF+1                          ; NUMBER OF BYTES TO RETURN
EED3 C003             (   monitor1v4.asm):02381                  SUBB     #3                                ; MINUS PAGE AND ADDRESS
EED5 2714             (   monitor1v4.asm):02382                  BEQ      WLP50                             ; JIF NO BYTES TO PUT
                      (   monitor1v4.asm):02383         ;
                      (   monitor1v4.asm):02384         ;  Write the specified bytes to local memory
EED7 3434             (   monitor1v4.asm):02385                  PSHS     B,X,Y
EED9 A680             (   monitor1v4.asm):02386         WLP      LDA      ,X+                               ; GET BYTE TO WRITE
EEDB A7A0             (   monitor1v4.asm):02387                  STA      ,Y+                               ; STORE THE BYTE AT ,Y
EEDD 5A               (   monitor1v4.asm):02388                  DECB
EEDE 26F9             (   monitor1v4.asm):02389                  BNE      WLP
                      (   monitor1v4.asm):02390         ;
                      (   monitor1v4.asm):02391         ;  Compare to see if the write worked
EEE0 3534             (   monitor1v4.asm):02392                  PULS     B,X,Y
EEE2 A680             (   monitor1v4.asm):02393         WLP20    LDA      ,X+                               ; GET BYTE JUST WRITTEN
EEE4 A1A0             (   monitor1v4.asm):02394                  CMPA     ,Y+
EEE6 2607             (   monitor1v4.asm):02395                  BNE      WLP80                             ; BR IF WRITE FAILED
EEE8 5A               (   monitor1v4.asm):02396                  DECB
EEE9 26F7             (   monitor1v4.asm):02397                  BNE      WLP20
                      (   monitor1v4.asm):02398         ;
                      (   monitor1v4.asm):02399         ;  Write succeeded:  return status = 0
EEEB 8600             (   monitor1v4.asm):02400         WLP50    LDA      #0                                ; RETURN STATUS = 0
EEED 2002             (   monitor1v4.asm):02401                  BRA      WLP90
                      (   monitor1v4.asm):02402         ;
                      (   monitor1v4.asm):02403         ;  Write failed:  return status = 1
EEEF 8601             (   monitor1v4.asm):02404         WLP80    LDA      #1
                      (   monitor1v4.asm):02405         
                      (   monitor1v4.asm):02406         ;  Return OK status
EEF1 7EEFE2           (   monitor1v4.asm):02407         WLP90    JMP      SEND_STATUS
                      (   monitor1v4.asm):02408         
                      (   monitor1v4.asm):02409         ;===========================================================================
                      (   monitor1v4.asm):02410         ;
                      (   monitor1v4.asm):02411         ;  Read registers:  FN, len=0
                      (   monitor1v4.asm):02412         ;
                      (   monitor1v4.asm):02413         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02414         ;
EEF4                  (   monitor1v4.asm):02415         READ_REGS
                      (   monitor1v4.asm):02416         ;
                      (   monitor1v4.asm):02417         ;  Enter here from SWI after "RUN" and "STEP" to return task registers
EEF4                  (   monitor1v4.asm):02418         RETURN_REGS
EEF4 108EBFBC         (   monitor1v4.asm):02419                  LDY      #TASK_REGS                        ; POINTER TO REGISTERS
EEF8 C615             (   monitor1v4.asm):02420                  LDB      #TASK_REG_SZ                      ; NUMBER OF BYTES
EEFA 8EBF01           (   monitor1v4.asm):02421                  LDX      #COMBUF+1                         ; POINTER TO RETURN BUFFER
EEFD E780             (   monitor1v4.asm):02422                  STB      ,X+                               ; SAVE RETURN DATA LENGTH
                      (   monitor1v4.asm):02423         ;
                      (   monitor1v4.asm):02424         ;  Copy the registers
EEFF A6A0             (   monitor1v4.asm):02425         GRLP     LDA      ,Y+                               ; GET BYTE TO A
EF01 A780             (   monitor1v4.asm):02426                  STA      ,X+                               ; STORE TO RETURN BUFFER
EF03 5A               (   monitor1v4.asm):02427                  DECB
EF04 26F9             (   monitor1v4.asm):02428                  BNE      GRLP
                      (   monitor1v4.asm):02429         ;
                      (   monitor1v4.asm):02430         ;  Compute checksum on buffer, and send to master, then return
EF06 7EEFEC           (   monitor1v4.asm):02431                  JMP      SEND
                      (   monitor1v4.asm):02432         
                      (   monitor1v4.asm):02433         ;===========================================================================
                      (   monitor1v4.asm):02434         ;
                      (   monitor1v4.asm):02435         ;  Write registers:  FN, len, (register image)
                      (   monitor1v4.asm):02436         ;
                      (   monitor1v4.asm):02437         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02438         ;
EF09                  (   monitor1v4.asm):02439         WRITE_REGS
                      (   monitor1v4.asm):02440         ;
EF09 5D               (   monitor1v4.asm):02441                  TSTB                                       ; NUMBER OF BYTES
EF0A 270B             (   monitor1v4.asm):02442                  BEQ      WRR80                             ; JIF NO REGISTERS
                      (   monitor1v4.asm):02443         ;
                      (   monitor1v4.asm):02444         ;  Copy the registers
EF0C 108EBFBC         (   monitor1v4.asm):02445                  LDY      #TASK_REGS                        ; POINTER TO REGISTERS
EF10 A680             (   monitor1v4.asm):02446         WRRLP    LDA      ,X+                               ; GET BYTE TO A
EF12 A7A0             (   monitor1v4.asm):02447                  STA      ,Y+                               ; STORE TO REGISTER RAM
EF14 5A               (   monitor1v4.asm):02448                  DECB
EF15 26F9             (   monitor1v4.asm):02449                  BNE      WRRLP
                      (   monitor1v4.asm):02450         ;
                      (   monitor1v4.asm):02451         ;  Return OK status
EF17 4F               (   monitor1v4.asm):02452         WRR80    CLRA
EF18 7EEFE2           (   monitor1v4.asm):02453                  JMP      SEND_STATUS
                      (   monitor1v4.asm):02454         
                      (   monitor1v4.asm):02455         ;===========================================================================
                      (   monitor1v4.asm):02456         ;
                      (   monitor1v4.asm):02457         ;  Run Target:  FN, len
                      (   monitor1v4.asm):02458         ;
                      (   monitor1v4.asm):02459         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02460         ;
EF1B                  (   monitor1v4.asm):02461         RUN_TARGET
                      (   monitor1v4.asm):02462         ;
                      (   monitor1v4.asm):02463         ;  Restore user's map
                      (   monitor1v4.asm):02464         ;*      LDA     REG_PAGE                ; USER'S PAGE
                      (   monitor1v4.asm):02465         ;*      STA     MAPIMG                  ; SET IMAGE
                      (   monitor1v4.asm):02466         ;*      STA     MAPREG                  ; SET MAPPING REGISTER
                      (   monitor1v4.asm):02467         ;
                      (   monitor1v4.asm):02468         ;  Switch to user stack
EF1B B6BFBF           (   monitor1v4.asm):02469                  LDA      REG_SP+1                          ; BACK TO USER STACK
EF1E F6BFBE           (   monitor1v4.asm):02470                  LDB      REG_SP
EF21 1F04             (   monitor1v4.asm):02471                  TFR      D,S                               ; TO S
                      (   monitor1v4.asm):02472         ;
                      (   monitor1v4.asm):02473         ;  Restore MD, as it affects stack building and RTI
                      (   monitor1v4.asm):02474         ;  Only bits 1 and 0 can be written, and only using LDMD #
                      (   monitor1v4.asm):02475         ;  It's time for some self-modifying code!  Build LDMD #xxx, RTS in RAM and call it.
EF23 CC113D           (   monitor1v4.asm):02476                  LDD      #$113D                            ; LDMD #imm
EF26 FDBF1E           (   monitor1v4.asm):02477                  STD      COMBUF+30                         ; Start code string
EF29 B6BFCC           (   monitor1v4.asm):02478                  LDA      REG_MD                            ; #imm is desired MD value
EF2C B7BF20           (   monitor1v4.asm):02479                  STA      COMBUF+32
EF2F 8639             (   monitor1v4.asm):02480                  LDA      #$39                              ; RTS
EF31 B7BF21           (   monitor1v4.asm):02481                  STA      COMBUF+33
EF34 BDBF1E           (   monitor1v4.asm):02482                  JSR      COMBUF+30
                      (   monitor1v4.asm):02483         ;
                      (   monitor1v4.asm):02484         ;  Restore V, which isn't on the stack
EF37 B6BFCE           (   monitor1v4.asm):02485                  LDA      REG_V+1
EF3A F6BFCD           (   monitor1v4.asm):02486                  LDB      REG_V
EF3D 1F07             (   monitor1v4.asm):02487                  TFR      D,V
                      (   monitor1v4.asm):02488         ;
                      (   monitor1v4.asm):02489         ;  Restore registers
EF3F B6BFD0           (   monitor1v4.asm):02490                  LDA      REG_PC+1                          ; MS USER PC FOR RTI
EF42 F6BFCF           (   monitor1v4.asm):02491                  LDB      REG_PC                            ; LS USER PC FOR RTI
EF45 3406             (   monitor1v4.asm):02492                  PSHS     D
                      (   monitor1v4.asm):02493         ;
EF47 B6BFC1           (   monitor1v4.asm):02494                  LDA      REG_U+1
EF4A F6BFC0           (   monitor1v4.asm):02495                  LDB      REG_U
EF4D 3406             (   monitor1v4.asm):02496                  PSHS     D
                      (   monitor1v4.asm):02497         ;
EF4F B6BFC3           (   monitor1v4.asm):02498                  LDA      REG_Y+1
EF52 F6BFC2           (   monitor1v4.asm):02499                  LDB      REG_Y
EF55 3406             (   monitor1v4.asm):02500                  PSHS     D
                      (   monitor1v4.asm):02501         ;
EF57 B6BFC5           (   monitor1v4.asm):02502                  LDA      REG_X+1
EF5A F6BFC4           (   monitor1v4.asm):02503                  LDB      REG_X
EF5D 3406             (   monitor1v4.asm):02504                  PSHS     D
                      (   monitor1v4.asm):02505         ;
EF5F B6BFCA           (   monitor1v4.asm):02506                  LDA      REG_DP
EF62 3402             (   monitor1v4.asm):02507                  PSHS     A
                      (   monitor1v4.asm):02508         ;
                      (   monitor1v4.asm):02509         ;  Restore W from memory (not used between here and RTI)
EF64 11B6BFC7         (   monitor1v4.asm):02510                  LDE      REG_E
EF68 11F6BFC6         (   monitor1v4.asm):02511                  LDF      REG_F
EF6C B6BFCC           (   monitor1v4.asm):02512                  LDA      REG_MD
EF6F 8501             (   monitor1v4.asm):02513                  BITA     #1
EF71 2702             (   monitor1v4.asm):02514                  BEQ      RT_10                             ; jump if 6809 mode
EF73 1038             (   monitor1v4.asm):02515                  PSHSW                                      ; else push W on stack for RTI
EF75                  (   monitor1v4.asm):02516         RT_10
                      (   monitor1v4.asm):02517         ;
EF75 B6BFC8           (   monitor1v4.asm):02518                  LDA      REG_B
EF78 3402             (   monitor1v4.asm):02519                  PSHS     A
                      (   monitor1v4.asm):02520         ;
EF7A B6BFC9           (   monitor1v4.asm):02521                  LDA      REG_A
EF7D 3402             (   monitor1v4.asm):02522                  PSHS     A
                      (   monitor1v4.asm):02523         ;
EF7F B6BFCB           (   monitor1v4.asm):02524                  LDA      REG_CC                            ; SAVE USER CONDITION CODES FOR RTI
EF82 8A80             (   monitor1v4.asm):02525                  ORA      #CC_E                             ; _MUST_ BE "ALL REGS PUSHED"
EF84 3402             (   monitor1v4.asm):02526                  PSHS     A
                      (   monitor1v4.asm):02527         ;
                      (   monitor1v4.asm):02528         ;  Return to user (conditioned by MD.0)
EF86 3B               (   monitor1v4.asm):02529                  RTI
                      (   monitor1v4.asm):02530         ;
                      (   monitor1v4.asm):02531         ;===========================================================================
                      (   monitor1v4.asm):02532         ;
                      (   monitor1v4.asm):02533         ;  Common continue point for all monitor entrances
                      (   monitor1v4.asm):02534         ;  SP = user stack
EF87                  (   monitor1v4.asm):02535         ENTER_MON
EF87 1F40             (   monitor1v4.asm):02536                  TFR      S,D                               ; USER STACK POINTER
EF89 B7BFBF           (   monitor1v4.asm):02537                  STA      REG_SP+1                          ; SAVE USER'S STACK POINTER (MSB)
EF8C F7BFBE           (   monitor1v4.asm):02538                  STB      REG_SP                            ; LSB
                      (   monitor1v4.asm):02539         ;
                      (   monitor1v4.asm):02540         ;  Change to our own stack
EF8F 10CEBFAB         (   monitor1v4.asm):02541                  LDS      #MONSTACK                         ; AND USE OURS INSTEAD
                      (   monitor1v4.asm):02542         ;
                      (   monitor1v4.asm):02543         ;  Operating system variables
                      (   monitor1v4.asm):02544         ;*      LDA     MAPIMG                  ; GET CURRENT USER MAP
EF93 8600             (   monitor1v4.asm):02545                  LDA      #0                                ; ... OR ZERO IF UNMAPPED TARGET
EF95 B7BFBD           (   monitor1v4.asm):02546                  STA      REG_PAGE                          ; SAVE USER'S PAGE
                      (   monitor1v4.asm):02547         ;
                      (   monitor1v4.asm):02548         ;  Return registers to master
EF98 7EEEF4           (   monitor1v4.asm):02549                  JMP      RETURN_REGS
                      (   monitor1v4.asm):02550         
                      (   monitor1v4.asm):02551         ;===========================================================================
                      (   monitor1v4.asm):02552         ;
                      (   monitor1v4.asm):02553         ;  Set target byte(s):  FN, len { (page, alow, ahigh, data), (...)... }
                      (   monitor1v4.asm):02554         ;
                      (   monitor1v4.asm):02555         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02556         ;
                      (   monitor1v4.asm):02557         ;  Return has FN, len, (data from memory locations)
                      (   monitor1v4.asm):02558         ;
                      (   monitor1v4.asm):02559         ;  If error in insert (memory not writable), abort to return short data
                      (   monitor1v4.asm):02560         ;
                      (   monitor1v4.asm):02561         ;  This function is used primarily to set and clear breakpoints
                      (   monitor1v4.asm):02562         ;
                      (   monitor1v4.asm):02563         ;  Uses 1 byte of stack
                      (   monitor1v4.asm):02564         ;
EF9B                  (   monitor1v4.asm):02565         SET_BYTES
EF9B CEBF01           (   monitor1v4.asm):02566                  LDU      #COMBUF+1                         ; POINTER TO RETURN BUFFER
EF9E 8600             (   monitor1v4.asm):02567                  LDA      #0
EFA0 A7C0             (   monitor1v4.asm):02568                  STA      ,U+                               ; SET RETURN COUNT AS ZERO
EFA2 54               (   monitor1v4.asm):02569                  LSRB
EFA3 54               (   monitor1v4.asm):02570                  LSRB                                       ; LEN/4 = NUMBER OF BYTES TO SET
EFA4 2720             (   monitor1v4.asm):02571                  BEQ      SB99                              ; JIF NO BYTES (COMBUF+1 = 0)
                      (   monitor1v4.asm):02572         ;
                      (   monitor1v4.asm):02573         ;  Loop on inserting bytes
EFA6 3404             (   monitor1v4.asm):02574         SB10     PSHS     B                                 ; SAVE LOOP COUNTER
                      (   monitor1v4.asm):02575         ;
                      (   monitor1v4.asm):02576         ;  Set map
                      (   monitor1v4.asm):02577         ;;;;    LDA     0,X
                      (   monitor1v4.asm):02578         ;;;;    STA     MAPIMG
                      (   monitor1v4.asm):02579         ;;;;    STA     MAPREG
                      (   monitor1v4.asm):02580         ;
                      (   monitor1v4.asm):02581         ;  Get address
EFA8 A602             (   monitor1v4.asm):02582                  LDA      2,X                               ; MSB OF ADDRESS IN A
EFAA E601             (   monitor1v4.asm):02583                  LDB      1,X                               ; LSB OF ADDRESS IN B
EFAC 1F02             (   monitor1v4.asm):02584                  TFR      D,Y                               ; MEMORY ADDRESS IN Y
                      (   monitor1v4.asm):02585         ;
                      (   monitor1v4.asm):02586         ;  Read current data at byte location
EFAE A620             (   monitor1v4.asm):02587                  LDA      0,Y
                      (   monitor1v4.asm):02588         ;
                      (   monitor1v4.asm):02589         ;  Insert new data at byte location
EFB0 E603             (   monitor1v4.asm):02590                  LDB      3,X                               ; GET BYTE TO STORE
EFB2 E720             (   monitor1v4.asm):02591                  STB      0,Y                               ; WRITE TARGET MEMORY
                      (   monitor1v4.asm):02592         ;
                      (   monitor1v4.asm):02593         ;  Verify write
EFB4 E120             (   monitor1v4.asm):02594                  CMPB     0,Y                               ; READ TARGET MEMORY
EFB6 3504             (   monitor1v4.asm):02595                  PULS     B                                 ; RESTORE LOOP COUNT, CC'S INTACT
EFB8 260C             (   monitor1v4.asm):02596                  BNE      SB90                              ; BR IF INSERT FAILED: ABORT
                      (   monitor1v4.asm):02597         ;
                      (   monitor1v4.asm):02598         ;  Save target byte in return buffer
EFBA A7C0             (   monitor1v4.asm):02599                  STA      ,U+
EFBC 7CBF01           (   monitor1v4.asm):02600                  INC      COMBUF+1                          ; COUNT ONE RETURN BYTE
                      (   monitor1v4.asm):02601         ;
                      (   monitor1v4.asm):02602         ;  Loop for next byte
EFBF 3004             (   monitor1v4.asm):02603                  LEAX     4,X                               ; STEP TO NEXT BYTE SPECIFIER
EFC1 F1BF01           (   monitor1v4.asm):02604                  CMPB     COMBUF+1
EFC4 26E0             (   monitor1v4.asm):02605                  BNE      SB10                              ; *LOOP FOR ALL BYTES
                      (   monitor1v4.asm):02606         ;
                      (   monitor1v4.asm):02607         ;  Return buffer with data from byte locations
EFC6                  (   monitor1v4.asm):02608         SB90
                      (   monitor1v4.asm):02609         ;
                      (   monitor1v4.asm):02610         ;  Compute checksum on buffer, and send to master, then return
EFC6 7EEFEC           (   monitor1v4.asm):02611         SB99     JMP      SEND
                      (   monitor1v4.asm):02612         
                      (   monitor1v4.asm):02613         ;===========================================================================
                      (   monitor1v4.asm):02614         ;
                      (   monitor1v4.asm):02615         ;  Input from port:  FN, len, PortAddressLo, PAhi (=0)
                      (   monitor1v4.asm):02616         ;
                      (   monitor1v4.asm):02617         ;  While the 6809 has no input or output instructions, we retain these
                      (   monitor1v4.asm):02618         ;  to allow write-without-verify
                      (   monitor1v4.asm):02619         ;
                      (   monitor1v4.asm):02620         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02621         ;
EFC9                  (   monitor1v4.asm):02622         IN_PORT
                      (   monitor1v4.asm):02623         ;
                      (   monitor1v4.asm):02624         ;  Get port address
EFC9 A601             (   monitor1v4.asm):02625                  LDA      1,X                               ; MSB OF ADDRESS IN A
EFCB E600             (   monitor1v4.asm):02626                  LDB      0,X                               ; LSB OF ADDRESS IN B
EFCD 1F02             (   monitor1v4.asm):02627                  TFR      D,Y                               ; MEMORY ADDRESS IN Y
                      (   monitor1v4.asm):02628         ;
                      (   monitor1v4.asm):02629         ;  Read the requested byte from local memory
EFCF A620             (   monitor1v4.asm):02630                  LDA      0,Y
                      (   monitor1v4.asm):02631         ;
                      (   monitor1v4.asm):02632         ;  Return byte read as "status"
EFD1 7EEFE2           (   monitor1v4.asm):02633                  JMP      SEND_STATUS
                      (   monitor1v4.asm):02634         
                      (   monitor1v4.asm):02635         ;===========================================================================
                      (   monitor1v4.asm):02636         ;
                      (   monitor1v4.asm):02637         ;  Output to port  FN, len, PortAddressLo, PAhi (=0), data
                      (   monitor1v4.asm):02638         ;
                      (   monitor1v4.asm):02639         ;  Entry with A=function code, B=data size, X=COMBUF+2
                      (   monitor1v4.asm):02640         ;
EFD4                  (   monitor1v4.asm):02641         OUT_PORT
                      (   monitor1v4.asm):02642         ;
                      (   monitor1v4.asm):02643         ;  Get port address
EFD4 A601             (   monitor1v4.asm):02644                  LDA      1,X                               ; MSB OF ADDRESS IN A
EFD6 E600             (   monitor1v4.asm):02645                  LDB      0,X                               ; LSB OF ADDRESS IN B
EFD8 1F02             (   monitor1v4.asm):02646                  TFR      D,Y                               ; MEMORY ADDRESS IN Y
                      (   monitor1v4.asm):02647         ;
                      (   monitor1v4.asm):02648         ;  Get data
EFDA A602             (   monitor1v4.asm):02649                  LDA      2,X
                      (   monitor1v4.asm):02650         ;
                      (   monitor1v4.asm):02651         ;  Write value to port
EFDC A720             (   monitor1v4.asm):02652                  STA      0,Y
                      (   monitor1v4.asm):02653         ;
                      (   monitor1v4.asm):02654         ;  Do not read port to verify (some I/O devices don't like it)
                      (   monitor1v4.asm):02655         ;
                      (   monitor1v4.asm):02656         ;  Return status of OK
EFDE 4F               (   monitor1v4.asm):02657                  CLRA
EFDF 7EEFE2           (   monitor1v4.asm):02658                  JMP      SEND_STATUS
                      (   monitor1v4.asm):02659         
                      (   monitor1v4.asm):02660         ;===========================================================================
                      (   monitor1v4.asm):02661         ;  Build status return with value from "A"
                      (   monitor1v4.asm):02662         ;
EFE2                  (   monitor1v4.asm):02663         SEND_STATUS
EFE2 B7BF02           (   monitor1v4.asm):02664                  STA      COMBUF+2                          ; SET STATUS
EFE5 8601             (   monitor1v4.asm):02665                  LDA      #1
EFE7 B7BF01           (   monitor1v4.asm):02666                  STA      COMBUF+1                          ; SET LENGTH
EFEA 2000             (   monitor1v4.asm):02667                  BRA      SEND
                      (   monitor1v4.asm):02668         
                      (   monitor1v4.asm):02669         ;===========================================================================
                      (   monitor1v4.asm):02670         ;  Append checksum to COMBUF and send to master
                      (   monitor1v4.asm):02671         ;
EFEC BDF004           (   monitor1v4.asm):02672         SEND     JSR      CHECKSUM                          ; GET A=CHECKSUM, X->checksum location
EFEF 40               (   monitor1v4.asm):02673                  NEGA
EFF0 A700             (   monitor1v4.asm):02674                  STA      0,X                               ; STORE NEGATIVE OF CHECKSUM
                      (   monitor1v4.asm):02675         ;
                      (   monitor1v4.asm):02676         ;  Send buffer to master
EFF2 8EBF00           (   monitor1v4.asm):02677                  LDX      #COMBUF                           ; POINTER TO DATA
EFF5 E601             (   monitor1v4.asm):02678                  LDB      1,X                               ; LENGTH OF DATA
EFF7 CB03             (   monitor1v4.asm):02679                  ADDB     #3                                ; PLUS FUNCTION, LENGTH, CHECKSUM
EFF9 A680             (   monitor1v4.asm):02680         SND10    LDA      ,X+
EFFB BDED22           (   monitor1v4.asm):02681                  JSR      DBPUTCH                           ; SEND A BYTE
EFFE 5A               (   monitor1v4.asm):02682                  DECB
EFFF 26F8             (   monitor1v4.asm):02683                  BNE      SND10
F001 7EEE14           (   monitor1v4.asm):02684                  JMP      MAIN                              ; BACK TO MAIN LOOP
                      (   monitor1v4.asm):02685         
                      (   monitor1v4.asm):02686         ;===========================================================================
                      (   monitor1v4.asm):02687         ;  Compute checksum on COMBUF.  COMBUF+1 has length of data,
                      (   monitor1v4.asm):02688         ;  Also include function byte and length byte
                      (   monitor1v4.asm):02689         ;
                      (   monitor1v4.asm):02690         ;  Returns:
                      (   monitor1v4.asm):02691         ;       A = checksum
                      (   monitor1v4.asm):02692         ;       X = pointer to next byte in buffer (checksum location)
                      (   monitor1v4.asm):02693         ;       B is scratched
                      (   monitor1v4.asm):02694         ;
F004                  (   monitor1v4.asm):02695         CHECKSUM
F004 8EBF00           (   monitor1v4.asm):02696                  LDX      #COMBUF                           ; pointer to buffer
F007 E601             (   monitor1v4.asm):02697                  LDB      1,X                               ; length of message
F009 CB02             (   monitor1v4.asm):02698                  ADDB     #2                                ; plus function, length
F00B 8600             (   monitor1v4.asm):02699                  LDA      #0                                ; init checksum to 0
F00D AB80             (   monitor1v4.asm):02700         CHK10    ADDA     ,X+
F00F 5A               (   monitor1v4.asm):02701                  DECB
F010 26FB             (   monitor1v4.asm):02702                  BNE      CHK10                             ; loop for all
F012 39               (   monitor1v4.asm):02703                  RTS                                        ; return with checksum in A
                      (   monitor1v4.asm):02704         
                      (   monitor1v4.asm):02705         ;**********************************************************************
                      (   monitor1v4.asm):02706         ;
                      (   monitor1v4.asm):02707         ;  Interrupt handlers to catch unused interrupts and traps
                      (   monitor1v4.asm):02708         ;  Registers are stacked.  Jump through RAM vector using X, type in A
                      (   monitor1v4.asm):02709         ;
                      (   monitor1v4.asm):02710         ;  This will affect only interrupt routines looking for register values!
                      (   monitor1v4.asm):02711         ;
                      (   monitor1v4.asm):02712         ;  Our default handler uses the code in "A" as the processor state to be
                      (   monitor1v4.asm):02713         ;  passed back to the host.
                      (   monitor1v4.asm):02714         ;
                      (   monitor1v4.asm):02715         
                      (   monitor1v4.asm):02716         ;  This is "reserved" on 6809
                      (   monitor1v4.asm):02717         ;  Used for Divide-by-zero and Illegal-instruction on 6309
F013 8607             (   monitor1v4.asm):02718         TRAP_ENT LDA      #7
F015 BEBF83           (   monitor1v4.asm):02719                  LDX      RAMVEC+0
F018 6E00             (   monitor1v4.asm):02720                  JMP      0,X
                      (   monitor1v4.asm):02721         ;
F01A 8606             (   monitor1v4.asm):02722         SWI3_ENT LDA      #6
F01C BEBF85           (   monitor1v4.asm):02723                  LDX      RAMVEC+2
F01F 6E00             (   monitor1v4.asm):02724                  JMP      0,X
                      (   monitor1v4.asm):02725         ;
F021 8605             (   monitor1v4.asm):02726         SWI2_ENT LDA      #5
F023 BEBF87           (   monitor1v4.asm):02727                  LDX      RAMVEC+4
F026 6E00             (   monitor1v4.asm):02728                  JMP      0,X
                      (   monitor1v4.asm):02729         ;
                      (   monitor1v4.asm):02730         ;  Will have only PC and CC's pushed unless we were waiting for an interrupt
                      (   monitor1v4.asm):02731         ;  or MD.1 is true.  Use CC's E bit to distinguish.
                      (   monitor1v4.asm):02732         ;  Push all registers here for common entry (else we can't use our RAM vector)
F028 B7BFC9           (   monitor1v4.asm):02733         FIRQ_ENT STA      REG_A                             ; SAVE A REG
F02B 3502             (   monitor1v4.asm):02734                  PULS     A                                 ; GET CC'S FROM STACK
F02D 8580             (   monitor1v4.asm):02735                  BITA     #CC_E
F02F 2629             (   monitor1v4.asm):02736                  BNE      FIRQ9                             ; BR IF ALL REGISTERS PUSHED ALREADY
                      (   monitor1v4.asm):02737         
                      (   monitor1v4.asm):02738         ; CC.E was not set which means that regMD bit2 was not set and that bit in
                      (   monitor1v4.asm):02739         ; the image should be cleared. If CC.E is set, we can't tell what set it, a
                      (   monitor1v4.asm):02740         ; direct command, CWAI, or bit 1 of regMD.
                      (   monitor1v4.asm):02741         ;
                      (   monitor1v4.asm):02742         ; Push registers as if CC.E had been set
                      (   monitor1v4.asm):02743         ;  If 6809 mode, stack needs CC A B DP XH XL YH YL UH UL PCH PCL
                      (   monitor1v4.asm):02744         ;  If 6309 mode, stack needs CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      (   monitor1v4.asm):02745         ;
F031 7FBFB9           (   monitor1v4.asm):02746                  CLR      E_FLAG
F034 B6BFCC           (   monitor1v4.asm):02747                  LDA      REG_MD
F037 84FD             (   monitor1v4.asm):02748                  ANDA     #$FD                              ; BIT1 must be clear, else all regs would have been pushed
F039 B7BFCC           (   monitor1v4.asm):02749                  STA      REG_MD
F03C 3478             (   monitor1v4.asm):02750                  PSHS     U,Y,X,DP                          ; push regs next below PC
                      (   monitor1v4.asm):02751         
F03E 10B7BFC6         (   monitor1v4.asm):02752                  STW      REG_F                             ; MD_TEST will not preserve regW
F042 BDF083           (   monitor1v4.asm):02753                  JSR      MD_TEST
F045 3401             (   monitor1v4.asm):02754                  PSHS     CC                                ; Save result
F047 10B6BFC6         (   monitor1v4.asm):02755                  LDW      REG_F                             ; Recover regW
F04B 3501             (   monitor1v4.asm):02756                  PULS     CC                                ; Recover result of test
F04D 2602             (   monitor1v4.asm):02757                  BNE      FE1
F04F 1038             (   monitor1v4.asm):02758                  PSHSW
F051 3404             (   monitor1v4.asm):02759         FE1      PSHS     B
F053 F6BFC9           (   monitor1v4.asm):02760                  LDB      REG_A
F056 3404             (   monitor1v4.asm):02761                  PSHS     B
F058 8A80             (   monitor1v4.asm):02762                  ORA      #CC_E                             ; SET AS "ALL REGS PUSHED"
                      (   monitor1v4.asm):02763         
F05A 7DBFB9           (   monitor1v4.asm):02764         FIRQ9    TST      E_FLAG
F05D 2608             (   monitor1v4.asm):02765                  BNE      FIRQ9B
F05F F6BFCC           (   monitor1v4.asm):02766                  LDB      REG_MD                            ; We got here with E_FLAG clear and CC.E set which
F062 CA02             (   monitor1v4.asm):02767                  ORB      #2                                ; means regMD bit2 must be set.
F064 F7BFCC           (   monitor1v4.asm):02768                  STB      REG_MD
F067 3402             (   monitor1v4.asm):02769         FIRQ9B   PSHS     A                                 ; REPLACE CC'S
F069 8604             (   monitor1v4.asm):02770                  LDA      #4
F06B BEBF89           (   monitor1v4.asm):02771                  LDX      RAMVEC+6
F06E 6E00             (   monitor1v4.asm):02772                  JMP      0,X
                      (   monitor1v4.asm):02773         ;
F070 8603             (   monitor1v4.asm):02774         IRQ_ENT  LDA      #3
F072 BEBF8B           (   monitor1v4.asm):02775                  LDX      RAMVEC+8
F075 6E00             (   monitor1v4.asm):02776                  JMP      0,X
                      (   monitor1v4.asm):02777         ;
F077 8602             (   monitor1v4.asm):02778         NMI_ENT  LDA      #2
F079 BEBF8F           (   monitor1v4.asm):02779                  LDX      RAMVEC+12
F07C 6E00             (   monitor1v4.asm):02780                  JMP      0,X
                      (   monitor1v4.asm):02781         ;
F07E 8601             (   monitor1v4.asm):02782         SWI_ENT  LDA      #1
F080 7EEDA2           (   monitor1v4.asm):02783                  JMP      INT_ENTRY
                      (   monitor1v4.asm):02784         ;
                      (   monitor1v4.asm):02785         ;============================================================================
                      (   monitor1v4.asm):02786         ; TEST FOR BIT0 OF regMD:
                      (   monitor1v4.asm):02787         ; Exit emulation mode: regW=$1234
                      (   monitor1v4.asm):02788         ;      native    mode: regW=$0000
                      (   monitor1v4.asm):02789         ;
                      (   monitor1v4.asm):02790         ; Preserves W and V.  Other registers destroyed.
                      (   monitor1v4.asm):02791         ;
F083                  (   monitor1v4.asm):02792         MD_TEST
F083 1038             (   monitor1v4.asm):02793                  PSHSW
                      (   monitor1v4.asm):02794         ;
                      (   monitor1v4.asm):02795         ; If 6809 mode, RTI will pop 12 bytes: CC A B DP XH XL YH YL UH UL PCH PCL
                      (   monitor1v4.asm):02796         ; If 6309 mode, RTI will pop 14 bytes: CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      (   monitor1v4.asm):02797         ;
                      (   monitor1v4.asm):02798         ; Initialize TEST_STACK used for fake RTI. The return address will be MD_RETURN
                      (   monitor1v4.asm):02799         ; in both emulation and native modes. If native mode, regW will be cleared.
                      (   monitor1v4.asm):02800         ;
F085 8EBFAB           (   monitor1v4.asm):02801                  LDX      #TEST_STACK
                      (   monitor1v4.asm):02802         
F088 8680             (   monitor1v4.asm):02803                  LDA      #$80
F08A A780             (   monitor1v4.asm):02804                  STA      ,X+                               ; CC with E set
                      (   monitor1v4.asm):02805         
F08C C609             (   monitor1v4.asm):02806                  LDB      #9
F08E 6F80             (   monitor1v4.asm):02807         RES11    CLR      ,X+                               ; zeros for other registers, including W
F090 5A               (   monitor1v4.asm):02808                  DECB
F091 26FB             (   monitor1v4.asm):02809                  BNE      RES11
                      (   monitor1v4.asm):02810         
F093 CCF0A7           (   monitor1v4.asm):02811                  LDD      #MD_RETURN
F096 ED81             (   monitor1v4.asm):02812                  STD      ,X++                              ; 6809 return address, or 6309 U
F098 ED81             (   monitor1v4.asm):02813                  STD      ,X++                              ; 6309 return address, or past 6809 stack
                      (   monitor1v4.asm):02814         
F09A 10FFBFBA         (   monitor1v4.asm):02815                  STS      S_IMAGE
F09E 10CEBFAB         (   monitor1v4.asm):02816                  LDS      #TEST_STACK
F0A2 10861234         (   monitor1v4.asm):02817                  LDW      #$1234
F0A6 3B               (   monitor1v4.asm):02818                  RTI                                        ; if 6309 mode, W gets 0; else unchanged
                      (   monitor1v4.asm):02819         
F0A7                  (   monitor1v4.asm):02820         MD_RETURN
F0A7 10FEBFBA         (   monitor1v4.asm):02821                  LDS      S_IMAGE
F0AB 105D             (   monitor1v4.asm):02822                  TSTW                                       ; adjust CC.Z: set if 6309 mode
F0AD 1039             (   monitor1v4.asm):02823                  PULSW
F0AF 39               (   monitor1v4.asm):02824                  RTS
                      (   monitor1v4.asm):02825                  
                      (   monitor1v4.asm):02826         ;======================================================================
                      (   monitor1v4.asm):02827         ;  END OF 6309 Debug monitor for use with NOICE09
                      (   monitor1v4.asm):02828         ;  Copyright (c) 1992-2006 by John Hartman
                      (   monitor1v4.asm):02829         ;======================================================================
                      (   monitor1v4.asm):02830         
                      (   monitor1v4.asm):02831         
                      (   monitor1v4.asm):02832         ;;======================================================================
                      (   monitor1v4.asm):02833         ;; WOZMON RESIDENT MONITOR
                      (   monitor1v4.asm):02834         ;;======================================================================
                      (   monitor1v4.asm):02835         ; This is adapted from Jeff Tranter's work, and is a port of WOZMON to
                      (   monitor1v4.asm):02836         ; my HD6309 SBC. Jeff's work can be found here:
                      (   monitor1v4.asm):02837         ; https://github.com/jefftranter/6809/blob/master/sbc/wozmon/wozmon.asm
                      (   monitor1v4.asm):02838         ;
                      (   monitor1v4.asm):02839         ; This code uses SCC UART functions that are already present elsewhere
                      (   monitor1v4.asm):02840         ; in this ROM. I've tweaked it a bit in terms of cleanup and taking
                      (   monitor1v4.asm):02841         ; advantage of 6809/6309 architecture. I've added an "X" command to
                      (   monitor1v4.asm):02842         ; invoke an S-Record/Intel Hex loader (inspired by Dave Dunfield's
                      (   monitor1v4.asm):02843         ; 6809 monitor), an "N" command to invoke the ROM resident
                      (   monitor1v4.asm):02844         ; NoICE debugger, and an "M" command to invoke MSBASIC (resident in the
                      (   monitor1v4.asm):02845         ; alternate ROM bank). Finally, I added a crude 'flow control' to the
                      (   monitor1v4.asm):02846         ; NXTPRNT function, to allow pausing (^S), exit to newline (^C), and
                      (   monitor1v4.asm):02847         ; line-by-line (SPACE) during the dump. As such, the code is now much
                      (   monitor1v4.asm):02848         ; larger than the 256 bytes that Woz's original 6502 occupied!
                      (   monitor1v4.asm):02849         ;
                      (   monitor1v4.asm):02850         ; It was fun to study this old code, and I added some more comments to
                      (   monitor1v4.asm):02851         ; it to help w/ readability. I've migrated the syntax to that of William
                      (   monitor1v4.asm):02852         ; Astle's LWTOOLS 6809/6309 toolchain, which can be found here:
                      (   monitor1v4.asm):02853         ; http://www.lwtools.ca/
                      (   monitor1v4.asm):02854         ;
                      (   monitor1v4.asm):02855         ;***********************************************************************
                      (   monitor1v4.asm):02856         ;
                      (   monitor1v4.asm):02857         ; Following are notes from Jeff Tranter on this:
                      (   monitor1v4.asm):02858         ;
                      (   monitor1v4.asm):02859         ; This is a port of the 6800 version of Woz Mon to my 6809-based Single
                      (   monitor1v4.asm):02860         ; Board Computer. It was converted to 6809 instructions as well as
                      (   monitor1v4.asm):02861         ; ported to use the 6850 ACIA for input/output.
                      (   monitor1v4.asm):02862         ;
                      (   monitor1v4.asm):02863         ; The original 6800 port came from here: https://pastebin.com/TSM2DdRL
                      (   monitor1v4.asm):02864         ;
                      (   monitor1v4.asm):02865         ; Note: The code internally converts all characters to high ASCII (bit
                      (   monitor1v4.asm):02866         ; 7 = 1) because the Apple 1 used this format and the program logic is
                      (   monitor1v4.asm):02867         ; dependent on it in several places.
                      (   monitor1v4.asm):02868         ;
                      (   monitor1v4.asm):02869         ; The code is not quite small enough to fit in 256 bytes as the
                      (   monitor1v4.asm):02870         ; original 6502 and 6800 versions did.
                      (   monitor1v4.asm):02871         ;
                      (   monitor1v4.asm):02872         ;***********************************************************************
                      (   monitor1v4.asm):02873         ;
                      (   monitor1v4.asm):02874         ; This is a rewrite of the Apple 1 monitor to run on an MC6800
                      (   monitor1v4.asm):02875         ; microprocessor, rather than the MCS6502 microprocessor that
                      (   monitor1v4.asm):02876         ; was standard.  This source code will assemble with the
                      (   monitor1v4.asm):02877         ; AS Macro Assembler; with minor changes it should assemble
                      (   monitor1v4.asm):02878         ; with any MC6800 assembler.
                      (   monitor1v4.asm):02879         
                      (   monitor1v4.asm):02880         ; Copyright 2011 Eric Smith <eric@brouhaha.com>
                      (   monitor1v4.asm):02881         ;
                      (   monitor1v4.asm):02882         ; This program is free software; you can redistribute and/or modify it
                      (   monitor1v4.asm):02883         ; under the terms of the GNU General Public License version 3 as
                      (   monitor1v4.asm):02884         ; published by the Free Software Foundation.
                      (   monitor1v4.asm):02885         ;
                      (   monitor1v4.asm):02886         ; This program is distributed in the hope that it will be useful, but
                      (   monitor1v4.asm):02887         ; WITHOUT ANY WARRANTY; without even the implied warranty of
                      (   monitor1v4.asm):02888         ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                      (   monitor1v4.asm):02889         ; General Public License for more details.
                      (   monitor1v4.asm):02890         ;
                      (   monitor1v4.asm):02891         ; The text of the license may be found online at:
                      (   monitor1v4.asm):02892         ;     http://www.brouhaha.com/~eric/software/GPLv3
                      (   monitor1v4.asm):02893         ; or:
                      (   monitor1v4.asm):02894         ;     http://www.gnu.org/licenses/gpl-3.0.txt
                      (   monitor1v4.asm):02895         
                      (   monitor1v4.asm):02896         ; relative addresses of program variables
                      (   monitor1v4.asm):02897         
                      (   monitor1v4.asm):02898         ; first, determine WOZ_RAM absolute offset
     BF00             (   monitor1v4.asm):02899         W_OFFS   EQU      WOZ_RAM % 256
                      (   monitor1v4.asm):02900         
                      (   monitor1v4.asm):02901         ; next, establish the amount of line input buffer to allocate
     0078             (   monitor1v4.asm):02902         W_INLEN  EQU      120                               ; line input buffer length
                      (   monitor1v4.asm):02903         
                      (   monitor1v4.asm):02904         ; then, determine xx,U offset for XAM variable, because this gets used w/o DP reg, also
     0078             (   monitor1v4.asm):02905         W_XAM    EQU      W_INLEN                           
                      (   monitor1v4.asm):02906         
                      (   monitor1v4.asm):02907         ; finally, determine DP offset pointers to temporary variables
     BF78             (   monitor1v4.asm):02908         W_dXAM   EQU      W_OFFS+W_INLEN                    ; XAM address (+120/121)
     BF7A             (   monitor1v4.asm):02909         W_dST    EQU      W_OFFS+W_INLEN+2                  ; STOR address  (+122/+123)   [A3 in new monitor]
     BF7C             (   monitor1v4.asm):02910         W_dMODE  EQU      W_OFFS+W_INLEN+4                  ; 'mode' is XAM, STOR, BLOCK XAM (+124)
     BF7D             (   monitor1v4.asm):02911         W_dTEMP  EQU      W_OFFS+W_INLEN+5                  ; temporary storage (+125)
     002E             (   monitor1v4.asm):02912         DOT      EQU      '.'
     00BA             (   monitor1v4.asm):02913         HI_COL   EQU      ':'+$80                           ; msb set Colon
     00D2             (   monitor1v4.asm):02914         HI_R     EQU      'R'+$80                           ; msb set "R" - RUN command
     00D8             (   monitor1v4.asm):02915         HI_X     EQU      'X'+$80                           ; msb set "X" - HEX LOAD command
     00CD             (   monitor1v4.asm):02916         HI_M     EQU      'M'+$80                           ; msb set "M" - MS BASIC command
     00CE             (   monitor1v4.asm):02917         HI_N     EQU      'N'+$80                           ; msb set "N" - NOICE command
     0003             (   monitor1v4.asm):02918         CTL_C    EQU      'C'-$40                           ; control-C
     0013             (   monitor1v4.asm):02919         CTL_S    EQU      'S'-$40                           ; control-S
     0008             (   monitor1v4.asm):02920         CTL_H    EQU      'H'-$40                           ; control-H
     0018             (   monitor1v4.asm):02921         CTL_X    EQU      'X'-$40                           ; control-X
     007F             (   monitor1v4.asm):02922         DEL      EQU      127                               ; "Delete"
     001B             (   monitor1v4.asm):02923         ESC      EQU      '['-$40                           ; ESCape
                      (   monitor1v4.asm):02924         
                      (   monitor1v4.asm):02925         ;; WOZMON - primary entry point
F0B0                  (   monitor1v4.asm):02926         WOZMON:
F0B0 10CEBF00         (   monitor1v4.asm):02927                  LDS      #INITSTACK                        ; grow stack downward from reserved RAM
F0B4 CEBF00           (   monitor1v4.asm):02928                  LDU      #WOZ_RAM                          ; point U at beginning of WOZ_RAM block
F0B7 30C878           (   monitor1v4.asm):02929         W?Z1     LEAX     W_INLEN,U                         ; absolute address of FIRST variable in X
F0BA 1F1B             (   monitor1v4.asm):02930                  TFR      X,DP                              ; copy the MSB of the address to DP register
F0BC 105F             (   monitor1v4.asm):02931                  CLRW                                       ; reset WORD value
F0BE 109778           (   monitor1v4.asm):02932                  STW      <W_dXAM                           ; reset XAM address
F0C1 10977A           (   monitor1v4.asm):02933                  STW      <W_dST                            ; reset STORE address
F0C4 2000             (   monitor1v4.asm):02934                  BRA      WOZ3                              ; enter monitor main loop
F0C6                  (   monitor1v4.asm):02935         WOZ3:
F0C6 8D23             (   monitor1v4.asm):02936                  BSR      W_GETLINE                         ; get an input line
F0C8 29FC             (   monitor1v4.asm):02937                  BVS      WOZ3                              ;   CANCEL - repeat input
F0CA 8D39             (   monitor1v4.asm):02938                  BSR      W_PARSE                           ; parse it
F0CC 20F8             (   monitor1v4.asm):02939                  BRA      WOZ3                              ; loop forever
                      (   monitor1v4.asm):02940         
                      (   monitor1v4.asm):02941         ; Get a line of input from the keyboard, echoing to display.
                      (   monitor1v4.asm):02942         ; Normally enter at ESCAPE or GETLINE. Handle ^H and DEL as
                      (   monitor1v4.asm):02943         ; 'backspace' and ^X and ESC as 'cancel'. Otherwise accumulate 
                      (   monitor1v4.asm):02944         ; characters in the buffer. Exit when a CR is received, and
                      (   monitor1v4.asm):02945         ; auto-cancel and resrtart when buffer length exceeds W_INLEN.
                      (   monitor1v4.asm):02946         ;
                      (   monitor1v4.asm):02947         ; inputs: U is pointer to line buffer 
                      (   monitor1v4.asm):02948         ; return: B is the index into the buffer at last character position
                      (   monitor1v4.asm):02949         ;         A is the last character received (either CR or \)
                      (   monitor1v4.asm):02950         ;         V = 0 CR received
                      (   monitor1v4.asm):02951         ;         V = 1 CANCEL or >W_INLEN characters received
                      (   monitor1v4.asm):02952         
F0CE                  (   monitor1v4.asm):02953         W_NOTCR:
F0CE 8108             (   monitor1v4.asm):02954                  CMPA     #CTL_H                            ; CTRL-H? ["backspace"]
F0D0 2723             (   monitor1v4.asm):02955                  BEQ      W_BACKSPC                         ;   yes, back up a character
F0D2 817F             (   monitor1v4.asm):02956                  CMPA     #DEL                              ; DEL? ["delete"]
F0D4 271F             (   monitor1v4.asm):02957                  BEQ      W_BACKSPC                         ;   yes, back up a character
F0D6 8118             (   monitor1v4.asm):02958                  CMPA     #CTL_X                            ; CTRL-X? ["cancel"]
F0D8 2709             (   monitor1v4.asm):02959                  BEQ      W_CANCEL                          ;   yes, abort line
F0DA 811B             (   monitor1v4.asm):02960                  CMPA     #ESC                              ; ESC? ["escape"]
F0DC 2705             (   monitor1v4.asm):02961                  BEQ      W_CANCEL
F0DE 5C               (   monitor1v4.asm):02962                  INCB                                       ; leave in buffer and advance text index.
F0DF C178             (   monitor1v4.asm):02963                  CMPB     #W_INLEN                          ; are we at end of buffer?
F0E1 2515             (   monitor1v4.asm):02964                  BLO      W_NEXTCHR                         ;   no, get another character
F0E3                  (   monitor1v4.asm):02965         W_CANCEL:
F0E3 865C             (   monitor1v4.asm):02966                  LDA      #'\'                              ; in case of CANCEL or end-of-buffer
F0E5 BDE71F           (   monitor1v4.asm):02967                  JSR      PUTCH                             ; output a \
F0E8 1A02             (   monitor1v4.asm):02968                  ORCC     #CC_V                             ; set V flag (too long or cancel)
F0EA 39               (   monitor1v4.asm):02969                  RTS                                        ; and return
F0EB                  (   monitor1v4.asm):02970         W_GETLINE:
F0EB 862A             (   monitor1v4.asm):02971                  LDA      #'*'                              ; put prompt character in A
F0ED                  (   monitor1v4.asm):02972         W_GETLNZ:                                           ; alternate entry point           
F0ED BDE731           (   monitor1v4.asm):02973                  JSR      PUTCR                             ; start a new line (A is preserved)
F0F0 BDE71F           (   monitor1v4.asm):02974                  JSR      PUTCH                             ; output the prompt char
F0F3 C601             (   monitor1v4.asm):02975                  LDB      #1                                ; Set offset to 1 (decremented next line)
F0F5                  (   monitor1v4.asm):02976         W_BACKSPC:
F0F5 5A               (   monitor1v4.asm):02977                  DECB                                       ; Back up text index.
F0F6 2BF3             (   monitor1v4.asm):02978                  BMI      W_GETLINE                         ; index<0 (start of line), reinitialize
F0F8                  (   monitor1v4.asm):02979         W_NEXTCHR:
F0F8 BDE6E7           (   monitor1v4.asm):02980                  JSR      GETCHT                            ; get a character from UART Ch A
F0FB A7C5             (   monitor1v4.asm):02981                  STA      B,U                               ; Add to text buffer.
F0FD BDE71F           (   monitor1v4.asm):02982                  JSR      PUTCH                             ; Display character.
F100 810D             (   monitor1v4.asm):02983                  CMPA     #CR                               ; CR?
F102 26CA             (   monitor1v4.asm):02984                  BNE      W_NOTCR                           ;   not a CR, keep getting input chars
F104 39               (   monitor1v4.asm):02985                  RTS                                        ;   return with V=0 (no error)
                      (   monitor1v4.asm):02986         
                      (   monitor1v4.asm):02987         ; Process an input line. Examine each character in the buffer. Handle
                      (   monitor1v4.asm):02988         ; CR (end of line), and "." (block mode) and ":" (store mode) cases. Character
                      (   monitor1v4.asm):02989         ; codes less than "." are treated as delimiters. The "R" character executes the
                      (   monitor1v4.asm):02990         ; RUN command, and the "X" character executes the S-Record download function.
                      (   monitor1v4.asm):02991         ; The "N" command jumps to NoICE debugger. The "M" command jumps to BASIC
                      (   monitor1v4.asm):02992         ; All other characters are assumed to be a hex input 'item' and parsed into
                      (   monitor1v4.asm):02993         ; W register.
                      (   monitor1v4.asm):02994         ;
                      (   monitor1v4.asm):02995         ; U is pointer to line buffer and work variables
                      (   monitor1v4.asm):02996         ; W is the WORD parsed from input line
                      (   monitor1v4.asm):02997         ; B is the index into the line buffer
                      (   monitor1v4.asm):02998         ; A is work register
                      (   monitor1v4.asm):02999         ; W_TEMP is used as part of zero-digit-length argument check
                      (   monitor1v4.asm):03000         
F105                  (   monitor1v4.asm):03001         W_PARSE:
F105 104F             (   monitor1v4.asm):03002                  CLRD                                       ; clear both A and B (A used to set XAM mode soon)
F107 5A               (   monitor1v4.asm):03003                  DECB                                       ; (B) text index -1, to become zero at BLSKIP
F108                  (   monitor1v4.asm):03004         W_SETMODE:
F108 977C             (   monitor1v4.asm):03005                  STA      <W_dMODE                          ; $00=XAM (0), $BA=STORE (-), $2E=BLOK XAM (+)
F10A                  (   monitor1v4.asm):03006         W_BLSKIP:
F10A 5C               (   monitor1v4.asm):03007                  INCB                                       ; advance text index (B,U allows only 0...127)
F10B                  (   monitor1v4.asm):03008         W_NEXTITEM:
F10B A6C5             (   monitor1v4.asm):03009                  LDA      B,U                               ; Get character
F10D 810D             (   monitor1v4.asm):03010                  CMPA     #CR                               ; is it a CR?
F10F 2763             (   monitor1v4.asm):03011                  BEQ      W_XRET                            ;  yes, done this line.
F111 812E             (   monitor1v4.asm):03012                  CMPA     #DOT                              ; is it a period?
F113 27F3             (   monitor1v4.asm):03013                  BEQ      W_SETMODE                         ; yes, set BLOCK XAM mode ($2E)
F115 23F3             (   monitor1v4.asm):03014                  BLS      W_BLSKIP                          ;  less than periods are treated as delimiters
F117 8A80             (   monitor1v4.asm):03015                  ORA      #$80                              ; convert high-bit set (for MODE stuff)
F119 81BA             (   monitor1v4.asm):03016                  CMPA     #HI_COL                           ; is it a colon?
F11B 27EB             (   monitor1v4.asm):03017                  BEQ      W_SETMODE                         ;  yes, set STORE mode ($BA)
F11D 81CD             (   monitor1v4.asm):03018                  CMPA     #HI_M                             ; is it an "M"?  ("MS Basic")
F11F 1027F4E5         (   monitor1v4.asm):03019                  LBEQ     GOBASIC                           ;   yes, jump to MS BASIC
F123 81CE             (   monitor1v4.asm):03020                  CMPA     #HI_N                             ; is it an "N"?  ("NoICE")
F125 1027F13A         (   monitor1v4.asm):03021                  LBEQ     GONOICE                           ;   yes, start NoICE debugger
F129 81D2             (   monitor1v4.asm):03022                  CMPA     #HI_R                             ; is it an "R"?  ("Run")
F12B 272C             (   monitor1v4.asm):03023                  BEQ      W_RUN                             ;   Yes, jump to current XAM index.
F12D 81D8             (   monitor1v4.asm):03024                  CMPA     #HI_X                             ; is it an "X"?  ("Hex")
F12F 272D             (   monitor1v4.asm):03025                  BEQ      W_XLOAD                           ;   yes, try to load hexfile from console
F131                  (   monitor1v4.asm):03026         W_NEWHEX:
F131 105F             (   monitor1v4.asm):03027                  CLRW                                       ; clear W (HI = E, LO = F)
F133 D77D             (   monitor1v4.asm):03028                  STB      <W_dTEMP                          ; make a copy of text buffer index
F135                  (   monitor1v4.asm):03029         W_NEXTHEX:
F135 A6C5             (   monitor1v4.asm):03030                  LDA      B,U                               ; Get character for hex test.
F137 8830             (   monitor1v4.asm):03031                  EORA     #$30                              ; Map digits to $0-9.
F139 8109             (   monitor1v4.asm):03032                  CMPA     #$09                              ; Digit?
F13B 2308             (   monitor1v4.asm):03033                  BLS      W_ADDDIG                          ; Yes.
F13D 8A20             (   monitor1v4.asm):03034                  ORA      #$20                              ; neutralize case
F13F 8B89             (   monitor1v4.asm):03035                  ADDA     #$89                              ; Map letter "a"-"f" to $FA-FF.
F141 81F9             (   monitor1v4.asm):03036                  CMPA     #$F9                              ; Hex letter?
F143 2330             (   monitor1v4.asm):03037                  BLS      W_NOTHEX                          ; No, character not hex.
F145                  (   monitor1v4.asm):03038         W_ADDDIG:
F145 840F             (   monitor1v4.asm):03039                  ANDA     #$0F                              ; isolate the hex digit value ($0-$F)
F147 1E06             (   monitor1v4.asm):03040                  EXG      D,W                               ; digit in 4lsb of E, WORD in D, buffer ptr in F
F149 1048             (   monitor1v4.asm):03041                  ASLD                                       ; shift WORD left 4 bits to make room
F14B 1048             (   monitor1v4.asm):03042                  ASLD                                       ;   for the new hex nybble
F14D 1048             (   monitor1v4.asm):03043                  ASLD
F14F 1048             (   monitor1v4.asm):03044                  ASLD
F151 1035E9           (   monitor1v4.asm):03045                  ORR      E,B                               ; OR the new digit in WORD
F154 1E06             (   monitor1v4.asm):03046                  EXG      D,W                               ; WORD back in W, buffer pointer back in B
F156 5C               (   monitor1v4.asm):03047                  INCB                                       ; advance text index
F157 20DC             (   monitor1v4.asm):03048                  BRA      W_NEXTHEX                         ; Always taken. Check next character for hex.
F159                  (   monitor1v4.asm):03049         W_RUN:
F159 3262             (   monitor1v4.asm):03050                  LEAS     2,S                               ; free up return address on stack
F15B 6ED878           (   monitor1v4.asm):03051                  JMP      [W_XAM,U]                         ; RUN command, jump to address in XAM index
F15E                  (   monitor1v4.asm):03052         W_XLOAD:
F15E BDE774           (   monitor1v4.asm):03053                  JSR      PUTMSG
F161 0D0A             (   monitor1v4.asm):03054                  FCB      CR,LF
F163 48657820446F776E (   monitor1v4.asm):03055                  FCN      "Hex Download "
     6C6F61642000
F171 BDF1E7           (   monitor1v4.asm):03056                  JSR      DL_START                          ; yes, try to download from host
F174                  (   monitor1v4.asm):03057         W_XRET:         
F174 39               (   monitor1v4.asm):03058                  RTS         
                      (   monitor1v4.asm):03059         
                      (   monitor1v4.asm):03060         ; A non-hex, non-command character has been encountered. We may have a new
                      (   monitor1v4.asm):03061         ; hex argument in WORD (if W_TEMP = B, we do NOT) and if so, we need to figure
                      (   monitor1v4.asm):03062         ; out what to do with depending on MODE. If we are already in STOR mode, then
                      (   monitor1v4.asm):03063         ; we simply store the LSB of the WORD at address in ST, then increment ST.
                      (   monitor1v4.asm):03064         ; If we are in XAM mode (which includes the address entered prior to the ':' in
                      (   monitor1v4.asm):03065         ; the command line) then WORD argument is copied to XAM and ST addresses, and we
                      (   monitor1v4.asm):03066         ; fall into the NXTPRT loop. If we're already in BLOCK XAM mode, then we take the
                      (   monitor1v4.asm):03067         ; WORD argument as the end of the block, and fall in the NXTPRT loop.
                      (   monitor1v4.asm):03068         ;
                      (   monitor1v4.asm):03069         ; U is pointer to line buffer and work variables
                      (   monitor1v4.asm):03070         ; X is work pointer
                      (   monitor1v4.asm):03071         ; W is the WORD parsed from input line (A2 in new monitor)
                      (   monitor1v4.asm):03072         ; B is the index into the line buffer
                      (   monitor1v4.asm):03073         ; A is work register
                      (   monitor1v4.asm):03074         ; W_TEMP is copy of line buffer index upon entry, but after this is
                      (   monitor1v4.asm):03075         ;        complete, it is the flow-control byte for XAM/BLOCK XAM output
                      (   monitor1v4.asm):03076         
F175                  (   monitor1v4.asm):03077         W_NOTHEX:
F175 D17D             (   monitor1v4.asm):03078                  CMPB     <W_dTEMP                          ; Check if W empty (no hex digits parsed).
F177 2769             (   monitor1v4.asm):03079                  BEQ      W_XERR                            ;  yes, bad input so return via ERROR
F179 0F7D             (   monitor1v4.asm):03080                  CLR      <W_dTEMP                          ; clear the 'flow control' byte
F17B 0D7C             (   monitor1v4.asm):03081                  TST      <W_dMODE                          ; Test MODE byte.
F17D 2A09             (   monitor1v4.asm):03082                  BPL      W_NOTSTOR                         ; B7=1 for STOR, 0 for XAM and BLOCK XAM
                      (   monitor1v4.asm):03083         ; STOR mode
F17F 9E7A             (   monitor1v4.asm):03084                  LDX      <W_dST                            ; use X to hold 'store index'
F181 11E780           (   monitor1v4.asm):03085                  STF      ,X+                               ; store LSB of WORD at 'store index'
F184 9F7A             (   monitor1v4.asm):03086                  STX      <W_dST                            ; save the incremented 'store index'
F186 2083             (   monitor1v4.asm):03087                  BRA      W_NEXTITEM                        ; Get next command item.
F188                  (   monitor1v4.asm):03088         W_NOTSTOR:
F188 2645             (   monitor1v4.asm):03089                  BNE      W_XAMNEXT                         ; mode = $00 for XAM, $56 for BLOCK XAM.
                      (   monitor1v4.asm):03090         ; non BLOCK XAM
F18A 10977A           (   monitor1v4.asm):03091                  STW      <W_dST                            ; copy word parsed into 'store index'
F18D 109778           (   monitor1v4.asm):03092                  STW      <W_dXAM                           ; copy word parsed into 'XAM index'
F190 4F               (   monitor1v4.asm):03093                  CLRA                                       ; set Z=1 to cause address display to occur
                      (   monitor1v4.asm):03094                  ; fall into NXTPRNT loop...
F191                  (   monitor1v4.asm):03095         W_NXTPRNT:
F191 2633             (   monitor1v4.asm):03096                  BNE      W_PRDATA                          ; Z=0 means skip displaying address
F193 967D             (   monitor1v4.asm):03097                  LDA      <W_dTEMP                          ; check flow control byte
F195 270C             (   monitor1v4.asm):03098                  BEQ      W?NXT1                            ;  if zero, skip waiting for character
F197 BDE6E7           (   monitor1v4.asm):03099                  JSR      GETCHT                             ; yes, flow control in effect, wait for character
F19A 8118             (   monitor1v4.asm):03100                  CMPA     #CTL_X                            ; did we get a ^X?
F19C 27D6             (   monitor1v4.asm):03101                  BEQ      W_XRET                            ;  yes, exit and get new input line
F19E 8120             (   monitor1v4.asm):03102                  CMPA     #SPACE                            ; did we get a SPACE
F1A0 2701             (   monitor1v4.asm):03103                  BEQ      W?NXT1                            ;  yes, set flow control to $20
F1A2 4F               (   monitor1v4.asm):03104                  CLRA                                       ; any other character, clear flow control
F1A3 977D             (   monitor1v4.asm):03105         W?NXT1   STA      <W_dTEMP                          ; update flow control byte
F1A5 BDE6FA           (   monitor1v4.asm):03106                  JSR      GETCH1                             ; attempt to read a character (A=0 if none)
F1A8 8120             (   monitor1v4.asm):03107                  CMPA     #SPACE                            ; is it a SPACE?
F1AA 2706             (   monitor1v4.asm):03108                  BEQ      W?NXT2                            ;   yes, set flow control to $20
F1AC 8118             (   monitor1v4.asm):03109                  CMPA     #CTL_X                            ; is it a ^X?
F1AE 27C4             (   monitor1v4.asm):03110                  BEQ      W_XRET                            ;  yes, exit and get new input line
F1B0 967D             (   monitor1v4.asm):03111                  LDA      <W_dTEMP                          ; flow unaffected by other characters
F1B2 977D             (   monitor1v4.asm):03112         W?NXT2   STA      <W_dTEMP                          ; update flow control byte
F1B4 BDE731           (   monitor1v4.asm):03113         W?NXT3   JSR      PUTCR                             ; CR for a new line
F1B7 9678             (   monitor1v4.asm):03114                  LDA      <W_dXAM                           ; 'XAM index' high-order byte.
F1B9 BDE74E           (   monitor1v4.asm):03115                  JSR      PUTBYTE
F1BC 9679             (   monitor1v4.asm):03116                  LDA      <W_dXAM+1                         ; Low-order 'Examine index' byte.
F1BE BDE74E           (   monitor1v4.asm):03117                  JSR      PUTBYTE
F1C1 863A             (   monitor1v4.asm):03118                  LDA      #':'                              ; ":".
F1C3 BDE71F           (   monitor1v4.asm):03119                  JSR      PUTCH                              ; Output it.
F1C6                  (   monitor1v4.asm):03120         W_PRDATA:
F1C6 BDE73D           (   monitor1v4.asm):03121                  JSR      PUTSPACE                          ; output a space
F1C9 A6D878           (   monitor1v4.asm):03122                  LDA      [W_XAM,U]                         ; Get data byte at 'examine index'.
F1CC BDE74E           (   monitor1v4.asm):03123                  JSR      PUTBYTE                           ; display it
F1CF                  (   monitor1v4.asm):03124         W_XAMNEXT:
F1CF 9E78             (   monitor1v4.asm):03125                  LDX      <W_dXAM                           ; use X to hold XAM index
F1D1 103761           (   monitor1v4.asm):03126                  CMPR     W,X                               ; compare XAM index to parsed address WORD
F1D4 1027FF33         (   monitor1v4.asm):03127                  LBEQ     W_NEXTITEM                        ;  same, done examining memory
F1D8 3001             (   monitor1v4.asm):03128                  LEAX     1,X                               ; increment XAM index
F1DA 9F78             (   monitor1v4.asm):03129                  STX      <W_dXAM                           ;  and save it
F1DC 9679             (   monitor1v4.asm):03130                  LDA      <(W_dXAM+1)                       ; Check low-order 'examine index' byte
F1DE 8407             (   monitor1v4.asm):03131                  ANDA     #$07                              ; set Z when 'examine index' MOD 8 = 0
F1E0 20AF             (   monitor1v4.asm):03132                  BRA      W_NXTPRNT                         ; always taken
F1E2                  (   monitor1v4.asm):03133         W_XERR:
F1E2 863F             (   monitor1v4.asm):03134                  LDA      #'?'                              ; parse ERROR
F1E4 7EE71F           (   monitor1v4.asm):03135                  JMP      PUTCH                             ; output a ? and return
                      (   monitor1v4.asm):03136         
                      (   monitor1v4.asm):03137         ;;======================================================================
                      (   monitor1v4.asm):03138         ;; S-RECORD AND INTEL HEX CONSOLE DOWNLOAD FUNCTION
                      (   monitor1v4.asm):03139         ;;======================================================================
                      (   monitor1v4.asm):03140         
                      (   monitor1v4.asm):03141         ;;
                      (   monitor1v4.asm):03142         ;; DL_START - try to download a HEX file (either S9 or IHEX) from console
                      (   monitor1v4.asm):03143         ;; inputs: none
                      (   monitor1v4.asm):03144         ;; return: V=0 : successful load (A=0)
                      (   monitor1v4.asm):03145         ;;         V=1 : error during load (A=$FF)
                      (   monitor1v4.asm):03146         ;;
F1E7                  (   monitor1v4.asm):03147         DL_START:
F1E7 8D1B             (   monitor1v4.asm):03148                  BSR      DL_REC                            ; DOWNLOAD RECORD (A=00 ready for more)
F1E9 2606             (   monitor1v4.asm):03149                  BNE      D?LO2                             ;  if Z=0 then stop reading records
F1EB BDE768           (   monitor1v4.asm):03150                  JSR      PUTCONST                          ; OUTPUT ONE DOT PER RECORD
F1EE 2E               (   monitor1v4.asm):03151                  FCC      '.'
F1EF 20F6             (   monitor1v4.asm):03152                  BRA      DL_START                          ; CONTINUE
F1F1 2A0A             (   monitor1v4.asm):03153         D?LO2    BPL      D?LO3                             ;  if N=0, no error occurred (A=01 means EOF)
F1F3 BDE774           (   monitor1v4.asm):03154                  JSR      PUTMSG
F1F6 45525200         (   monitor1v4.asm):03155                  FCN      "ERR"
F1FA 1A02             (   monitor1v4.asm):03156                  ORCC     #CC_V                             ; set V (error)         
F1FC 39               (   monitor1v4.asm):03157                  RTS
F1FD BDE774           (   monitor1v4.asm):03158         D?LO3    JSR      PUTMSG
F200 4F4B00           (   monitor1v4.asm):03159                  FCN      "OK"
F203 39               (   monitor1v4.asm):03160                  RTS
                      (   monitor1v4.asm):03161         
                      (   monitor1v4.asm):03162         ; Download a record in either MOTOROLA or INTEL hex format
F204 BDE6E2           (   monitor1v4.asm):03163         DL_REC   JSR      GETCH                             ; Get a character
F207 8118             (   monitor1v4.asm):03164                  CMPA     #CTL_X                            ; Check for ^X (CANCEL)
F209 274E             (   monitor1v4.asm):03165                  BEQ      DL_ERR                            ; yes, abort with error
F20B 813A             (   monitor1v4.asm):03166                  CMPA     #':'                              ; Start of INTEL record?
F20D 10270071         (   monitor1v4.asm):03167                  LBEQ     DL_INT                            ; Yes, download INTEL
F211 8153             (   monitor1v4.asm):03168                  CMPA     #'S'                              ; Start of MOTOROLA record?
F213 26EF             (   monitor1v4.asm):03169                  BNE      DL_REC                            ; No, keep looking
                      (   monitor1v4.asm):03170         
                      (   monitor1v4.asm):03171         ; Download a record in MOTOROLA hex format
F215 BDE6E2           (   monitor1v4.asm):03172         DL_MOT   JSR      GETCH                              ; get record type
F218 8130             (   monitor1v4.asm):03173                  CMPA     #'0'                              ; S0 header record?
F21A 27E8             (   monitor1v4.asm):03174                  BEQ      DL_REC                            ;    skip it
F21C 8135             (   monitor1v4.asm):03175                  CMPA     #'5'                              ; S5 count record?
F21E 27E4             (   monitor1v4.asm):03176                  BEQ      DL_REC                            ;    skip it
F220 8139             (   monitor1v4.asm):03177                  CMPA     #'9'                              ; S9 end of file?
F222 2738             (   monitor1v4.asm):03178                  BEQ      DL_MOT9                           ;    end of file
F224 8131             (   monitor1v4.asm):03179                  CMPA     #'1'                              ; should be a data record (S1) then!
F226 2631             (   monitor1v4.asm):03180                  BNE      DL_ERR                            ;  none of these = load error
F228 BDE78F           (   monitor1v4.asm):03181                  JSR      GETBYTE                           ; get length
F22B 292C             (   monitor1v4.asm):03182                  BVS      DL_ERR                            ; report error
F22D 1F8E             (   monitor1v4.asm):03183                  TFR      A,E                               ; start checksum in E
F22F 8003             (   monitor1v4.asm):03184                  SUBA     #3                                ; adjust length (omit address and checksum)
F231 1F8F             (   monitor1v4.asm):03185                  TFR      A,F                               ; set length in F
                      (   monitor1v4.asm):03186         ; Get address         
F233 BDE78F           (   monitor1v4.asm):03187                  JSR      GETBYTE                           ; get first byte of address
F236 2921             (   monitor1v4.asm):03188                  BVS      DL_ERR                            ; report error
F238 1F89             (   monitor1v4.asm):03189                  TFR      A,B                               ; save for later
F23A 10308E           (   monitor1v4.asm):03190                  ADDR     A,E                               ; include in checksum
F23D BDE78F           (   monitor1v4.asm):03191                  JSR      GETBYTE                           ; get next byte of address
F240 2917             (   monitor1v4.asm):03192                  BVS      DL_ERR                            ; report error
F242 1E89             (   monitor1v4.asm):03193                  EXG      A,B                               ; swap address halves (endian stuff)
F244 1F01             (   monitor1v4.asm):03194                  TFR      D,X                               ; set pointer
F246 10309E           (   monitor1v4.asm):03195                  ADDR     B,E                               ; include in checksum
                      (   monitor1v4.asm):03196         ; Get data bytes         
F249 8D24             (   monitor1v4.asm):03197                  BSR      DL_BYTES
F24B 290C             (   monitor1v4.asm):03198                  BVS      DL_ERR
                      (   monitor1v4.asm):03199         ; get checksum byte
F24D BDE78F           (   monitor1v4.asm):03200                  JSR      GETBYTE                           
F250 2907             (   monitor1v4.asm):03201                  BVS      DL_ERR                            ; report error
F252 10308E           (   monitor1v4.asm):03202                  ADDR     A,E                               ; add to computed checksum
F255 114C             (   monitor1v4.asm):03203                  INCE                                       ; test for success
F257 2714             (   monitor1v4.asm):03204                  BEQ      DL_RTS                            ; download ok
                      (   monitor1v4.asm):03205         
                      (   monitor1v4.asm):03206         ; Error occurred on loading
F259 86FF             (   monitor1v4.asm):03207         DL_ERR   LDA      #$FF                              ; A=$FF if an error occurred (N is set, Z is clear)
F25B 39               (   monitor1v4.asm):03208                  RTS
                      (   monitor1v4.asm):03209         
                      (   monitor1v4.asm):03210         ; properly handle S9 end record (just eat it)
F25C BDE78F           (   monitor1v4.asm):03211         DL_MOT9  JSR      GETBYTE                           ; get length byte
F25F 29F8             (   monitor1v4.asm):03212                  BVS      DL_ERR                            ; report error
F261 1F8F             (   monitor1v4.asm):03213                  TFR      A,F                               ; save length
F263 BDE78F           (   monitor1v4.asm):03214         DL_MOT10 JSR      GETBYTE                           ; get next byte (ignore it)
F266 115A             (   monitor1v4.asm):03215                  DECF                                       ; reduce length
F268 26F9             (   monitor1v4.asm):03216                  BNE      DL_MOT10                          ; get all the bytes
                      (   monitor1v4.asm):03217         ; fall into DLEOF...
                      (   monitor1v4.asm):03218         
                      (   monitor1v4.asm):03219         ; Record download successful, EOF marker encountered
F26A 8601             (   monitor1v4.asm):03220         DL_EOF   LDA      #$01                              ; A=$01 if EOF is reached (N and Z both clear)
F26C 39               (   monitor1v4.asm):03221                  RTS
                      (   monitor1v4.asm):03222         
                      (   monitor1v4.asm):03223         ; Record download successful, expecting another record
F26D 4F               (   monitor1v4.asm):03224         DL_RTS   CLRA                                       ; A=$00 if another record is needed (Z set, N clear)
F26E 39               (   monitor1v4.asm):03225                  RTS
                      (   monitor1v4.asm):03226         
                      (   monitor1v4.asm):03227         ; Download F number of bytes from console, storing in memory at X, and 
                      (   monitor1v4.asm):03228         ; maintaining running checksum in E. Exit with V=1 on error.
F26F 115D             (   monitor1v4.asm):03229         DL_BYTES TSTF                                       ; examine # of bytes to get
F271 270E             (   monitor1v4.asm):03230                  BEQ      D?LBX                             ;   zero, nothing to do!
F273 BDE78F           (   monitor1v4.asm):03231                  JSR      GETBYTE                           ; get data byte
F276 2909             (   monitor1v4.asm):03232                  BVS      D?LBX                             ; exit with V=1 on error
F278 A780             (   monitor1v4.asm):03233                  STA      ,X+                               ; Write to memory
F27A 10308E           (   monitor1v4.asm):03234                  ADDR     A,E                               ; include in checksum
F27D 115A             (   monitor1v4.asm):03235                  DECF                                       ; reduce length
F27F 26EE             (   monitor1v4.asm):03236                  BNE      DL_BYTES                          ; Do them all
F281 39               (   monitor1v4.asm):03237         D?LBX    RTS
                      (   monitor1v4.asm):03238         
                      (   monitor1v4.asm):03239         ; Download record in INTEL format
F282 BDE78F           (   monitor1v4.asm):03240         DL_INT   JSR      GETBYTE                           ; get count
F285 29D2             (   monitor1v4.asm):03241                  BVS      DL_ERR                            ; report error
F287 1F8E             (   monitor1v4.asm):03242                  TFR      A,E                               ; start checksum in E
F289 1F8F             (   monitor1v4.asm):03243                  TFR      A,F                               ; set length in F
                      (   monitor1v4.asm):03244         ; Get address
F28B BDE78F           (   monitor1v4.asm):03245                  JSR      GETBYTE                           ; get first byte of address
F28E 29C9             (   monitor1v4.asm):03246                  BVS      DL_ERR                            ; report error
F290 1F89             (   monitor1v4.asm):03247                  TFR      A,B                               ; Save for later
F292 10308E           (   monitor1v4.asm):03248                  ADDR     A,E                               ; include in checksum
F295 BDE78F           (   monitor1v4.asm):03249                  JSR      GETBYTE                           ; get next byte of address
F298 29BF             (   monitor1v4.asm):03250                  BVS      DL_ERR                            ; report error
F29A 1E89             (   monitor1v4.asm):03251                  EXG      A,B                               ; Swap
F29C 1F01             (   monitor1v4.asm):03252                  TFR      D,X                               ; Set pointer
F29E 10309E           (   monitor1v4.asm):03253                  ADDR     B,E                               ; include in checksum
                      (   monitor1v4.asm):03254         ; Get record type
F2A1 115C             (   monitor1v4.asm):03255                  INCF                                       ; temporarily increment length (EOF 0->1)
F2A3 BDE78F           (   monitor1v4.asm):03256                  JSR      GETBYTE                           ; get type value
F2A6 29B1             (   monitor1v4.asm):03257                  BVS      DL_ERR                            ; report error
F2A8 8101             (   monitor1v4.asm):03258                  CMPA     #1                                ; EOF record?
F2AA 27B7             (   monitor1v4.asm):03259                  BEQ      DL_MOT10                          ;   yes, eat 1 byte and return with EOF status
F2AC 10308E           (   monitor1v4.asm):03260                  ADDR     A,E                               ; include type in checksum
F2AF 115A             (   monitor1v4.asm):03261                  DECF                                       ; back to correct length 
                      (   monitor1v4.asm):03262         ; Get data bytes
F2B1 8DBC             (   monitor1v4.asm):03263                  BSR      DL_BYTES                          ; get F# of data bytes (return with zero length)
F2B3 29A4             (   monitor1v4.asm):03264                  BVS      DL_ERR                            ; report error
                      (   monitor1v4.asm):03265         ; Get checksum
F2B5 BDE78F           (   monitor1v4.asm):03266                  JSR      GETBYTE                           ; Read checksum byte
F2B8 299F             (   monitor1v4.asm):03267                  BVS      DL_ERR                            ; Report error
F2BA 10308E           (   monitor1v4.asm):03268                  ADDR     A,E                               ; add to computed checksum
F2BD 27AE             (   monitor1v4.asm):03269                  BEQ      DL_RTS                            ; Report success
F2BF 2098             (   monitor1v4.asm):03270                  BRA      DL_ERR                            ; Report failure
                      (   monitor1v4.asm):03271         
                      (   monitor1v4.asm):03272                  ORG      JUMP_TABLE
FF40 E69C             (   monitor1v4.asm):03273                  FDB      SCC_InitA                         ; initialize SCC channel A
FF42 E6A7             (   monitor1v4.asm):03274                  FDB      SCC_InitB                         ; initialize SCC channel B
FF44 E6E2             (   monitor1v4.asm):03275                  FDB      GETCH                             ; wait for character from CONSOLE
FF46 E6FA             (   monitor1v4.asm):03276                  FDB      GETCH1                            ; attempt to get character from CONSOLE
FF48 E7A2             (   monitor1v4.asm):03277                  FDB      GETNIB                            ; get a HEX NYBBLE from CONSOLE
FF4A E78F             (   monitor1v4.asm):03278                  FDB      GETBYTE                           ; get a HEX BYTE from CONSOLE
FF4C E7BD             (   monitor1v4.asm):03279                  FDB      GETBDIG                           ; get a bounded hex digit from CONSOLE
FF4E F0ED             (   monitor1v4.asm):03280                  FDB      W_GETLNZ                          ; get a ^X/CR terminated line from CONSOLE
FF50 0000000000000000 (   monitor1v4.asm):03281                  FILL $00,(4*2)                             ; room for future expansion                  
FF58 E71F             (   monitor1v4.asm):03282                  FDB      PUTCH                             ; output character to CONSOLE
FF5A E758             (   monitor1v4.asm):03283                  FDB      PUTHEX                            ; output HEX NYBBLE to CONSOLE
FF5C E74E             (   monitor1v4.asm):03284                  FDB      PUTBYTE                           ; output HEX BYTE to CONSOLE
FF5E E745             (   monitor1v4.asm):03285                  FDB      PUTWORD                           ; output HEX WORD to CONSOLE
FF60 E774             (   monitor1v4.asm):03286                  FDB      PUTMSG                            ; output ASCIIZ message at PC to CONSOLE
FF62 E77E             (   monitor1v4.asm):03287                  FDB      PUTSTR                            ; output ASCIIZ message at X to CONSOLE
FF64 E731             (   monitor1v4.asm):03288                  FDB      PUTCR                             ; output a CR+LF to CONSOLE
FF66 0000000000000000 (   monitor1v4.asm):03289                  FILL $00,(4*2)                             ; room for future expansion         
FF6E ECFD             (   monitor1v4.asm):03290                  FDB      DBGETCH1                          ; attempt to get character from DEBUG
FF70 ED22             (   monitor1v4.asm):03291                  FDB      DBPUTCH                           ; output character to DEBUG
FF72 E65F             (   monitor1v4.asm):03292                  FDB      CIO_Initialize                    ; initialize CIO to default state
FF74 E684             (   monitor1v4.asm):03293                  FDB      CIO_ReadReg                       ; read CIO register
FF76 E690             (   monitor1v4.asm):03294                  FDB      CIO_WriteReg                      ; write CIO register
FF78 00000000         (   monitor1v4.asm):03295                  FILL $00,(2*2)                             ; room for future expansion
FF7C E8CA             (   monitor1v4.asm):03296                  FDB      RTC_ReadByte                      ; read byte from I2C RTC
FF7E E948             (   monitor1v4.asm):03297                  FDB      RTC_ReadBlock                     ; read block of bytes from I2C RTC
FF80 E944             (   monitor1v4.asm):03298                  FDB      RTC_ReadRegs                      ; read I2C RTC registers 0-15
FF82 E8F2             (   monitor1v4.asm):03299                  FDB      RTC_WriteByte                     ; write byte to I2C RTC
FF84 E911             (   monitor1v4.asm):03300                  FDB      RTC_WriteBlock                    ; write block of bytes to I2C RTC
FF86 E90D             (   monitor1v4.asm):03301                  FDB      RTC_WriteRegs                     ; write I2C RTC registers 0-15
FF88 E9C5             (   monitor1v4.asm):03302                  FDB      RTC_FmtTime                       ; create formatted ASCII time string
FF8A E97A             (   monitor1v4.asm):03303                  FDB      RTC_FmtDate                       ; create formatted ASCII date string
FF8C 0000000000000000 (   monitor1v4.asm):03304                  FILL $00,(4*2)                             ; room for future expansion         
FF94 EA49             (   monitor1v4.asm):03305                  FDB      SPI_Read                          ; SPI read byte (send $FF)
FF96 EA51             (   monitor1v4.asm):03306                  FDB      SPI_ReadBlock                     ; SPI read block (send $FF)
FF98 EA39             (   monitor1v4.asm):03307                  FDB      SPI_Write                         ; SPI write byte
FF9A EA61             (   monitor1v4.asm):03308                  FDB      SPI_WriteBlock                    ; SPI write block         
FF9C 0000000000000000 (   monitor1v4.asm):03309                  FILL $00,(4*2)                             ; room for future expansion                  
FFA4 EAAF             (   monitor1v4.asm):03310                  FDB      SD_Initialize                     ; initialize SD card
FFA6 EBE3             (   monitor1v4.asm):03311                  FDB      SD_SendCmd                        ; send command to SD card, get R1 response
FFA8 EC0B             (   monitor1v4.asm):03312                  FDB      SD_GetR7                          ; get R7 response after command
FFAA EC5B             (   monitor1v4.asm):03313                  FDB      SD_ReadBlock                      ; read LBA block from SD card
FFAC EC9B             (   monitor1v4.asm):03314                  FDB      SD_WriteBlock                     ; write LBA block to SD card
FFAE ECE4             (   monitor1v4.asm):03315                  FDB      SD_WaitReady                      ; wait for SD card to complete write operation
FFB0 0000000000000000 (   monitor1v4.asm):03316                  FILL $00,(4*2)                             ; room for future expansion
FFB8 E804             (   monitor1v4.asm):03317                  FDB      DELAYMS                           ; delay X * ms
FFBA E813             (   monitor1v4.asm):03318                  FDB      DELAYUS                           ; delay X * 10us
FFBC E64E             (   monitor1v4.asm):03319                  FDB      MOVEMON                           ; move MONITOR to RAM, select RAM
FFBE F1E7             (   monitor1v4.asm):03320                  FDB      DL_START                          ; HEXFILE DOWNLOAD via CONSOLE port
FFC0 F0EB             (   monitor1v4.asm):03321                  FDB      W_GETLINE                         ; get CR/^X terminated ASCII input line
FFC2 0000000000000000 (   monitor1v4.asm):03322                  FILL $00,(HARD_VECT-*-2)         
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     00000000
FFEE 0141             (   monitor1v4.asm):03323                  FDB      _MONITOR_REV                      ; monitor revision (e.g. $01,$41)
                      (   monitor1v4.asm):03324         
                      (   monitor1v4.asm):03325         ; VECTORS THROUGH RAM
                      (   monitor1v4.asm):03326                  ORG      HARD_VECT
FFF0 F013             (   monitor1v4.asm):03327                  FDB      TRAP_ENT                          ; fff0 (reserved/trap)
FFF2 F01A             (   monitor1v4.asm):03328                  FDB      SWI3_ENT                          ; fff2 (SWI3)
FFF4 F021             (   monitor1v4.asm):03329                  FDB      SWI2_ENT                          ; fff4 (SWI2)
FFF6 F028             (   monitor1v4.asm):03330                  FDB      FIRQ_ENT                          ; fff6 (FIRQ)
FFF8 F070             (   monitor1v4.asm):03331                  FDB      IRQ_ENT                           ; fff8 (IRQ)
FFFA F07E             (   monitor1v4.asm):03332                  FDB      SWI_ENT                           ; fffa (SWI/breakpoint)
FFFC F077             (   monitor1v4.asm):03333                  FDB      NMI_ENT                           ; fffc (NMI)
FFFE                  (   monitor1v4.asm):03334         V_RESET
FFFE E20C             (   monitor1v4.asm):03335                  FDB      RESET                             ; fffe reset
                      (   monitor1v4.asm):03336         ;
                      (   monitor1v4.asm):03337                  END      RESET

Symbol Table:
[ G] _MONITOR_REV                     0141
[ G] B0                               ED3C
[ G] B1                               ED3D
[ G] BANNER                           E000
[ G] BANNER_END                       E1FB
[ G] BSWAP                            E618
[ G] CC_C                             0001
[ G] CC_E                             0080
[ G] CC_F                             0040
[ G] CC_H                             0020
[ G] CC_I                             0010
[ G] CC_N                             0008
[ G] CC_V                             0002
[ G] CC_Z                             0004
[ G] CHECKSUM                         F004
[ G] CHK10                            F00D
[ G] CIO_Initialize                   E65F
[ G] CIO_ReadReg                      E684
[ G] CIO_WriteReg                     E690
[ G] CIOA                             E002
[ G] CIOB                             E001
[ G] CIOC                             E000
[ G] CIOCTL                           E003
[ G] COMBUF                           BF00
[ G] COMBUF_SIZE                      0080
[ G] COMMON_TEXT_BUFFER               0001
[ G] CONSOLE_CH                       0001
[ G] CONSOLE_CMD                      E012
[ G] CONSOLE_DAT                      E013
[ G] CONSOLE_INIT                     E69C
[ G] COPY_MON_TO_RAM                  0001
[ G] CPLDVER                          E060
[ G] CPU_FREQ_MHZ                     0003
[ G] CR                               000D
[ G] CT_BLOCK                         0008
[ G] CT_MMC                           0001
[ G] CT_SD1                           0002
[ G] CT_SD2                           0004
[ G] CTL_C                            0003
[ G] CTL_H                            0008
[ G] CTL_S                            0013
[ G] CTL_X                            0018
[ G] DBGETCH                          ED05
[ G] DBGETCH1                         ECFD
[ G] DBPUTCH                          ED22
[ G] DEBUG_CH                         0002
[ G] DEBUG_CMD                        E010
[ G] DEBUG_DAT                        E011
[ G] DEBUG_INIT                       E6A7
[ G] DEL                              007F
[ G] DELAYMS                          E804
[ G] DELAYUS                          E813
[ G] DL_BYTES                         F26F
[ G] DL_EOF                           F26A
[ G] DL_ERR                           F259
[ G] DL_INT                           F282
[ G] DL_MOT                           F215
[ G] DL_MOT10                         F263
[ G] DL_MOT9                          F25C
[ G] DL_REC                           F204
[ G] DL_RTS                           F26D
[ G] DL_START                         F1E7
[ G] DOT                              002E
[ G] E_FLAG                           BFB9
[ G] ENTER_MON                        EF87
[ G] ESC                              001B
[ G] EXC_STUB                         E607
[ G] FALSE                            0000
[ G] FE1                              F051
[ G] FIRQ9                            F05A
[ G] FIRQ9B                           F067
[ G] FIRQ_ENT                         F028
[ G] FMTBCD                           E9B8
[ G] FN_ERROR                         00F0
[ G] FN_GET_STAT                      00FF
[ G] FN_IN                            00F8
[ G] FN_MIN                           00F7
[ G] FN_OUT                           00F7
[ G] FN_READ_MEM                      00FE
[ G] FN_READ_RG                       00FC
[ G] FN_RUN_TARG                      00FA
[ G] FN_SET_BYTE                      00F9
[ G] FN_WRITE_M                       00FD
[ G] FN_WRITE_RG                      00FB
[ G] GETBDIG                          E7BD
[ G] GETBYTE                          E78F
[ G] GETCH                            E6E2
[ G] GETCH1                           E6FA
[ G] GETCH2                           E702
[ G] GETCHT                           E6E7
[ G] GETNIB                           E7A2
[ G] GETPATT                          E7CC
[ G] GLP                              EEBE
[ G] GLP90                            EEC5
[ G] GOBASIC                          E608
[ G] GOBOOT                           E510
[ G] GOHELP                           E33F
[ G] GONOICE                          E263
[ G] GORTC                            E375
[ G] GORTC1                           E397
[ G] GOWOZ                            E331
[ G] GRLP                             EEFF
[ G] HARD_VECT                        FFF0
[ G] HI_COL                           00BA
[ G] HI_M                             00CD
[ G] HI_N                             00CE
[ G] HI_R                             00D2
[ G] HI_X                             00D8
[ G] I2C.DSCL                         0080
[ G] I2C.DSDA                         0040
[ G] I2C.MSCL                         0008
[ G] I2C.MSDA                         0004
[ G] I2C_ACKNOWLEDGE                  0001
[ G] I2C_BusError                     0002
[ G] I2C_GoMaster                     E8A5
[ G] I2C_Initialize                   E822
[ G] I2C_NoSlaveAck                   0001
[ G] I2C_NOTACKNOWLEDGE               0000
[ G] I2C_RcvByte                      E861
[ G] I2C_ReadBlock                    E94B
[ G] I2C_ReadByte                     E8CD
[ G] I2C_SendACK                      E889
[ G] I2C_SendByte                     E82D
[ G] I2C_SendNAK                      E88F
[ G] I2C_SendStop                     E852
[ G] I2C_SN0                          E893
[ G] I2C_Success                      0000
[ G] I2C_WriteBlock                   E914
[ G] I2C_WriteByte                    E8F5
[ G] I2CPORT                          E020
[ G] I_ERR                            E93E
[ G] I_ERRX                           E93C
[ G] I_OK                             E936
[ G] I_OKX                            E934
[ G] IE_10                            EDBB
[ G] IE_11                            EDD7
[ G] IE_12                            EDDE
[ G] IN_PORT                          EFC9
[ G] INITSTACK                        BF00
[ G] INT_ENTRY                        EDA2
[ G] IO.LED1                          0001
[ G] IO.LED2                          0002
[ G] IO.PB                            0008
[ G] IO.SDBSY                         0040
[ G] IO.SDCLK                         0020
[ G] IO.SDCS                          0010
[ G] IO.SDSW                          0080
[ G] IOPAGE                           E000
[ G] IOPORT                           E050
[ G] IRQ_ENT                          F070
[ G] IS0                              E6B0
[ G] JIN_PORT                         EE96
[ G] JOUT_PORT                        EE99
[ G] JREAD_MEM                        EE84
[ G] JREAD_REGS                       EE8A
[ G] JRUN_TARGET                      EE90
[ G] JSET_BYTES                       EE93
[ G] JUMP_TABLE                       FF40
[ G] JWRITE_MEM                       EE87
[ G] JWRITE_REGS                      EE8D
[ G] LF                               000A
[ G] MA05                             EE1B
[ G] MA10                             EE37
[ G] MA80                             EE41
[ G] MAIN                             EE14
[ G] MD_RETURN                        F0A7
[ G] MD_TEST                          F083
[ G] MONSTACK                         BFAB
[ G] MOVEMON                          E64E
[ G] MOVEUP                           E629
[ G] NMI_ENT                          F077
[ G] NOICE                            ED4E
[ G] NOTBP                            EE09
[ G] NVEC                             0008
[ G] OUT_PORT                         EFD4
[ G] PUTBYTE                          E74E
[ G] PUTCH                            E71F
[ G] PUTCONST                         E768
[ G] PUTCR                            E731
[ G] PUTCR1                           E733
[ G] PUTHEX                           E758
[ G] PUTMSG                           E774
[ G] PUTSPACE                         E73D
[ G] PUTSTR                           E77E
[ G] PUTWORD                          E745
[ G] R_DATEPAT                        E4F8
[ G] R_TIMEPAT                        E4E6
[ G] RAM_END                          BFD1
[ G] RAM_START                        BF00
[ G] RAMSEL                           E642
[ G] RAMVEC                           BF83
[ G] READ_MEM                         EEB1
[ G] READ_REGS                        EEF4
[ G] REG_A                            BFC9
[ G] REG_B                            BFC8
[ G] REG_CC                           BFCB
[ G] REG_DP                           BFCA
[ G] REG_E                            BFC7
[ G] REG_F                            BFC6
[ G] REG_MD                           BFCC
[ G] REG_PAGE                         BFBD
[ G] REG_PC                           BFCF
[ G] REG_SP                           BFBE
[ G] REG_STATE                        BFBC
[ G] REG_U                            BFC0
[ G] REG_V                            BFCD
[ G] REG_X                            BFC4
[ G] REG_Y                            BFC2
[ G] RES10                            ED60
[ G] RES11                            F08E
[ G] RESET                            E20C
[ G] RESET0                           E245
[ G] RESET1                           E26E
[ G] RESET2                           E2EB
[ G] RETURN_REGS                      EEF4
[ G] ROMH_START                       E200
[ G] ROML_START                       C000
[ G] RT_10                            EF75
[ G] RTC.ADDRESS                      00D0
[ G] RTC.CONTROL                      000E
[ G] RTC.DAY                          0004
[ G] RTC.HOURS                        0002
[ G] RTC.MINUTES                      0001
[ G] RTC.MONTH                        0005
[ G] RTC.SECONDS                      0000
[ G] RTC.STATUS                       000F
[ G] RTC.WEEKDAY                      0003
[ G] RTC.YEAR                         0006
[ G] RTC_ClearStatus                  E8EF
[ G] RTC_DISNMI                       E4C8
[ G] RTC_ENNMI                        E4AA
[ G] RTC_FmtDate                      E97A
[ G] RTC_FmtTime                      E9C5
[ G] RTC_NMIDisable                   EA21
[ G] RTC_NMIEnable                    EA07
[ G] RTC_ReadBlock                    E948
[ G] RTC_ReadByte                     E8CA
[ G] RTC_ReadRegs                     E944
[ G] RTC_ReadStatus                   E8C8
[ G] RTC_SETD                         E426
[ G] RTC_SETT                         E40A
[ G] RTC_WriteBlock                   E911
[ G] RTC_WriteByte                    E8F2
[ G] RTC_WriteRegs                    E90D
[ G] RTCERR                           E495
[ G] RTCIE                            E47B
[ G] RTCIF                            E490
[ G] RTCISR                           EA34
[ G] RTCS0                            E442
[ G] RUN_TARGET                       EF1B
[ G] RV_FIRQ                          BF89
[ G] RV_IRQ                           BF8B
[ G] RV_NMI                           BF8F
[ G] RV_SWI                           BF8D
[ G] RV_SWI2                          BF87
[ G] RV_SWI3                          BF85
[ G] RV_TRAP                          BF83
[ G] S_IMAGE                          BFBA
[ G] SB10                             EFA6
[ G] SB90                             EFC6
[ G] SB99                             EFC6
[ G] SCC_CHA                          0001
[ G] SCC_CHB                          0002
[ G] SCC_InitA                        E69C
[ G] SCC_InitB                        E6A7
[ G] SCCATBL                          E6C2
[ G] SCCBTBL                          E6D2
[ G] SD.A0                            0004
[ G] SD.A1                            0003
[ G] SD.A2                            0002
[ G] SD.A3                            0001
[ G] SD.CMD                           0000
[ G] SD.CRC                           0005
[ G] SD.OCR0                          0001
[ G] SD.OCR1                          0002
[ G] SD.OCR2                          0003
[ G] SD.OCR3                          0004
[ G] SD.R1                            0000
[ G] SD_ACMD41                        0069
[ G] SD_CMD0                          0040
[ G] SD_CMD0CRC                       0095
[ G] SD_CMD16                         0050
[ G] SD_CMD17                         0051
[ G] SD_CMD24                         0058
[ G] SD_CMD41CRC                      0077
[ G] SD_CMD55                         0077
[ G] SD_CMD55CRC                      0065
[ G] SD_CMD58                         007A
[ G] SD_CMD58CRC                      00FD
[ G] SD_CMD8                          0048
[ G] SD_CMD8CRC                       0087
[ G] SD_DisplayR1                     EC24
[ G] SD_DisplayR7                     EC3A
[ G] SD_GetR7                         EC0B
[ G] SD_Initialize                    EAAF
[ G] SD_NativeMode                    EA8F
[ G] SD_NOCRC                         0001
[ G] SD_ReadBlock                     EC5B
[ G] SD_SendCmd                       EBE3
[ G] SD_WaitReady                     ECE4
[ G] SD_WriteBlock                    EC9B
[ G] SD_XCMD0                         EA71
[ G] SD_XCMD41                        EA7D
[ G] SD_XCMD55                        EA83
[ G] SD_XCMD58                        EA89
[ G] SD_XCMD8                         EA77
[ G] SDPORT                           E030
[ G] SEND                             EFEC
[ G] SEND_STATUS                      EFE2
[ G] SET_BYTES                        EF9B
[ G] SND10                            EFF9
[ G] SPACE                            0020
[ G] SPI_Read                         EA49
[ G] SPI_ReadBlock                    EA51
[ G] SPI_Write                        EA39
[ G] SPI_WriteBlock                   EA61
[ G] SPI_Xcg                          EA4B
[ G] SWI2_ENT                         F021
[ G] SWI3_ENT                         F01A
[ G] SWI_ENT                          F07E
[ G] SYS.RA14                         0008
[ G] SYS.ROMSEH                       0004
[ G] SYS.ROMSEL                       0002
[ G] SYS.ROMWS                        0001
[ G] SYSCFG                           E040
[ G] TARGET_STAT                      EE9C
[ G] TASK_REG_SZ                      0015
[ G] TASK_REGS                        BFBC
[ G] TEST_STACK                       BFAB
[ G] TIM10U                           0006
[ G] TIM1M                            0258
[ G] TRAP_ENT                         F013
[ G] TRUE                             0001
[ G] TS10                             EEA7
[ G] TSTG                             ED34
[ G] TSTG_SIZE                        001A
[ G] V_RESET                          FFFE
[ G] W_ADDDIG                         F145
[ G] W_BACKSPC                        F0F5
[ G] W_BLSKIP                         F10A
[ G] W_CANCEL                         F0E3
[ G] W_dMODE                          BF7C
[ G] W_dST                            BF7A
[ G] W_dTEMP                          BF7D
[ G] W_dXAM                           BF78
[ G] W_GETLINE                        F0EB
[ G] W_GETLNZ                         F0ED
[ G] W_INLEN                          0078
[ G] W_NEWHEX                         F131
[ G] W_NEXTCHR                        F0F8
[ G] W_NEXTHEX                        F135
[ G] W_NEXTITEM                       F10B
[ G] W_NOTCR                          F0CE
[ G] W_NOTHEX                         F175
[ G] W_NOTSTOR                        F188
[ G] W_NXTPRNT                        F191
[ G] W_OFFS                           BF00
[ G] W_PARSE                          F105
[ G] W_PRDATA                         F1C6
[ G] W_RUN                            F159
[ G] W_SETMODE                        F108
[ G] W_XAM                            0078
[ G] W_XAMNEXT                        F1CF
[ G] W_XERR                           F1E2
[ G] W_XLOAD                          F15E
[ G] W_XRET                           F174
[ G] WLP                              EED9
[ G] WLP20                            EEE2
[ G] WLP50                            EEEB
[ G] WLP80                            EEEF
[ G] WLP90                            EEF1
[ G] WOZ3                             F0C6
[ G] WOZ_RAM                          BF00
[ G] WOZMON                           F0B0
[ G] WRITE_MEM                        EEC8
[ G] WRITE_REGS                       EF09
[ G] WRR80                            EF17
[ G] WRRLP                            EF10
[ G] ZCIO                             E000
[ G] ZSCC                             E010
[ G] ZSCC.RXBF                        0001
[ G] ZSCC.TXBE                        0004
[ G] ZSCCAC                           E012
[ G] ZSCCAD                           E013
[ G] ZSCCBC                           E010
[ G] ZSCCBD                           E011
